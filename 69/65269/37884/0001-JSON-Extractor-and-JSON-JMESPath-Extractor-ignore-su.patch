From 5a92c119c4ceb0d5ffb296fe921378a1630fb025 Mon Sep 17 00:00:00 2001
From: Felix Schumacher <felix.schumacher@internetallee.de>
Date: Sun, 30 May 2021 20:39:18 +0200
Subject: [PATCH] JSON Extractor and JSON JMESPath Extractor ignore sub-samples

The UI for those elements suggest, that the extractors would
look into sub-samples for matches (or even could be configured
to use only values from the sub-samples). Adapt the implementation
to make that assumption true.

Bugzilla Id: 65269
---
 .../json/jmespath/JMESPathExtractor.java      | 48 ++++++++++++-------
 .../json/jsonpath/JSONPostProcessor.java      | 27 +++++++----
 2 files changed, 47 insertions(+), 28 deletions(-)

diff --git a/src/components/src/main/java/org/apache/jmeter/extractor/json/jmespath/JMESPathExtractor.java b/src/components/src/main/java/org/apache/jmeter/extractor/json/jmespath/JMESPathExtractor.java
index 78e72da579..8cad7e6346 100644
--- a/src/components/src/main/java/org/apache/jmeter/extractor/json/jmespath/JMESPathExtractor.java
+++ b/src/components/src/main/java/org/apache/jmeter/extractor/json/jmespath/JMESPathExtractor.java
@@ -20,7 +20,10 @@ package org.apache.jmeter.extractor.json.jmespath;
 import java.io.IOException;
 import java.io.Serializable;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
+import java.util.stream.Collectors;
 
 import org.apache.commons.lang3.StringUtils;
 import org.apache.jmeter.processor.PostProcessor;
@@ -38,6 +41,8 @@ import com.fasterxml.jackson.databind.JsonNode;
 import com.fasterxml.jackson.databind.ObjectMapper;
 import com.fasterxml.jackson.databind.node.ArrayNode;
 
+import io.burt.jmespath.Expression;
+
 /**
  * JMESPATH based extractor
  *
@@ -60,7 +65,7 @@ public class JMESPathExtractor extends AbstractScopedTestElement
     public void process() {
         JMeterContext context = getThreadContext();
         JMeterVariables vars = context.getVariables();
-        String jsonResponse = getData(vars, context);
+        List<String> jsonResponse = getData(vars, context);
         String refName = getRefName();
         String defaultValue = getDefaultValue();
         int matchNumber;
@@ -71,21 +76,25 @@ public class JMESPathExtractor extends AbstractScopedTestElement
         }
         final String jsonPathExpression = getJmesPathExpression().trim();
         clearOldRefVars(vars, refName);
-        if (StringUtils.isEmpty(jsonResponse)) {
+        if (jsonResponse.isEmpty()) {
             handleEmptyResponse(vars, refName, defaultValue);
             return;
         }
 
         try {
-            JsonNode actualObj = OBJECT_MAPPER.readValue(jsonResponse, JsonNode.class);
-            JsonNode result = JMESPathCache.getInstance().get(jsonPathExpression).search(actualObj);
-            if (result.isNull()) {
-                handleNullResult(vars, refName, defaultValue, matchNumber);
-                return;
+            List<String> resultList = new ArrayList<>();
+            Expression<JsonNode> searchExpression = JMESPathCache.getInstance().get(jsonPathExpression);
+            for (String response: jsonResponse) {
+                JsonNode actualObj = OBJECT_MAPPER.readValue(response, JsonNode.class);
+                JsonNode result = searchExpression.search(actualObj);
+                if (result.isNull()) {
+                    continue;
+                }
+                resultList.addAll(splitJson(result));
             }
-            List<String> resultList = splitJson(result);
             // if more than one value extracted, suffix with "_index"
-            if (resultList.size() > 1) {
+            int size = resultList.size();
+            if (size > 1) {
                 handleListResult(vars, refName, defaultValue, matchNumber, resultList);
             } else if (resultList.isEmpty()){
                 handleNullResult(vars, refName, defaultValue, matchNumber);
@@ -94,7 +103,7 @@ public class JMESPathExtractor extends AbstractScopedTestElement
                 // else just one value extracted
                 handleSingleResult(vars, refName, matchNumber, resultList);
             }
-            vars.put(refName + REF_MATCH_NR, Integer.toString(resultList.size()));
+            vars.put(refName + REF_MATCH_NR, Integer.toString(size));
         } catch (Exception e) {
             // if something wrong, default value added
             if (log.isDebugEnabled()) {
@@ -155,23 +164,26 @@ public class JMESPathExtractor extends AbstractScopedTestElement
         vars.put(refName, defaultValue);
     }
 
-    private String getData(JMeterVariables vars, JMeterContext context) {
-        String jsonResponse = null;
+    private List<String> getData(JMeterVariables vars, JMeterContext context) {
         if (isScopeVariable()) {
-            jsonResponse = vars.get(getVariableName());
+            String jsonResponse = vars.get(getVariableName());
             if (log.isDebugEnabled()) {
                 log.debug("JMESExtractor is using variable: {}, which content is: {}", getVariableName(), jsonResponse);
             }
+            return Arrays.asList(jsonResponse);
         } else {
             SampleResult previousResult = context.getPreviousResult();
             if (previousResult != null) {
-                jsonResponse = previousResult.getResponseDataAsString();
-            }
-            if (log.isDebugEnabled()) {
-                log.debug("JMESExtractor {} working on Response: {}", getName(), jsonResponse);
+                List<String> results = getSampleList(previousResult).stream()
+                        .map(SampleResult::getResponseDataAsString)
+                        .collect(Collectors.toList());
+                if (log.isDebugEnabled()) {
+                    log.debug("JMESExtractor {} working on Responses: {}", getName(), results);
+                }
+                return results;
             }
         }
-        return jsonResponse;
+        return Collections.emptyList();
     }
 
     public List<String> splitJson(JsonNode jsonNode) throws IOException {
diff --git a/src/components/src/main/java/org/apache/jmeter/extractor/json/jsonpath/JSONPostProcessor.java b/src/components/src/main/java/org/apache/jmeter/extractor/json/jsonpath/JSONPostProcessor.java
index 56bbe2e006..6e61f7393b 100644
--- a/src/components/src/main/java/org/apache/jmeter/extractor/json/jsonpath/JSONPostProcessor.java
+++ b/src/components/src/main/java/org/apache/jmeter/extractor/json/jsonpath/JSONPostProcessor.java
@@ -18,10 +18,12 @@
 package org.apache.jmeter.extractor.json.jsonpath;
 
 import java.io.Serializable;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.List;
+import java.util.stream.Collectors;
 
-import org.apache.commons.lang3.StringUtils;
 import org.apache.jmeter.processor.PostProcessor;
 import org.apache.jmeter.samplers.SampleResult;
 import org.apache.jmeter.testelement.AbstractScopedTestElement;
@@ -62,7 +64,7 @@ public class JSONPostProcessor
     public void process() {
         JMeterContext context = getThreadContext();
         JMeterVariables vars = context.getVariables();
-        String jsonResponse = extractJsonResponse(context, vars);
+        List<String> jsonResponses = extractJsonResponse(context, vars);
         String[] refNames = getRefNames().split(SEPARATOR);
         String[] jsonPathExpressions = getJsonPathExpressions().split(SEPARATOR);
         String[] defaultValues = getDefaultValues().split(SEPARATOR);
@@ -76,11 +78,13 @@ public class JSONPostProcessor
             String currentJsonPath = jsonPathExpressions[i].trim();
             clearOldRefVars(vars, currentRefName);
             try {
-                if (StringUtils.isEmpty(jsonResponse)) {
+                if (jsonResponses.isEmpty()) {
                     handleEmptyResponse(vars, defaultValues, i, currentRefName);
                 } else {
-                    List<Object> extractedValues = localMatcher.get()
-                            .extractWithJsonPath(jsonResponse, currentJsonPath);
+                    List<Object> extractedValues = new ArrayList<>();
+                    for (String jsonResponse: jsonResponses) {
+                        extractedValues.addAll(localMatcher.get().extractWithJsonPath(jsonResponse, currentJsonPath));
+                    }
                     // if no values extracted, default value added
                     if (extractedValues.isEmpty()) {
                         handleEmptyResult(vars, defaultValues, i, matchNumber, currentRefName);
@@ -198,23 +202,26 @@ public class JSONPostProcessor
         vars.put(currentRefName, defaultValues[i]);
     }
 
-    private String extractJsonResponse(JMeterContext context, JMeterVariables vars) {
+    private List<String> extractJsonResponse(JMeterContext context, JMeterVariables vars) {
         String jsonResponse = "";
         if (isScopeVariable()) {
-            jsonResponse = vars.get(getVariableName());
             if (log.isDebugEnabled()) {
                 log.debug("JSON Extractor is using variable: {}, which content is: {}", getVariableName(), jsonResponse);
             }
+            return Arrays.asList(vars.get(getVariableName()));
         } else {
             SampleResult previousResult = context.getPreviousResult();
             if (previousResult != null) {
-                jsonResponse = previousResult.getResponseDataAsString();
+                List<String> results = getSampleList(previousResult).stream()
+                        .map(SampleResult::getResponseDataAsString)
+                        .collect(Collectors.toList());
                 if (log.isDebugEnabled()) {
-                    log.debug("JSON Extractor {} working on Response: {}", getName(), jsonResponse);
+                    log.debug("JSON Extractor {} working on Responses: {}", getName(), results);
                 }
+                return results;
             }
         }
-        return jsonResponse;
+        return Collections.emptyList();
     }
 
     private void clearOldRefVars(JMeterVariables vars, String refName) {
-- 
2.25.1

