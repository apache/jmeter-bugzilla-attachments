Index: src/core/org/apache/jmeter/threads/JMeterContextService.java
===================================================================
--- src/core/org/apache/jmeter/threads/JMeterContextService.java	(revision 817377)
+++ src/core/org/apache/jmeter/threads/JMeterContextService.java	(working copy)
@@ -22,8 +22,8 @@
  * @version $Revision$
  */
 public final class JMeterContextService {
-	static private ThreadLocal threadContext = new ThreadLocal() {
-		public Object initialValue() {
+	static private ThreadLocal<JMeterContext> threadContext = new ThreadLocal<JMeterContext>() {
+		public JMeterContext initialValue() {
 			return new JMeterContext();
 		}
 	};
@@ -40,6 +40,9 @@
 	private JMeterContextService() {
 	}
 
+	static public ThreadLocal<JMeterContext> getThreadLocal() {
+		return threadContext;
+	}
 	static public JMeterContext getContext() {
 		return (JMeterContext) threadContext.get();
 	}
Index: src/core/org/apache/jmeter/threads/JMeterThread.java
===================================================================
--- src/core/org/apache/jmeter/threads/JMeterThread.java	(revision 817377)
+++ src/core/org/apache/jmeter/threads/JMeterThread.java	(working copy)
@@ -241,8 +241,8 @@
 	}
 
 	public void run() {
+		JMeterContextService.getThreadLocal().set(threadContext);
 		try {
-			initRun();
 			while (running) {
 				Sampler sam;
 				while (running && (sam = controller.next()) != null) {
@@ -324,10 +324,6 @@
                                 compiler.done(pack); // Finish up
                             }
                         }
-						if (scheduler) {
-							// checks the scheduler to stop the iteration
-							stopScheduler();
-						}
 					} catch (JMeterStopTestException e) {
 						log.info("Stopping Test: " + e.toString());
 						stopTest();
@@ -401,8 +397,8 @@
 	/**
 	 * 
 	 */
-	protected void initRun() {
-		threadContext = JMeterContextService.getContext();
+	public void initRun() {
+		threadContext = new JMeterContext();
 		threadContext.setVariables(threadVars);
 		threadContext.setThreadNum(getThreadNum());
 		threadContext.getVariables().put(LAST_SAMPLE_OK, "true");
@@ -410,11 +406,6 @@
         threadContext.setThreadGroup(threadGroup);
 		testTree.traverse(compiler);
 		// listeners = controller.getListeners();
-		if (scheduler) {
-			// set the scheduler to start
-			startScheduler();
-		}
-		rampUpDelay();
 		log.info("Thread " + Thread.currentThread().getName() + " started");
         JMeterContextService.incrNumberOfThreads();
         threadGroup.incrNumberOfThreads();
Index: src/core/org/apache/jmeter/threads/ThreadGroup.java
===================================================================
--- src/core/org/apache/jmeter/threads/ThreadGroup.java	(revision 817377)
+++ src/core/org/apache/jmeter/threads/ThreadGroup.java	(working copy)
@@ -124,25 +124,6 @@
 	}
 
 	/**
-	 * Set the Scheduler value.
-	 * 
-	 * @param Scheduler
-	 *            the Scheduler value.
-	 */
-	public void setScheduler(boolean Scheduler) {
-		setProperty(new BooleanProperty(SCHEDULER, Scheduler));
-	}
-
-	/**
-	 * Get the Scheduler value.
-	 * 
-	 * @return the Scheduler value.
-	 */
-	public boolean getScheduler() {
-		return getPropertyAsBoolean(SCHEDULER);
-	}
-
-	/**
 	 * Set the StartTime value.
 	 * 
 	 * @param stime -
Index: src/core/org/apache/jmeter/engine/StandardJMeterEngine.java
===================================================================
--- src/core/org/apache/jmeter/engine/StandardJMeterEngine.java	(revision 817377)
+++ src/core/org/apache/jmeter/engine/StandardJMeterEngine.java	(working copy)
@@ -22,12 +22,14 @@
 import java.io.Serializable;
 import java.io.StringWriter;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.jmeter.testbeans.TestBean;
 import org.apache.jmeter.testbeans.TestBeanHelper;
@@ -58,7 +60,7 @@
 
 	private static long WAIT_TO_DIE = 5 * 1000; // 5 seconds
 
-	private transient Map allThreads;
+	private transient Set<JMeterThread> mThreads;
 
 	private volatile boolean startingGroups; // flag to show that groups are still being created
 	
@@ -89,20 +91,19 @@
 	// e.g. from beanshell server
 	// Assumes that there is only one instance of the engine
 	// at any one time so it is not guaranteed to work ...
-	private static transient Map allThreadNames;
 
 	private static StandardJMeterEngine engine;
 
-	private static Map allThreadsSave;
+    private ScheduledExecutorService mThreadPool;
 
 	public static void stopEngineNow() {
 		if (engine != null) // May be null if called from Unit test
-			engine.stopTest(true);
+			engine.stopTest();
 	}
 
 	public static void stopEngine() {
 		if (engine != null) // May be null if called from Unit test
-			engine.stopTest(false);
+			engine.stopTest();
 	}
 
 	/*
@@ -115,43 +116,25 @@
 	}
 
 	public static boolean stopThread(String threadName) {
-		return stopThread(threadName, false);
+		stopEngine();
+		return true;
 	}
 
 	public static boolean stopThreadNow(String threadName) {
-		return stopThread(threadName, true);
+		stopEngine();
+		return true;
 	}
 
 	private static boolean stopThread(String threadName, boolean now) {
-		if (allThreadNames == null)
-			return false;// e.g. not yet started
-		JMeterThread thrd;
-		try {
-			thrd = (JMeterThread) allThreadNames.get(threadName);
-		} catch (Exception e) {
-			log.warn("stopThread: " + e);
-			return false;
-		}
-		if (thrd != null) {
-			thrd.stop();
-			if (now) {
-				Thread t = (Thread) allThreadsSave.get(thrd);
-				if (t != null) {
-					t.interrupt();
-				}
-			}
-			return true;
-		}
-		return false;
+		stopEngine();
+		return true;
 	}
 
 	// End of code to allow engine to be controlled remotely
 
 	public StandardJMeterEngine() {
-		allThreads = new HashMap();
+		mThreads = new HashSet<JMeterThread>();
 		engine = this;
-		allThreadNames = new HashMap();
-		allThreadsSave = allThreads;
 	}
 
 	public StandardJMeterEngine(String host) {
@@ -173,7 +156,10 @@
 
 	protected void compileTree() {
 		PreCompiler compiler = new PreCompiler();
-		getTestTree().traverse(compiler);
+		HashTree testTree = getTestTree();
+		synchronized(testTree) {
+			testTree.traverse(compiler);
+		}
 	}
 
 	// TODO: in Java1.5, perhaps we can use Thread.setUncaughtExceptionHandler() instead
@@ -259,58 +245,12 @@
 
 	public synchronized void threadFinished(JMeterThread thread) {
 		try {
-            allThreads.remove(thread);
             log.info("Ending thread " + thread.getThreadName());
-            if (!serialized && !schcdule_run && !startingGroups && allThreads.size() == 0 ) {
-            	log.info("Stopping test");
-            	stopTest();
-            }
         } catch (Throwable e) {
             log.fatalError("Call to threadFinished should never throw an exception - this can deadlock JMeter",e);
         }
 	}
 
-	public synchronized void stopTest() {
-		Thread stopThread = new Thread(new StopTest());
-		stopThread.start();
-	}
-
-	public synchronized void stopTest(boolean b) {
-		Thread stopThread = new Thread(new StopTest(b));
-		stopThread.start();
-	}
-
-	private class StopTest implements Runnable {
-		boolean now;
-
-		private StopTest() {
-			now = true;
-		}
-
-		private StopTest(boolean b) {
-			now = b;
-		}
-
-		public void run() {
-			if (running) {
-				running = false;
-				if (now) {
-					tellThreadsToStop();
-				} else {
-					stopAllThreads();
-				}
-				try {
-					Thread.sleep(10 * allThreads.size());
-				} catch (InterruptedException e) {
-				}
-				boolean stopped = verifyThreadsStopped();
-				if (stopped || now) {
-					notifyTestListenersOfEnd();
-				}
-			}
-		}
-	}
-
 	public void run() {
 		log.info("Running the test!");
 		running = true;
@@ -367,7 +307,11 @@
 		 * early in the test can impair results for short tests.
 		 */
 		System.gc();
-
+		
+		int threadPoolSize = JMeterUtils.getPropDefault("threadPoolSize", 1000);
+        log.debug("thread pool size is " + threadPoolSize);
+		mThreadPool = Executors.newScheduledThreadPool(threadPoolSize);
+		
 		notifier = new ListenerNotifier();
 
 		schcdule_run = true;
@@ -402,34 +346,26 @@
                 jmeterThread.setThreadNum(i);
 				jmeterThread.setThreadGroup(group);
 				jmeterThread.setInitialContext(JMeterContextService.getContext());
-				jmeterThread.setInitialDelay((int) (perThreadDelay * i));
+				//jmeterThread.setInitialDelay((int) (perThreadDelay * i));
+				jmeterThread.setStartTime((long)perThreadDelay * i);
 				jmeterThread.setThreadName(groupName + " " + (groupCount) + "-" + (i + 1));
 
-				scheduleThread(jmeterThread, group);
-
-				// Set up variables for stop handling
 				jmeterThread.setEngine(this);
 				jmeterThread.setOnErrorStopTest(onErrorStopTest);
 				jmeterThread.setOnErrorStopThread(onErrorStopThread);
+				
+				jmeterThread.initRun();
+				scheduleThread(jmeterThread, group);
 
-				Thread newThread = new Thread(jmeterThread);
-				newThread.setName(jmeterThread.getThreadName());
-				allThreads.put(jmeterThread, newThread);
+				// Set up variables for stop handling
+
+				mThreads.add(jmeterThread);
 				if (serialized && !iter.hasNext() && i == numThreads - 1) // last thread
 				{
 					serialized = false;
 				}
-				newThread.start();
 			}
 			schcdule_run = false;
-			if (serialized) {
-				while (running && allThreads.size() > 0) {
-					try {
-						Thread.sleep(1000);
-					} catch (InterruptedException e) {
-					}
-				}
-			}
 		}
         startingGroups = false;
 	}
@@ -442,7 +378,7 @@
 	 */
 	private void scheduleThread(JMeterThread thread, ThreadGroup group) {
 		// if true the Scheduler is enabled
-		if (group.getScheduler()) {
+		/*if (group.getScheduler()) {
 			long now = System.currentTimeMillis();
 			// set the start time for the Thread
 			if (group.getDelay() > 0) {// Duration is in seconds
@@ -459,59 +395,22 @@
 				thread.setEndTime(group.getDuration() * 1000 + (thread.getStartTime()));
 			} else {
 				thread.setEndTime(group.getEndTime());
-			}
+			}*/
 
 			// Enables the scheduler
-			thread.setScheduled(true);
-		}
+			log.debug("scheduling thread for " + thread.getStartTime() + " millis from now");
+			mThreadPool.schedule(thread, thread.getStartTime(), TimeUnit.MILLISECONDS);
+		//}
 	}
 
 	private boolean verifyThreadsStopped() {
-		boolean stoppedAll = true;
-		Iterator iter = new HashSet(allThreads.keySet()).iterator();
-		while (iter.hasNext()) {
-			Thread t = (Thread) allThreads.get(iter.next());
-			if (t != null && t.isAlive()) {
-				try {
-					t.join(WAIT_TO_DIE);
-				} catch (InterruptedException e) {
-				}
-				if (t.isAlive()) {
-					stoppedAll = false;
-					log.info("Thread won't die: " + t.getName());
-				}
-			}
-		}
-		return stoppedAll;
+		return mThreadPool.isShutdown();
 	}
 
-	private void tellThreadsToStop() {
-		Iterator iter = new HashSet(allThreads.keySet()).iterator();
-		while (iter.hasNext()) {
-			JMeterThread item = (JMeterThread) iter.next();
-			item.stop();
-			Thread t = (Thread) allThreads.get(item);
-			if (t != null) {
-				t.interrupt();
-			} else {
-				log.warn("Lost thread: " + item.getThreadName());
-				allThreads.remove(item);
-			}
-		}
+	public void stopTest() {
+		mThreadPool.shutdownNow();
 	}
 
-	public void askThreadsToStop() {
-		engine.stopTest(false);
-	}
-
-	private void stopAllThreads() {
-		Iterator iter = new HashSet(allThreads.keySet()).iterator();
-		while (iter.hasNext()) {
-			JMeterThread item = (JMeterThread) iter.next();
-			item.stop();
-		}
-	}
-
 	// Remote exit
 	public void exit() {
 		// Needs to be run in a separate thread to allow RMI call to return OK
@@ -529,4 +428,8 @@
 		log.info("Starting Closedown");
 		t.start();
 	}
+
+	public void askThreadsToStop() {
+		this.stopTest();
+	}
 }
