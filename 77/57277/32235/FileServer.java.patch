Index: FileServer.java
===================================================================
--- FileServer.java	(revision 1628107)
+++ FileServer.java	(working copy)
@@ -70,7 +70,7 @@
     /** Default base prefix: {@value} */
     private static final String BASE_PREFIX_DEFAULT = "~/"; // $NON-NLS-1$
 
-    private static final String BASE_PREFIX = 
+    private static final String BASE_PREFIX =
         JMeterUtils.getPropDefault("jmeter.save.saveservice.base_prefix", // $NON-NLS-1$
                 BASE_PREFIX_DEFAULT);
 
@@ -89,7 +89,7 @@
 
     // Cannot be instantiated
     private FileServer() {
-        base = new File(DEFAULT_BASE);
+    	setBase(new File(DEFAULT_BASE));
         log.info("Default base='"+DEFAULT_BASE+"'");
     }
 
@@ -104,9 +104,8 @@
      * Resets the current base to {@link #DEFAULT_BASE}.
      */
     public synchronized void resetBase() {
-        checkForOpenFiles();
-        base = new File(DEFAULT_BASE);
-        log.info("Reset base to'"+base+"'");
+    	setBase(new File(DEFAULT_BASE));
+    	log.info("Reset base to'"+base+"'");
     }
 
     /**
@@ -113,19 +112,17 @@
      * Sets the current base directory for relative file names from the provided path.
      * If the path does not refer to an existing directory, then its parent is used.
      * Normally the provided path is a file, so using the parent directory is appropriate.
-     * 
+     *
      * @param basedir the path to set, or {@code null} if the GUI is being cleared
      * @throws IllegalStateException if files are still open
      */
     public synchronized void setBasedir(String basedir) {
-        checkForOpenFiles(); // TODO should this be called if basedir == null?
         if (basedir != null) {
             File newBase = new File(basedir);
             if (!newBase.isDirectory()) {
                 newBase = newBase.getParentFile();
             }
-            base = newBase;
-            log.info("Set new base='"+base+"'");
+            setBase(newBase);
         }
     }
 
@@ -133,7 +130,7 @@
      * Sets the current base directory for relative file names from the provided script file.
      * The parameter is assumed to be the path to a JMX file, so the base directory is derived
      * from its parent.
-     * 
+     *
      * @param scriptPath the path of the script file; must be not be {@code null}
      * @throws IllegalStateException if files are still open
      * @throws IllegalArgumentException if scriptPath parameter is null
@@ -149,7 +146,7 @@
 
     /**
      * Sets the current base directory for relative file names.
-     * 
+     *
      * @param jmxBase the path of the script file base directory, cannot be null
      * @throws IllegalStateException if files are still open
      * @throws IllegalArgumentException if {@code basepath} is null
@@ -160,6 +157,7 @@
         }
         checkForOpenFiles();
         base = jmxBase;
+        System.setProperty("base.dir", base.getAbsolutePath());  // $NON-NLS-1$
         log.info("Set new base='"+base+"'");
     }
 
@@ -168,7 +166,7 @@
      * <p>
      * Caller must ensure that access to the files map is single-threaded as
      * there is a window between checking the files Map and clearing it.
-     * 
+     *
      * @throws IllegalStateException if there are any entries still in use
      */
     private void checkForOpenFiles() throws IllegalStateException {
@@ -189,7 +187,7 @@
     /**
      * Calculates the relative path from {@link #DEFAULT_BASE} to the current base,
      * which must be the same as or a child of the default.
-     * 
+     *
      * @return the relative path, or {@code "."} if the path cannot be determined
      */
     public synchronized File getBaseDirRelative() {
@@ -197,7 +195,7 @@
         File parent = new File(DEFAULT_BASE).getAbsoluteFile();
         File f = base.getAbsoluteFile();
         ArrayStack l = new ArrayStack();
-        while (f != null) { 
+        while (f != null) {
             if (f.equals(parent)){
                 if (l.isEmpty()){
                     break;
@@ -209,7 +207,7 @@
                 return rel;
             }
             l.push(f.getName());
-            f = f.getParentFile(); 
+            f = f.getParentFile();
         }
         return new File(".");
     }
@@ -317,7 +315,7 @@
      * @return String containing the next line in the file (null if EOF reached and not recycle)
      * @throws IOException
      */
-    public synchronized String readLine(String filename, boolean recycle, 
+    public synchronized String readLine(String filename, boolean recycle,
             boolean firstLineIsNames) throws IOException {
         FileEntry fileEntry = files.get(filename);
         if (fileEntry != null) {
@@ -345,7 +343,7 @@
     }
 
     /**
-     * 
+     *
      * @param alias the file name or alias
      * @param recycle whether the file should be re-started on EOF
      * @param firstLineIsNames whether the file contains a file header
@@ -367,7 +365,7 @@
                 if (firstLineIsNames) {
                     // read first line and forget
                     reader.readLine();
-                }                
+                }
             } else if (!(fileEntry.inputOutputObject instanceof Reader)) {
                 throw new IOException("File " + alias + " already in use");
             } else {
@@ -382,7 +380,7 @@
                         if (firstLineIsNames) {
                             // read first line and forget
                             reader.readLine();
-                        }                
+                        }
                     } else { // OK, we still have some data, restore it
                         reader.reset();
                     }
@@ -493,7 +491,7 @@
     private static class FileEntry{
         private String headerLine;
         private final File file;
-        private Closeable inputOutputObject; 
+        private Closeable inputOutputObject;
         private final String charSetEncoding;
         FileEntry(File f, Closeable o, String e){
             file=f;
@@ -501,13 +499,13 @@
             charSetEncoding=e;
         }
     }
-    
+
     /**
      * Resolve a file name that may be relative to the base directory.
      * If the name begins with the value of the JMeter property
-     * "jmeter.save.saveservice.base_prefix" 
+     * "jmeter.save.saveservice.base_prefix"
      * - default "~/" - then the name is assumed to be relative to the basename.
-     * 
+     *
      * @param relativeName
      * @return the updated file
      */
