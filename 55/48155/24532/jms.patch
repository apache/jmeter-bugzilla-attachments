Index: src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/PublisherSampler.java
===================================================================
--- src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/PublisherSampler.java	(revision 836111)
+++ src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/PublisherSampler.java	(working copy)
@@ -55,8 +55,11 @@
 
     // Does not need to be synch. because it is only accessed from the sampler thread
     // The ClientPool does access it in a different thread, but ClientPool is fully synch.
-    private transient Publisher PUB = null; // TODO URGENT probably needs to be synch.
+    private transient Publisher PUB = null;
 
+    // Does not need to be synch. because only used by the sample method as a temporary buffer
+    private final StringBuffer BUFFER = new StringBuffer();
+
     private static final FileServer FSERVER = FileServer.getFileServer();
 
     // Cache for file. Only used by sample() in a single thread
@@ -113,7 +116,6 @@
     /**
      * The implementation calls sample() without any parameters
      */
-    @Override
     public SampleResult sample(Entry e) {
         return this.sample();
     }
@@ -124,30 +126,31 @@
      *
      * @return the populated sample result
      */
-    @Override
     public SampleResult sample() {
         SampleResult result = new SampleResult();
+        result.setDataType(SampleResult.TEXT);
         result.setSampleLabel(getName());
         if (this.PUB == null) {
             this.initClient();
         }
-        StringBuilder buffer = new StringBuilder();
         int loop = this.getIterationCount();
         if (this.PUB != null) {
             result.sampleStart();
             for (int idx = 0; idx < loop; idx++) {
                 String tmsg = this.getMessageContent();
                 this.PUB.publish(tmsg);
-                buffer.append(tmsg);
+                this.BUFFER.append(tmsg);
             }
             result.sampleEnd();
-            String content = buffer.toString();
+            String content = this.BUFFER.toString();
             result.setBytes(content.getBytes().length);
             result.setResponseCode("message published successfully");
             result.setResponseMessage(loop + " messages published");
             result.setSuccessful(true);
-            result.setResponseData(content.getBytes());
+            result.setResponseData("Not Applicable".getBytes());
+            result.setSamplerData(content);
             result.setSampleCount(loop);
+            this.BUFFER.setLength(0);
         }
         return result;
     }
Index: src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/SubscriberSampler.java
===================================================================
--- src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/SubscriberSampler.java	(revision 836111)
+++ src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/SubscriberSampler.java	(working copy)
@@ -22,39 +22,36 @@
 import javax.jms.MessageListener;
 import javax.jms.TextMessage;
 
-import org.apache.jmeter.samplers.Interruptible;
-import org.apache.jmeter.samplers.SampleResult;
-import org.apache.jmeter.testelement.TestListener;
-import org.apache.jmeter.util.JMeterUtils;
 import org.apache.jmeter.engine.event.LoopIterationEvent;
-
-import org.apache.jmeter.protocol.jms.control.gui.JMSSubscriberGui;
 import org.apache.jmeter.protocol.jms.client.ClientPool;
 import org.apache.jmeter.protocol.jms.client.OnMessageSubscriber;
 import org.apache.jmeter.protocol.jms.client.ReceiveSubscriber;
-
+import org.apache.jmeter.protocol.jms.control.gui.JMSSubscriberGui;
+import org.apache.jmeter.samplers.SampleResult;
+import org.apache.jmeter.testelement.TestListener;
+import org.apache.jmeter.util.JMeterUtils;
 import org.apache.jorphan.logging.LoggingManager;
 import org.apache.log.Logger;
 
 /**
  * This class implements the JMS Subcriber sampler
  */
-public class SubscriberSampler extends BaseJMSSampler implements Interruptible, TestListener, MessageListener {
+public class SubscriberSampler extends BaseJMSSampler implements TestListener,
+    MessageListener {
 
     private static final long serialVersionUID = 233L;
 
     private static final Logger log = LoggingManager.getLoggerForClass();
 
-    // No need to synch/ - only used by sampler and ClientPool (which does its own synch)
+    // No need to synch/ - only used by sampler and ClientPool (which does its
+    // own synch)
     private transient ReceiveSubscriber SUBSCRIBER = null;
 
-    //@GuardedBy("this")
+    // @GuardedBy("this")
     private final StringBuffer BUFFER = new StringBuffer();
 
-    //@GuardedBy("this")
+    // @GuardedBy("this")
     private transient int counter = 0;
-    
-    private transient volatile boolean interrupted = false;
 
     // Don't change the string, as it is used in JMX files
     private static final String CLIENT_CHOICE = "jms.client_choice"; // $NON-NLS-1$
@@ -71,8 +68,7 @@
     }
 
     /**
-     * testEnded is called by Jmeter's engine.
-     * Clears the client pool.
+     * testEnded is called by Jmeter's engine. Clears the client pool.
      */
     public void testEnded() {
         log.debug("SubscriberSampler.testEnded called");
@@ -81,7 +77,7 @@
 
     /*
      * (non-Javadoc)
-     *
+     * 
      * @see junit.framework.TestListener#startTest(junit.framework.Test)
      */
     public void testStarted() {
@@ -93,15 +89,15 @@
     /**
      * Create the OnMessageSubscriber client and set the sampler as the message
      * listener.
-     *
+     * 
      */
     private OnMessageSubscriber initListenerClient() {
-    	interrupted = false;
         OnMessageSubscriber sub = (OnMessageSubscriber) ClientPool.get(this);
         if (sub == null) {
-            sub = new OnMessageSubscriber(this.getUseJNDIPropertiesAsBoolean(), this.getJNDIInitialContextFactory(),
-                    this.getProviderUrl(), this.getConnectionFactory(), this.getTopic(), this.isUseAuth(), this
-                            .getUsername(), this.getPassword());
+            sub = new OnMessageSubscriber(this.getUseJNDIPropertiesAsBoolean(),
+                this.getJNDIInitialContextFactory(), this.getProviderUrl(),
+                this.getConnectionFactory(), this.getTopic(), this.isUseAuth(),
+                this.getUsername(), this.getPassword());
             sub.setMessageListener(this);
             sub.resume();
             ClientPool.addClient(sub);
@@ -116,10 +112,11 @@
      * Create the ReceiveSubscriber client for the sampler.
      */
     private void initReceiveClient() {
-    	interrupted = false;
-        this.SUBSCRIBER = new ReceiveSubscriber(this.getUseJNDIPropertiesAsBoolean(), this
-                .getJNDIInitialContextFactory(), this.getProviderUrl(), this.getConnectionFactory(), this.getTopic(),
-                this.isUseAuth(), this.getUsername(), this.getPassword());
+        this.SUBSCRIBER = new ReceiveSubscriber(this
+            .getUseJNDIPropertiesAsBoolean(), this
+            .getJNDIInitialContextFactory(), this.getProviderUrl(), this
+            .getConnectionFactory(), this.getTopic(), this.isUseAuth(), this
+            .getUsername(), this.getPassword());
         this.SUBSCRIBER.resume();
         ClientPool.addClient(this.SUBSCRIBER);
         log.debug("SubscriberSampler.initReceiveClient called");
@@ -128,10 +125,9 @@
     /**
      * sample method will check which client it should use and call the
      * appropriate client specific sample method.
-     *
+     * 
      * @return the appropriate sample result
      */
-    @Override
     public SampleResult sample() {
         if (this.getClientChoice().equals(JMSSubscriberGui.RECEIVE_RSC)) {
             return sampleWithReceive();
@@ -142,19 +138,19 @@
 
     /**
      * sample will block until messages are received
-     *
+     * 
      * @return the sample result
      */
     private SampleResult sampleWithListener() {
         SampleResult result = new SampleResult();
+        result.setDataType(SampleResult.TEXT);
         result.setSampleLabel(getName());
         initListenerClient();
 
         int loop = this.getIterationCount();
 
         result.sampleStart();
-        int read;
-        while ((read=this.count(0)) < loop && interrupted == false) {
+        while (this.count(0) < loop) {
             try {
                 Thread.sleep(0, 50);
             } catch (InterruptedException e) {
@@ -162,19 +158,19 @@
             }
         }
         result.sampleEnd();
-        synchronized (this) {// Need to synch because buffer is shared with onMessageHandler
+        result.setResponseMessage(loop + " samples messages recieved");
+        synchronized (this) {// Need to synch because buffer is shared with
+                             // onMessageHandler
             if (this.getReadResponseAsBoolean()) {
                 result.setResponseData(this.BUFFER.toString().getBytes());
             } else {
                 result.setBytes(this.BUFFER.toString().getBytes().length);
             }
-            read=this.count(0);
         }
         result.setSuccessful(true);
-        result.setResponseCodeOK();
-        result.setResponseMessage(read + " messages received");
-        result.setSamplerData(loop + " messages expected");
-        result.setSampleCount(read);
+        result.setResponseCode(loop + " message(s) recieved successfully");
+        result.setSamplerData("Not applicable");
+        result.setSampleCount(loop);
 
         this.resetCount();
         return result;
@@ -183,11 +179,12 @@
     /**
      * Sample method uses the ReceiveSubscriber client instead of onMessage
      * approach.
-     *
+     * 
      * @return the sample result
      */
     private SampleResult sampleWithReceive() {
         SampleResult result = new SampleResult();
+        result.setDataType(SampleResult.TEXT);
         result.setSampleLabel(getName());
         if (this.SUBSCRIBER == null) {
             this.initReceiveClient();
@@ -197,7 +194,7 @@
         this.SUBSCRIBER.setLoop(loop);
 
         result.sampleStart();
-        while (this.SUBSCRIBER.count(0) < loop && interrupted == false) {
+        while (this.SUBSCRIBER.count(0) < loop) {
             try {
                 Thread.sleep(0, 50);
             } catch (InterruptedException e) {
@@ -205,14 +202,14 @@
             }
         }
         result.sampleEnd();
-        result.setResponseMessage(loop + " samples messages received");
+        result.setResponseMessage(loop + " samples messages recieved");
         if (this.getReadResponseAsBoolean()) {
             result.setResponseData(this.SUBSCRIBER.getMessage().getBytes());
         } else {
             result.setBytes(this.SUBSCRIBER.getMessage().getBytes().length);
         }
         result.setSuccessful(true);
-        result.setResponseCode(loop + " message(s) received successfully");
+        result.setResponseCode(loop + " message(s) recieved successfully");
         result.setSamplerData("Not applicable");
         result.setSampleCount(loop);
 
@@ -230,6 +227,10 @@
                 TextMessage msg = (TextMessage) message;
                 String content = msg.getText();
                 if (content != null) {
+                    log.info("TextMessage received, " + content.length()
+                        + " bytes.");
+                    this.BUFFER.append(getMessageHeaders(message));
+                    this.BUFFER.append("JMS Message Text:\n\n");
                     this.BUFFER.append(content);
                     count(1);
                 }
@@ -241,7 +242,7 @@
 
     /**
      * increment the count and return the new value.
-     *
+     * 
      * @param increment
      * @return the new value
      */
@@ -270,29 +271,22 @@
 
     /**
      * Return the client choice.
-     *
+     * 
      * @return the client choice, either RECEIVE_RSC or ON_MESSAGE_RSC
      */
     public String getClientChoice() {
         String choice = getPropertyAsString(CLIENT_CHOICE);
-        // Convert the old test plan entry (which is the language dependent string) to the resource name
-        if (choice.equals(RECEIVE_STR)){
+        // Convert the old test plan entry (which is the language dependent
+        // string) to the resource name
+        if (choice.equals(RECEIVE_STR)) {
             choice = JMSSubscriberGui.RECEIVE_RSC;
-        } else if (!choice.equals(JMSSubscriberGui.RECEIVE_RSC)){
+        } else if (!choice.equals(JMSSubscriberGui.RECEIVE_RSC)) {
             choice = JMSSubscriberGui.ON_MESSAGE_RSC;
         }
         return choice;
     }
-    
-    /**
-     * Handle an interrupt of the test.
-     */
-    public boolean interrupt() {
-        boolean oldvalue = interrupted;
-    	interrupted = true;   // so we break the loops in SampleWithListener and SampleWithReceive
-    	return !oldvalue;
-    }
 
     // This was the old value that was checked for
-    private final static String RECEIVE_STR = JMeterUtils.getResString(JMSSubscriberGui.RECEIVE_RSC); // $NON-NLS-1$
+    private final static String RECEIVE_STR = JMeterUtils
+        .getResString(JMSSubscriberGui.RECEIVE_RSC); // $NON-NLS-1$
 }
Index: src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/BaseJMSSampler.java
===================================================================
--- src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/BaseJMSSampler.java	(revision 836111)
+++ src/protocol/jms/org/apache/jmeter/protocol/jms/sampler/BaseJMSSampler.java	(working copy)
@@ -17,6 +17,13 @@
 
 package org.apache.jmeter.protocol.jms.sampler;
 
+import java.util.Date;
+
+import javax.jms.DeliveryMode;
+import javax.jms.Destination;
+import javax.jms.JMSException;
+import javax.jms.Message;
+
 import org.apache.jmeter.testelement.TestListener;
 import org.apache.jmeter.samplers.AbstractSampler;
 import org.apache.jmeter.samplers.Entry;
@@ -280,4 +287,62 @@
     public boolean getUseJNDIPropertiesAsBoolean() {
         return getPropertyAsBoolean(USE_PROPERTIES_FILE);
     }
+    
+    
+    /**
+     * Returns a String with the JMS Message Header values.
+     * 
+     * @param message JMS Message
+     * @return String with message header values.
+     */
+    public static String getMessageHeaders(Message message) {
+        final StringBuffer response = new StringBuffer(256);
+        try {
+            response.append("JMS Message Header Attributes:");
+            response.append("\n   Correlation ID: ");
+            response.append(message.getJMSCorrelationID());
+
+            response.append("\n   Delivery Mode: ");
+            if (message.getJMSDeliveryMode() == DeliveryMode.PERSISTENT) {
+                response.append("PERSISTANT");
+            } else {
+                response.append("NON-PERSISTANT");
+            }
+
+            final Destination destination = message.getJMSDestination();
+
+            response.append("\n   Destination: ");
+            response.append((destination == null ? null : destination
+                .toString()));
+
+            response.append("\n   Expiration: ");
+            response.append(new Date(message.getJMSExpiration()));
+
+            response.append("\n   Message ID: ");
+            response.append(message.getJMSMessageID());
+
+            response.append("\n   Priority: ");
+            response.append(message.getJMSPriority());
+
+            response.append("\n   Redelivered: ");
+            response.append(message.getJMSRedelivered());
+
+            final Destination replyTo = message.getJMSReplyTo();
+            response.append("\n   Reply to: ");
+            response.append((replyTo == null ? null : replyTo.toString()));
+
+            response.append("\n   Timestamp: ");
+            response.append(new Date(message.getJMSTimestamp()));
+
+            response.append("\n   Type: ");
+            response.append(message.getJMSType());
+
+            response.append("\n\n");
+
+        } catch (JMSException e) {
+            e.printStackTrace();
+        }
+
+        return new String(response);
+    }
 }
Index: src/protocol/jms/org/apache/jmeter/protocol/jms/client/ReceiveSubscriber.java
===================================================================
--- src/protocol/jms/org/apache/jmeter/protocol/jms/client/ReceiveSubscriber.java	(revision 836111)
+++ src/protocol/jms/org/apache/jmeter/protocol/jms/client/ReceiveSubscriber.java	(working copy)
@@ -29,6 +29,7 @@
 import javax.naming.InitialContext;
 import javax.naming.NamingException;
 
+import org.apache.jmeter.protocol.jms.sampler.BaseJMSSampler;
 import org.apache.jorphan.logging.LoggingManager;
 import org.apache.log.Logger;
 
@@ -49,19 +50,21 @@
 
     private static final Logger log = LoggingManager.getLoggerForClass();
 
-    private final TopicConnection CONN;
+    private TopicConnection CONN = null;
 
-    private final TopicSession SESSION;
+    private TopicSession SESSION = null;
 
-    private final TopicSubscriber SUBSCRIBER;
+    private Topic TOPIC = null;
 
+    private TopicSubscriber SUBSCRIBER = null;
+
     //@GuardedBy("this")
     private int counter;
 
     private int loop = 1; // TODO never read
 
     //@GuardedBy("this")
-    private final StringBuffer buffer = new StringBuffer();
+    private StringBuffer buffer = new StringBuffer();
 
     //@GuardedBy("this")
     private volatile boolean RUN = true;
@@ -73,17 +76,25 @@
     public ReceiveSubscriber(boolean useProps, String jndi, String url, String connfactory, String topic,
             boolean useAuth, String user, String pwd) {
         Context ctx = initJNDI(useProps, jndi, url, useAuth, user, pwd);
-        TopicConnection _conn = null;
-        Topic _topic = null;
-        TopicSession _session = null;
-        TopicSubscriber _subscriber = null;
         if (ctx != null) {
             try {
                 ConnectionFactory.getTopicConnectionFactory(ctx,connfactory);
-                _conn = ConnectionFactory.getTopicConnection();
-                _topic = InitialContextFactory.lookupTopic(ctx, topic);
-                _session = _conn.createTopicSession(false, TopicSession.AUTO_ACKNOWLEDGE);
-                _subscriber = _session.createSubscriber(_topic);
+                CONN = ConnectionFactory.getTopicConnection();
+                if(CONN == null) {
+                    log.error("CONN is NULL!!");
+                }
+                TOPIC = InitialContextFactory.lookupTopic(ctx, topic);
+                if(TOPIC == null) {
+                    log.error("TOPIC is NULL!!");
+                }
+                SESSION = this.CONN.createTopicSession(false, TopicSession.AUTO_ACKNOWLEDGE);
+                if(SESSION == null) {
+                    log.error("SESSION is NULL!!");
+                }
+                SUBSCRIBER = this.SESSION.createSubscriber(this.TOPIC);
+                if(SUBSCRIBER == null) {
+                    log.error("SUBSCRIBER is NULL!!");
+                }
                 log.info("created the topic connection successfully");
             } catch (JMSException e) {
                 log.error("Connection error: " + e.getMessage());
@@ -91,9 +102,6 @@
         } else {
             log.error("Could not initialize JNDI Initial Context Factory");
         }
-        this.CONN = _conn;
-        this.SESSION = _session;
-        this.SUBSCRIBER = _subscriber;
     }
 
     /**
@@ -233,8 +241,12 @@
                 if (message != null && message instanceof TextMessage) {
                     TextMessage msg = (TextMessage) message;
                     String text = msg.getText();
+                    log.info("TextMessage received, " + text.length() + " bytes.");
                     if (text.trim().length() > 0) {
                         synchronized (this) {
+                            this.buffer.append(BaseJMSSampler
+                                .getMessageHeaders(message));
+                            this.buffer.append("JMS Message Text:\n\n");
                             this.buffer.append(text);
                             count(1);
                         }
