Index: src/components/org/apache/jmeter/visualizers/backend/apdex/ApdexBackendListenerClient.java
===================================================================
--- src/components/org/apache/jmeter/visualizers/backend/apdex/ApdexBackendListenerClient.java	(revision 0)
+++ src/components/org/apache/jmeter/visualizers/backend/apdex/ApdexBackendListenerClient.java	(revision 0)
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+package org.apache.jmeter.visualizers.backend.apdex;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicLong;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.jmeter.config.Arguments;
+import org.apache.jmeter.samplers.SampleResult;
+import org.apache.jmeter.visualizers.backend.AbstractBackendListenerClient;
+import org.apache.jmeter.visualizers.backend.BackendListenerContext;
+import org.apache.jorphan.logging.LoggingManager;
+import org.apache.log.Logger;
+
+/**
+ * APDEX Computer
+ * @since 2.13
+ */
+public class ApdexBackendListenerClient extends AbstractBackendListenerClient {
+    private static final Logger LOGGER = LoggingManager.getLoggerForClass();
+    private static final String SEPARATOR = ";"; //$NON-NLS-1$
+
+    private long satisfiedResponseTimeMS;
+    private long toleratedResponseTimeMS;
+    private String samplersList = ""; //$NON-NLS-1$
+    private Set<String> samplersToFilter;
+       
+    private AtomicLong numberOfSatistiedResponses = new AtomicLong(0);
+    private AtomicLong numberOfToleratedResponses = new AtomicLong(0);
+    private AtomicLong totalResponses = new AtomicLong(0);
+    public ApdexBackendListenerClient() {
+        super();
+    } 
+
+
+    /**
+     * @return the samplersList
+     */
+    public String getSamplersList() {
+        return samplersList;
+    }
+
+    /**
+     * @param samplersList the samplersList to set
+     */
+    public void setSamplersList(String samplersList) {
+        this.samplersList = samplersList;
+    }
+
+    @Override
+    public void handleSampleResults(List<SampleResult> sampleResults,
+            BackendListenerContext context) {
+        int satisfied = 0;
+        int tolerated = 0;
+        int total = 0;
+        for (SampleResult sampleResult : sampleResults) {
+            if(samplersToFilter.contains(sampleResult.getSampleLabel())) {
+                total++;
+                if(sampleResult.getTime()<=satisfiedResponseTimeMS) {
+                    satisfied++;
+                } else if (sampleResult.getTime()<=toleratedResponseTimeMS) {
+                    tolerated++;
+                }
+            }
+        }
+        numberOfSatistiedResponses.addAndGet(satisfied);
+        numberOfToleratedResponses.addAndGet(tolerated);
+        totalResponses.addAndGet(total);
+    }
+
+    @Override
+    public void setupTest(BackendListenerContext context) throws Exception {
+        String satisfiedResponseTimeAsString = context.getParameter("satisfiedResponseTimeMS", "");
+        if(!StringUtils.isEmpty(satisfiedResponseTimeAsString)) {
+            try {
+                satisfiedResponseTimeMS = Long.parseLong(satisfiedResponseTimeAsString);
+            } catch (Exception e) {
+                throw new IllegalArgumentException("Error parsing satisfiedResponseTimeMS '"
+                        +satisfiedResponseTimeAsString+"', message:"+e.getMessage());
+            }
+        } else {
+            throw new IllegalArgumentException("satisfiedResponseTimeMS is null or empty");
+        }
+
+        String toleratedResponseTimeAsString = context.getParameter("toleratedResponseTimeMS", "");
+        if(!StringUtils.isEmpty(toleratedResponseTimeAsString)) {
+            try {
+                toleratedResponseTimeMS = Long.parseLong(toleratedResponseTimeAsString);
+            } catch (Exception e) {
+                throw new IllegalArgumentException("Error parsing toleratedResponseTimeMS '"
+                        +satisfiedResponseTimeAsString+"', message:"+e.getMessage());
+            }
+        } else {
+            toleratedResponseTimeMS = 4*satisfiedResponseTimeMS;
+        }
+        
+        samplersList = context.getParameter("samplersList", "");
+        String[] samplers = samplersList.split(SEPARATOR);
+        samplersToFilter = new HashSet<String>();
+        for (String samplerName : samplers) {
+            samplersToFilter.add(samplerName.trim());
+        }
+        
+        numberOfSatistiedResponses.set(0);
+        numberOfToleratedResponses.set(0);
+        totalResponses.set(0);
+    }
+
+    @Override
+    public void teardownTest(BackendListenerContext context) throws Exception {
+        if(samplersToFilter.size()>0) {
+            LOGGER.warn("APDEX:"+computeAPDEX() + " for thresholds T:"+satisfiedResponseTimeMS+"ms, F:"+toleratedResponseTimeMS
+                    + "ms on samplers:"+samplersToFilter);
+        }
+        samplersToFilter.clear();
+        super.teardownTest(context);
+    }
+
+    /**
+     * @return float APDEX
+     */
+    private float computeAPDEX() {
+        double apdex = ((double)(numberOfSatistiedResponses.get()+numberOfToleratedResponses.get()/2))/totalResponses.get();
+        return (float)apdex;
+    }
+
+    @Override
+    public Arguments getDefaultParameters() {
+        Arguments arguments = new Arguments();
+        arguments.addArgument("satisfiedResponseTimeMS", "");
+        arguments.addArgument("toleratedResponseTimeMS", "");
+        arguments.addArgument("samplersList", "");
+        return arguments;
+    }
+}
