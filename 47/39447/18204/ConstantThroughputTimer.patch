Index: C:/JavaClasses/workspace/jMeter/src/components/org/apache/jmeter/timers/ConstantThroughputTimer.java
===================================================================
--- C:/JavaClasses/workspace/jMeter/src/components/org/apache/jmeter/timers/ConstantThroughputTimer.java    (revision 395922)
+++ C:/JavaClasses/workspace/jMeter/src/components/org/apache/jmeter/timers/ConstantThroughputTimer.java    (working copy)
@@ -17,12 +17,16 @@
 
 package org.apache.jmeter.timers;
 
+import java.util.Hashtable;
+import java.util.Map;
+
 import org.apache.jmeter.engine.event.LoopIterationEvent;
 import org.apache.jmeter.testbeans.TestBean;
 import org.apache.jmeter.testelement.AbstractTestElement;
 import org.apache.jmeter.testelement.TestListener;
+import org.apache.jmeter.threads.JMeterContext;
 import org.apache.jmeter.threads.JMeterContextService;
-import org.apache.jmeter.util.JMeterUtils;
+import org.apache.jmeter.threads.JMeterThread;
 import org.apache.jorphan.logging.LoggingManager;
 import org.apache.log.Logger;
 
@@ -34,161 +38,182 @@
  */
 public class ConstantThroughputTimer extends AbstractTestElement implements Timer, TestListener, TestBean {
    private static final long serialVersionUID = 2;
-
    private static final Logger log = LoggingManager.getLoggerForClass();
-
    private static final double MILLISEC_PER_MIN = 60000.0;
+    
+    private String calcMode;
+    private int modeInt;
+    private double requestsPerMinute;
+    private long millisecondsPerRequest;
+    
+    //For calculating throughput across all threads
+    private final static ThrougputInfo allThreadsInfo = new ThrougputInfo();
+    
+    //For holding the ThrougputInfo objects for all ThreadGroups. Keyed by ThreadGroup objects
+    private final static Map threadGroupsInfoMap = new Hashtable();
+    
+    //For calculating throughput on a single thread
+    private final ThrougputInfo thisThreadInfo = new ThrougputInfo();
+    
+    
+    
+    public String getCalcMode() {
+        return calcMode;
+    }
 
-   /**
-    * Target time for the start of the next request. The delay provided by the
-    * timer will be calculated so that the next request happens at this time.
-    */
-   private long previousTime = 0;
+    public void setCalcMode(String mode) {
+        // TODO find better way to get modeInt
+        this.modeInt = ConstantThroughputTimerBeanInfo.getCalcModeAsInt(mode);
+        this.calcMode = mode;
+    }
+    
+    
+    public void setThroughput(double requestsPerMinute) {
+        if (log.isDebugEnabled()) {
+            log.debug(this.threadName() + " - setThroughput(" + requestsPerMinute + ")");
+        }
+        
+        this.requestsPerMinute = requestsPerMinute;
+        this.millisecondsPerRequest = (long)(MILLISEC_PER_MIN / this.requestsPerMinute);
+        
+        if (log.isDebugEnabled()) {
+            log.debug(this.threadName() + " - Calculated millisecondsPerRequest=" + this.millisecondsPerRequest);
+        }
+    }
 
-   private String calcMode; // String representing the mode
-                               // (Locale-specific)
+    public double getThroughput() {
+        return this.requestsPerMinute;
+    }
+    
+    
+    /**
+     * @see org.apache.jmeter.timers.Timer#delay()
+     */
+    public long delay() {
+        final ThrougputInfo currentInfo = getTargetThroughputInfo();
+        final long calculatedDelay = this.calculateDelay(currentInfo);
+        return Math.max(calculatedDelay, 0);
+    }
+    
+    /**
+     * @see org.apache.jmeter.testelement.AbstractTestElement#threadName()
+     */
+    private String threadName() {
+        return Thread.currentThread().getName();
+    }
 
-   private int modeInt; // mode as an integer
+    /**
+     * Using the specified mode return the appropriate ThrougputInfo object.
+     * 
+     * @return The ThrougputInfo for the current mode.
+     */
+    private ThrougputInfo getTargetThroughputInfo() {
+        final ThrougputInfo currentInfo;
+        
+        if (log.isDebugEnabled()) {
+            log.debug(this.threadName() + " - Getting ThroughputInfo for modeInt=" + this.modeInt);
+        }
+        
+        // Use switch statement for performance (large order performance difference over if/else if/else
+        switch (this.modeInt) {
+            case 2: //All threads in this group
+                final JMeterContext context = JMeterContextService.getContext();
+                final JMeterThread thread = context.getThread();
+                final org.apache.jmeter.threads.ThreadGroup group = thread.getThreadGroup();
+                
+                if (log.isDebugEnabled()) {
+                    log.debug(this.threadName() + " - Getting ThroughputInfo for ThreadGroup=" + group.getName());
+                }
+                
+                synchronized (threadGroupsInfoMap) {
+                    ThrougputInfo info = (ThrougputInfo)threadGroupsInfoMap.get(group);
+                    if (info == null) {
+                        info = new ThrougputInfo();
+                        threadGroupsInfoMap.put(group, info);
+                    }
+                    currentInfo = info;
+                }
+                
+                break;
+                
+            case 1: //All threads
+                currentInfo = allThreadsInfo;
+                break;
 
-   /**
-    * Desired throughput, in samples per minute.
-    */
-   private double throughput;
+            case 0: //This thread only
+            default:
+                currentInfo = thisThreadInfo;
+                break;
+        }
 
-   /**
-    * Constructor for a non-configured ConstantThroughputTimer.
-    */
-   public ConstantThroughputTimer() {
-   }
+        return currentInfo;
+    }
+    
+    /**
+     * Calculates the the delay needed to achieve the througput using the
+     * passed ThrougputInfo object.
+     * 
+     * @param info The ThrougputInfo object that contains the last scheduled request time and a mutext for synchronization.
+     * @return The delay before the next request is executed to achieve the desired throughput.
+     */
+    private long calculateDelay(ThrougputInfo info) {
+        final long now = System.currentTimeMillis();
+        final long calculatedDelay;
+        
+        if (log.isDebugEnabled()) {
+            log.debug(this.threadName() + " - now=" + now + ", lastScheduledTime=" + info.lastScheduledTime);
+        }
+        
+        synchronized (info.MUTEX) {
+            final long nextRequstTime = info.lastScheduledTime + this.millisecondsPerRequest;
+            info.lastScheduledTime = Math.max(now, nextRequstTime);
+            calculatedDelay = info.lastScheduledTime - now;
+        }
+        
+        if (log.isDebugEnabled()) {
+            log.debug(this.threadName() + " - nextScheduledTime=" + info.lastScheduledTime + ", calculatedDelay=" + calculatedDelay);
+        }
+        
+        return Math.max(calculatedDelay, 0);
+    }
 
-   /**
-    * Sets the desired throughput.
-    * 
-    * @param throughput
-    *            Desired sampling rate, in samples per minute.
-    */
-   public void setThroughput(double throughput) {
-       this.throughput = throughput;
-   }
+    /**
+     * Resets all of the ThrougputInfo objects.
+     */
+    private synchronized void reset() {
+        log.debug("Clearing last scheduled times for all scopes.");
+        this.thisThreadInfo.lastScheduledTime = 0;
+        allThreadsInfo.lastScheduledTime = 0;
+        threadGroupsInfoMap.clear();
+    }
+    
+    /**
+     * @see org.apache.jmeter.testelement.TestListener#testStarted()
+     */
+    public void testStarted() {
+        reset();
+    }
+    
+    /**
+     * @see org.apache.jmeter.testelement.TestListener#testEnded()
+     */
+    public void testEnded() {
+        reset();
+    }
 
-   /**
-    * Gets the configured desired throughput.
-    * 
-    * @return the rate at which samples should occur, in samples per minute.
-    */
-   public double getThroughput() {
-       return throughput;
-   }
-
-   public String getCalcMode() {
-       return calcMode;
-   }
-
-   public void setCalcMode(String mode) {
-       // TODO find better way to get modeInt
-       this.modeInt = ConstantThroughputTimerBeanInfo.getCalcModeAsInt(calcMode);
-       this.calcMode = mode;
-   }
-
-   /**
-    * Retrieve the delay to use during test execution.
-    * 
-    * @see org.apache.jmeter.timers.Timer#delay()
-    */
-   public synchronized long delay() {
-       long currentTime = System.currentTimeMillis();
-       long currentTarget = previousTime == 0 ? currentTime : previousTime;
-       previousTime = currentTarget + calculateDelay();
-       if (currentTime > currentTarget) {
-           // We're behind schedule -- try to catch up:
-           return 0;
-       }
-       return currentTarget - currentTime;
-   }
-
-   /**
-    * @param currentTime
-    * @return new Target time
-    */
-   protected long calculateCurrentTarget(long currentTime) {
-       return currentTime + calculateDelay();
-   }
-
-   // Calculate the delay based on the mode
-   private long calculateDelay() {
-       long offset = 0;
-       long rate = (long) (MILLISEC_PER_MIN / getThroughput());
-       switch (modeInt) {
-       case 1: // Total number of threads
-           offset = (
-           // previousTime == 0 ? //TODO - why is this needed?
-                   // (JMeterContextService.getContext().getThreadNum() + 1)
-                   // :
-                   JMeterContextService.getNumberOfThreads()) * rate;
-           break;
-       case 2: // Active threads in this group
-           offset = JMeterContextService.getContext().getThread().getThreadGroup().getNumberOfThreads() * rate;
-           break;
-       default:
-           offset = rate; // i.e. rate * 1
-           break;
-       }
-       return offset;
-   }
-
-   /**
-    * Provide a description of this timer class.
-    * 
-    * TODO: Is this ever used? I can't remember where. Remove if it isn't --
-    * TODO: or obtain text from bean's displayName or shortDescription.
-    * 
-    * @return the description of this timer class.
-    */
-   public String toString() {
-       return JMeterUtils.getResString("constant_throughput_timer_memo");
-   }
-
-   /**
-    * Get the timer ready to compute delays for a new test.
-    * 
-    * @see org.apache.jmeter.testelement.TestListener#testStarted()
-    */
-   public synchronized void testStarted()// synch to protect targetTime
-   {
-       log.debug("Test started - reset throughput calculation.");
-       previousTime = 0;
-   }
-
-   /*
-    * (non-Javadoc)
-    * 
-    * @see org.apache.jmeter.testelement.TestListener#testEnded()
-    */
-   public void testEnded() {
-   }
-
-   /*
-    * (non-Javadoc)
-    * 
-    * @see org.apache.jmeter.testelement.TestListener#testStarted(java.lang.String)
-    */
-   public void testStarted(String host) {
-       testStarted();
-   }
-
-   /*
-    * (non-Javadoc)
-    * 
-    * @see org.apache.jmeter.testelement.TestListener#testEnded(java.lang.String)
-    */
-   public void testEnded(String host) {
-   }
-
-   /*
-    * (non-Javadoc)
-    * 
-    * @see org.apache.jmeter.testelement.TestListener#testIterationStart(org.apache.jmeter.engine.event.LoopIterationEvent)
-    */
-   public void testIterationStart(LoopIterationEvent event) {
-   }
+    /**
+     * @see org.apache.jmeter.testelement.TestListener#testEnded(java.lang.String)
+     */
+    public void testEnded(String host) {
+    }
+    /**
+     * @see org.apache.jmeter.testelement.TestListener#testIterationStart(org.apache.jmeter.engine.event.LoopIterationEvent)
+     */
+    public void testIterationStart(LoopIterationEvent event) {
+    }
+    /**
+     * @see org.apache.jmeter.testelement.TestListener#testStarted(java.lang.String)
+     */
+    public void testStarted(String host) {
+    }
 }
\ No newline at end of file
