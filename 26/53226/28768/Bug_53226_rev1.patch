# This patch file was generated by NetBeans IDE
# Following Index: paths are relative to: C:\Users\ihayden\Documents\NetBeansProjects\JMeter\src
# This patch can be applied using context Tools: Patch action on respective folder.
# It uses platform neutral UTF-8 encoding and \n newlines.
# Above lines and this line are ignored by the patching process.
Index: core/org/apache/jmeter/gui/action/ActionRouter.java
--- core/org/apache/jmeter/gui/action/ActionRouter.java Base (BASE)
+++ core/org/apache/jmeter/gui/action/ActionRouter.java Locally Modified (Based On LOCAL)
@@ -255,25 +255,24 @@
         try {
             List<String> listClasses = ClassFinder.findClassesThatExtend(
                     JMeterUtils.getSearchPaths(), 
-                    new Class[] {Class.forName("org.apache.jmeter.gui.action.Command") }); // $NON-NLS-1$
+                    new Class[] {Class.forName("org.apache.jmeter.gui.action.Command") }, // $NON-NLS-1$
+                    false, "org.apache.jmeter.gui", null, false); // $NON-NLS-1$
             commands = new HashMap<String, Set<Command>>(listClasses.size());
-            if (listClasses.size() == 0) {
+            if (listClasses.isEmpty()) {
                 log.fatalError("!!!!!Uh-oh, didn't find any action handlers!!!!!");
                 throw new JMeterError("No action handlers found - check JMeterHome and libraries");
             }
             for (String strClassName : listClasses) {
-                if (strClassName.startsWith("org.apache.jmeter.gui")) { // $NON-NLS-1$
-                    Class<?> commandClass = Class.forName(strClassName);
-                    if (!Modifier.isAbstract(commandClass.getModifiers())) {
-                        Command command = (Command) commandClass.newInstance();
-                        for (String commandName : command.getActionNames()) {
-                            Set<Command> commandObjects = commands.get(commandName);
-                            if (commandObjects == null) {
-                                commandObjects = new HashSet<Command>();
-                                commands.put(commandName, commandObjects);
-                            }
-                            commandObjects.add(command);
+                Class<?> commandClass = Class.forName(strClassName);
+                if (!Modifier.isAbstract(commandClass.getModifiers())) {
+                    Command command = (Command) commandClass.newInstance();
+                    for (String commandName : command.getActionNames()) {
+                        Set<Command> commandObjects = commands.get(commandName);
+                        if (commandObjects == null) {
+                            commandObjects = new HashSet<Command>();
+                            commands.put(commandName, commandObjects);
                         }
+                        commandObjects.add(command);
                     }
                 }
             }
@@ -293,12 +292,12 @@
      */
     public static ActionRouter getInstance() {
         if (router == null) {
-        	synchronized (LOCK) {
-        		if(router == null) {
-	                router = new ActionRouter();
-	                router.populateCommandMap();
-        		}				
-			}
+            synchronized (LOCK) {
+                if (router == null) {
+                    router = new ActionRouter();
+                    router.populateCommandMap();
+                }
+            }
         }
         return router;
     }
Index: jorphan/org/apache/jorphan/reflect/ClassFinder.java
--- jorphan/org/apache/jorphan/reflect/ClassFinder.java Base (BASE)
+++ jorphan/org/apache/jorphan/reflect/ClassFinder.java Locally Modified (Based On LOCAL)
@@ -19,20 +19,22 @@
 package org.apache.jorphan.reflect;
 
 import java.io.File;
-import java.io.FilenameFilter;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
-import java.util.Enumeration;
+import java.util.Collection;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.TreeSet;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipFile;
+import java.util.jar.JarEntry;
+import java.util.jar.JarInputStream;
 
 import org.apache.jorphan.logging.LoggingManager;
 import org.apache.jorphan.util.JOrphanUtils;
@@ -48,6 +50,8 @@
     private static final String DOT_JAR = ".jar"; // $NON-NLS-1$
     private static final String DOT_CLASS = ".class"; // $NON-NLS-1$
     private static final int DOT_CLASS_LEN = DOT_CLASS.length();
+    private static Map<String, List<String>> jarCache = new HashMap<String, List<String>>();
+    private static Map<String, Class<?>> classCache = new HashMap<String, Class<?>>();
 
     // static only
     private ClassFinder() {
@@ -108,6 +112,15 @@
             }
             return false;
         }
+
+        @Override
+        public boolean addAll(Collection<? extends String> c) {
+            boolean success = true;
+            for (Object o : c) {
+                success &= this.add((String) o);
+            }
+            return success;
+        }
     }
 
     private static class AnnoFilterTreeSet extends TreeSet<String>{
@@ -159,27 +172,46 @@
     }
 
     // For each directory in the search path, add all the jars found there
-    private static String[] addJarsInPath(String[] paths) {
-        Set<String> fullList = new HashSet<String>();
-        for (int i = 0; i < paths.length; i++) {
-            final String path = paths[i];
-            fullList.add(path); // Keep the unexpanded path
-            // TODO - allow directories to end with .jar by removing this check?
-            if (!path.endsWith(DOT_JAR)) {
-                File dir = new File(path);
-                if (dir.exists() && dir.isDirectory()) {
-                    String[] jars = dir.list(new FilenameFilter() {
-                        public boolean accept(File f, String name) {
-                            return name.endsWith(DOT_JAR);
+    private static String[] addJarsInPath(String[] paths) throws IOException {
+        Set<String> results = new HashSet<String>();
+        for (String path : paths) {
+            File file = new File(path);
+            addJarsToCache(file, results);
+        }
+        return results.toArray(new String[results.size()]);
+    }
+    
+    private static void addJarsToCache(File file, Set<String> checkedJars) throws IOException {
+        if(file.isDirectory()) {
+            for (File entry : file.listFiles()) {
+                addJarsToCache(entry, checkedJars);
+            }
+        } else {
+            String cacheKey = file.getCanonicalPath();
+            if(file.exists() && file.getName().endsWith(DOT_JAR)) {
+                if (!jarCache.containsKey(cacheKey)) { // not chached yet, read file
+                    List<String> toCache = new ArrayList<String>();
+                    JarInputStream jar = null;
+                    try {
+                        jar = new JarInputStream(new FileInputStream(file));
+                        JarEntry entry;
+                        while ((entry = jar.getNextJarEntry()) != null) {
+                            if (entry.getName().endsWith(DOT_CLASS)) {
+                                toCache.add(fixClassName(entry.getName()));
+                            }
                         }
-                    });
-                    for (int x = 0; x < jars.length; x++) {
-                        fullList.add(jars[x]);
+                    } catch (IOException e) {
+                        log.warn("Can not open the jar " + file + " " + e.getLocalizedMessage(),e);
                     }
+                    finally {
+                        if (jar != null)
+                            try { jar.close(); } catch (Exception e) {}
+                        jarCache.put(cacheKey, toCache);
+                    }
                 }
+                checkedJars.add(cacheKey);
             }
         }
-        return fullList.toArray(new String[fullList.size()]);
     }
 
     /**
@@ -253,7 +285,7 @@
      *
      * @return List containing discovered classes
      */
-    private static List<String> findClassesThatExtend(String[] strPathsOrJars,
+    public static List<String> findClassesThatExtend(String[] strPathsOrJars,
                 final Class<?>[] classNames, final boolean innerClasses,
                 String contains, String notContains, boolean annotations)
                 throws IOException  {
@@ -296,16 +328,6 @@
             }
         }
 
-//        // Now keep only the required classes
-//        Set subClassList = findAllSubclasses(superClasses, listClasses, innerClasses);
-//        if (log.isDebugEnabled()) {
-//            log.debug("subClassList.size()="+subClassList.size());
-//            Iterator tIter = subClassList.iterator();
-//            while (tIter.hasNext()) {
-//                log.debug("subClassList : " + tIter.next());
-//            }
-//        }
-
         return new ArrayList<String>(listClasses);//subClassList);
     }
 
@@ -326,7 +348,7 @@
 
         // find all jar files or paths that end with strPathOrJar
         ArrayList<String> listPaths = new ArrayList<String>();
-        String strPath = null;
+        String strPath;
         while (stPaths.hasMoreTokens()) {
             strPath = fixPathEntry(stPaths.nextToken());
             if (strPathsOrJars == null) {
@@ -374,82 +396,7 @@
         return path;
     }
 
-    /*
-     * NOTUSED * Determine if the class implements the interface.
-     *
-     * @param theClass
-     *            the class to check
-     * @param theInterface
-     *            the interface to look for
-     * @return boolean true if it implements
-     *
-     * private static boolean classImplementsInterface( Class theClass, Class
-     * theInterface) { HashMap mapInterfaces = new HashMap(); String strKey =
-     * null; // pass in the map by reference since the method is recursive
-     * getAllInterfaces(theClass, mapInterfaces); Iterator iterInterfaces =
-     * mapInterfaces.keySet().iterator(); while (iterInterfaces.hasNext()) {
-     * strKey = (String) iterInterfaces.next(); if (mapInterfaces.get(strKey) ==
-     * theInterface) { return true; } } return false; }
-     */
 
-    /*
-     * Finds all classes that extend the classes in the listSuperClasses
-     * ArrayList, searching in the listAllClasses ArrayList.
-     *
-     * @param superClasses
-     *            the base classes to find subclasses for
-     * @param listAllClasses
-     *            the collection of classes to search in
-     * @param innerClasses
-     *            indicate whether to include inner classes in the search
-     * @return ArrayList of the subclasses
-     */
-//  private static Set findAllSubclasses(Class []superClasses, Set listAllClasses, boolean innerClasses) {
-//      Set listSubClasses = new TreeSet();
-//      for (int i=0; i< superClasses.length; i++) {
-//          findAllSubclassesOneClass(superClasses[i], listAllClasses, listSubClasses, innerClasses);
-//      }
-//      return listSubClasses;
-//  }
-
-    /*
-     * Finds all classes that extend the class, searching in the listAllClasses
-     * ArrayList.
-     *
-     * @param theClass
-     *            the parent class
-     * @param listAllClasses
-     *            the collection of classes to search in
-     * @param listSubClasses
-     *            the collection of discovered subclasses
-     * @param innerClasses
-     *            indicates whether inners classes should be included in the
-     *            search
-     */
-//  private static void findAllSubclassesOneClass(Class theClass, Set listAllClasses, Set listSubClasses,
-//          boolean innerClasses) {
-//        Iterator iterClasses = listAllClasses.iterator();
-//      while (iterClasses.hasNext()) {
-//            String strClassName = (String) iterClasses.next();
-//          // only check classes if they are not inner classes
-//          // or we intend to check for inner classes
-//          if ((strClassName.indexOf("$") == -1) || innerClasses) { // $NON-NLS-1$
-//              // might throw an exception, assume this is ignorable
-//              try {
-//                  Class c = Class.forName(strClassName, false, Thread.currentThread().getContextClassLoader());
-//
-//                  if (!c.isInterface() && !Modifier.isAbstract(c.getModifiers())) {
-//                        if(theClass.isAssignableFrom(c)){
-//                            listSubClasses.add(strClassName);
-//                        }
-//                    }
-//              } catch (Throwable ignored) {
-//                    log.debug(ignored.getLocalizedMessage());
-//              }
-//          }
-//      }
-//  }
-
     /**
      *
      * @param parentClasses list of classes to check for
@@ -462,8 +409,13 @@
             ClassLoader contextClassLoader){
             // might throw an exception, assume this is ignorable
             try {
-                Class<?> c = Class.forName(strClassName, false, contextClassLoader);
-
+                Class<?> c;
+                if (!classCache.containsKey(strClassName)) {
+                    c = Class.forName(strClassName, false, contextClassLoader);
+                    classCache.put(strClassName, c);
+                } else {
+                    c = classCache.get(strClassName);
+                }
                 if (!c.isInterface() && !Modifier.isAbstract(c.getModifiers())) {
                     for (int i=0; i< parentClasses.length; i++) {
                         if(parentClasses[i].isAssignableFrom(c)){
@@ -517,50 +469,29 @@
         return strClassName;
     }
 
-    private static void findClassesInOnePath(String strPath, Set<String> listClasses) throws IOException {
-        File file = new File(strPath);
-        if (file.isDirectory()) {
-            findClassesInPathsDir(strPath, file, listClasses);
-        } else if (file.exists()) {
-            ZipFile zipFile = null;
-            try {
-                zipFile = new ZipFile(file);
-                Enumeration<? extends ZipEntry> entries = zipFile.entries();
-                while (entries.hasMoreElements()) {
-                    String strEntry = entries.nextElement().toString();
-                    if (strEntry.endsWith(DOT_CLASS)) {
-                        listClasses.add(fixClassName(strEntry));
-                    }
-                }
-            } catch (IOException e) {
-                log.warn("Can not open the jar " + strPath + " " + e.getLocalizedMessage(),e);
-            }
-            finally {
-                if(zipFile != null) {
-                    try {zipFile.close();} catch (Exception e) {}
-                }
-            }
+    private static void findClassesInPaths(List<String> listPaths, Set<String> listClasses) throws IOException {
+        for (String path : listPaths) {
+            findClassesInFile(new File(path), listClasses);
         }
     }
 
-    private static void findClassesInPaths(List<String> listPaths, Set<String> listClasses) throws IOException {
-        for (String path : listPaths) {
-            findClassesInOnePath(path, listClasses);
+    private static void findClassesInFile(File file, Set<String> listClasses) throws IOException {
+        if (file.isDirectory()) {
+            findClassesInDir(file, listClasses);
+        } else {
+            String cacheKey = file.getCanonicalPath();
+            List<String> values;
+            if ((values = jarCache.get(cacheKey)) != null) {
+                listClasses.addAll(values);
+            }
         }
     }
 
-    private static void findClassesInPathsDir(String strPathElement, File dir, Set<String> listClasses) throws IOException {
-        String[] list = dir.list();
-        for (int i = 0; i < list.length; i++) {
-            File file = new File(dir, list[i]);
-            if (file.isDirectory()) {
-                // Recursive call
-                findClassesInPathsDir(strPathElement, file, listClasses);
-            } else if (list[i].endsWith(DOT_CLASS) && file.exists() && (file.length() != 0)) {
-                final String path = file.getPath();
-                listClasses.add(path.substring(strPathElement.length() + 1,
-                        path.lastIndexOf(".")) // $NON-NLS-1$
-                        .replace(File.separator.charAt(0), '.')); // $NON-NLS-1$
\ No newline at end of file
+    private static void findClassesInDir(File dir, Set<String> listClasses)
+            throws IOException {
+        if (dir.isDirectory()) {
+            for (File f : dir.listFiles()) {
+                findClassesInFile(f, listClasses);
             }
         }
     }
