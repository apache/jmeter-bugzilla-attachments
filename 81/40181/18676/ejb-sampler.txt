Index: D:/Development/Eclipse/Workspace/jmeter/src/jorphan/org/apache/jorphan/gui/ObjectTableModel.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/jorphan/org/apache/jorphan/gui/ObjectTableModel.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/jorphan/org/apache/jorphan/gui/ObjectTableModel.java	(working copy)
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2004,2006 The Apache Software Foundation.
+ * Copyright 2003-2004 The Apache Software Foundation.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 
@@ -56,7 +57,7 @@
         int numClasses = classes.size();
         if (numClasses != numHeaders){
             log.warn("Header count="+numHeaders+" but classes count="+numClasses);
-        }
+		}
         
         // Functor count = 0 is handled specially 
         int numWrite = writeFunctors.length;
@@ -85,6 +86,15 @@
 		objects.add(value);
 		super.fireTableRowsInserted(objects.size() - 1, objects.size());
 	}
+    
+    public void setRows(Collection rows)
+    {
+        clearData();
+        for (Iterator iter = rows.iterator(); iter.hasNext();) {
+            Object val = iter.next();
+            addRow(val);
+        }
+    }
 
 	public void insertRow(Object value, int index) {
 		objects.add(index, value);
@@ -183,5 +193,10 @@
 	public Class getColumnClass(int arg0) {
 		return (Class) classes.get(arg0);
 	}
+    
+    public List getObjectList()
+    {
+        return objects;
+    }
 
 }
Index: D:/Development/Eclipse/Workspace/jmeter/src/jorphan/org/apache/jorphan/reflect/ClassFinder.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/jorphan/org/apache/jorphan/reflect/ClassFinder.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/jorphan/org/apache/jorphan/reflect/ClassFinder.java	(working copy)
@@ -43,49 +43,56 @@
  * @version $Revision$
  */
 public final class ClassFinder {
+
     private static final Logger log = LoggingManager.getLoggerForClass();
 
     private static final String DOT_JAR = ".jar"; // $NON-NLS-1$
+
     private static final String DOT_CLASS = ".class"; // $NON-NLS-1$
+
     private static final int DOT_CLASS_LEN = DOT_CLASS.length();
 
     // static only
-	private ClassFinder() {
-	}
-    
+    private ClassFinder() {
+    }
+
     /**
-     * Filter updates to TreeSet by only storing classes
-     * that extend one of the parent classes
+     * Filter updates to TreeSet by only storing classes that extend one of the
+     * parent classes
      * 
-     *
+     * 
      */
-    private static class FilterTreeSet extends TreeSet{
+    private static class FilterTreeSet extends TreeSet {
+
         private final Class[] parents; // parent classes to check
+
         private final boolean inner; // are inner classes OK?
 
-        private final ClassLoader contextClassLoader 
-            = Thread.currentThread().getContextClassLoader(); // Potentially expensive; do it once
-        
-        FilterTreeSet(Class []parents, boolean inner){
+        private final ClassLoader contextClassLoader = Thread.currentThread()
+            .getContextClassLoader(); // Potentially expensive; do it once
+
+        FilterTreeSet(Class[] parents, boolean inner) {
             super();
-            this.parents=parents;
-            this.inner=inner;
+            this.parents = parents;
+            this.inner = inner;
         }
-        
+
         /**
-         * Override the superclass so we only add classnames that
-         * meet the criteria.
+         * Override the superclass so we only add classnames that meet the
+         * criteria.
          * 
-         * @param o - classname (must be a String)
+         * @param o -
+         *            classname (must be a String)
          * @return true if it is a new entry
          * 
          * @see java.util.TreeSet#add(java.lang.Object)
          */
-        public boolean add(Object o){
-            if (contains(o)) return false;// No need to check it again
+        public boolean add(Object o) {
+            if (contains(o))
+                return false;// No need to check it again
             String s = (String) o;// we only expect Strings
             if ((s.indexOf("$") == -1) || inner) { // $NON-NLS-1$
-                if (isChildOf(parents,s, contextClassLoader)) {
+                if (isChildOf(parents, s, contextClassLoader)) {
                     return super.add(s);
                 }
             }
@@ -93,18 +100,158 @@
         }
     }
 
-	/**
-	 * Convenience method for 
-     * <code>findClassesThatExtend(Class[], boolean)</code>
-	 * with the option to include inner classes in the search set to false.
-	 * 
-	 * @return List containing discovered classes.
-	 */
-	public static List findClassesThatExtend(String[] paths, Class[] superClasses) 
-        throws IOException,	ClassNotFoundException {
-		return findClassesThatExtend(paths, superClasses, false);
-	}
+    // static only
+    /**
+     * Convenience method for <code>findClassesThatExtend(Class[],
+     * boolean)</code>
+     * with the option to include inner classes in the search set to false.
+     * 
+     * @return ArrayList containing discovered classes.
+     */
+    public static List findClassesThatExtend(String[] paths,
+        Class[] superClasses) throws IOException, ClassNotFoundException {
+        return findClassesThatExtend(paths, superClasses, false);
+    }
 
+    /**
+     * Convenience method for <code>findClassesThatExtend(Class[],
+     * boolean)</code>
+     * with the option to include interfaces and abstract classes in the search
+     * set to false.
+     * 
+     * @return ArrayList containing discovered classes.
+     */
+    public static List findClassesThatExtend(String[] paths,
+        Class[] superClasses, boolean innerClasses) throws IOException,
+        ClassNotFoundException {
+        return findClassesThatExtend(paths, superClasses, innerClasses, false);
+    }
+
+    public static List findClassesThatExtend(String[] strPathsOrJars,
+        Class[] superClasses, boolean innerClasses, boolean abstractClasses)
+        throws IOException, ClassNotFoundException {
+        List listPaths = null;
+        Set listClasses = null;
+        List listSuperClasses = null;
+        strPathsOrJars = addJarsInPath(strPathsOrJars);
+        if (log.isDebugEnabled()) {
+            for (int k = 0; k < strPathsOrJars.length; k++) {
+                log.debug("strPathsOrJars : " + strPathsOrJars[k]);
+            }
+        }
+        listPaths = getClasspathMatches(strPathsOrJars);
+        if (log.isDebugEnabled()) {
+            Iterator tIter = listPaths.iterator();
+            for (; tIter.hasNext();) {
+                log.debug("listPaths : " + tIter.next());
+            }
+        }
+        listClasses = new TreeSet();
+        listSuperClasses = new ArrayList();
+        for (int i = 0; i < superClasses.length; i++) {
+            listSuperClasses.add(superClasses[i].getName());
+        }
+        // first get all the classes
+        findClassesInPaths(listPaths, listClasses);
+        if (log.isDebugEnabled()) {
+            Iterator tIter = listClasses.iterator();
+            for (; tIter.hasNext();) {
+                log.debug("listClasses : " + tIter.next());
+            }
+        }
+        Set subClassList = findAllSubclasses(
+            listSuperClasses,
+            listClasses,
+            innerClasses,
+            abstractClasses);
+        return new ArrayList(subClassList);
+    }
+    
+    /**
+     * Finds all classes that extend the classes in the listSuperClasses
+     * ArrayList, searching in the listAllClasses ArrayList.
+     * 
+     * @param listSuperClasses
+     *            the base classes to find subclasses for
+     * @param listAllClasses
+     *            the collection of classes to search in
+     * @param innerClasses
+     *            indicate whether to include inner classes in the search
+     * @param abstractClasses
+     *            indicate whether to include interfaces or abstract classes in the search
+     * @return ArrayList of the subclasses
+     */
+    private static Set findAllSubclasses(List listSuperClasses, Set listAllClasses, boolean innerClasses, boolean abstractClasses) {
+        Iterator iterClasses = null;
+        Set listSubClasses = null;
+        String strClassName = null;
+        Class tempClass = null;
+        listSubClasses = new TreeSet();
+        iterClasses = listSuperClasses.iterator();
+        while (iterClasses.hasNext()) {
+            strClassName = (String) iterClasses.next();
+            // only check classes if they are not inner classes
+            // or we intend to check for inner classes
+            if ((strClassName.indexOf("$") == -1) || innerClasses) {
+                // might throw an exception, assume this is ignorable
+                try {
+                    tempClass = Class.forName(strClassName, false, Thread.currentThread().getContextClassLoader());
+                    findAllSubclassesOneClass(tempClass, listAllClasses, listSubClasses, innerClasses, abstractClasses);
+                    // call by reference - recursive
+                } catch (Throwable ignored) {
+                }
+            }
+        }
+        return listSubClasses;
+    }
+    
+    /**
+     * Finds all classes that extend the class, searching in the listAllClasses
+     * ArrayList.
+     * 
+     * @param theClass
+     *            the parent class
+     * @param listAllClasses
+     *            the collection of classes to search in
+     * @param listSubClasses
+     *            the collection of discovered subclasses
+     * @param innerClasses
+     *            indicates whether inners classes should be included in the
+     *            search
+     * @param acceptAbstract
+     *            indicates whether interfaces or abstract classes should be included in the
+     *            search
+     */
+    private static void findAllSubclassesOneClass(Class theClass, Set listAllClasses, Set listSubClasses,
+            boolean innerClasses, boolean acceptAbstract) {
+        Iterator iterClasses = null;
+        String strClassName = null;
+        Class c = null;
+        boolean bIsSubclass = false;
+        iterClasses = listAllClasses.iterator();
+        while (iterClasses.hasNext()) {
+            strClassName = (String) iterClasses.next();
+            // only check classes if they are not inner classes
+            // or we intend to check for inner classes
+            if ((strClassName.indexOf("$") == -1) || innerClasses) {
+                // might throw an exception, assume this is ignorable
+                try {
+                    c = Class.forName(strClassName, false, Thread.currentThread().getContextClassLoader());
+
+                    if ((!c.isInterface() && !Modifier.isAbstract(c.getModifiers())) || acceptAbstract) {
+                        bIsSubclass = theClass.isAssignableFrom(c);
+                    } else {
+                        bIsSubclass = false;
+                    }
+                    if (bIsSubclass) {
+                        listSubClasses.add(strClassName);
+                    }
+                } catch (Throwable ignored) {
+                }
+            }
+        }
+    }
+
     // For each directory in the search path, add all the jars found there
     private static String[] addJarsInPath(String[] paths) {
         Set fullList = new HashSet();
@@ -116,6 +263,7 @@
                 File dir = new File(path);
                 if (dir.exists() && dir.isDirectory()) {
                     String[] jars = dir.list(new FilenameFilter() {
+
                         public boolean accept(File f, String name) {
                             return name.endsWith(DOT_JAR);
                         }
@@ -129,278 +277,224 @@
         return (String[]) fullList.toArray(new String[0]);
     }
 
-    /**
-     * Find classes in the provided path(s)/jar(s) that extend the class(es).
-     * @param strPathsOrJars - pathnames or jarfiles to search for classes
-     * @param superClasses - required parent class(es)
-     * @param innerClasses - should we include inner classes?
-     * 
-     * @return List containing discovered classes
-     */
-	public static List findClassesThatExtend(String[] strPathsOrJars, 
-            final Class[] superClasses, final boolean innerClasses)
-			throws IOException, ClassNotFoundException {
-        
-        // Find all jars in the search path
-		strPathsOrJars = addJarsInPath(strPathsOrJars);
-        for (int k = 0; k < strPathsOrJars.length; k++) {
-            strPathsOrJars[k] = fixPathEntry(strPathsOrJars[k]);
-    		if (log.isDebugEnabled()) {
-				log.debug("strPathsOrJars : " + strPathsOrJars[k]);
-			}
-		}
-        
-        // Now eliminate any classpath entries that do not "match" the search
-		List listPaths = getClasspathMatches(strPathsOrJars);
-		if (log.isDebugEnabled()) {
-			Iterator tIter = listPaths.iterator();
-			while (tIter.hasNext()) {
-				log.debug("listPaths : " + tIter.next());
-			}
-		}
-        
-		Set listClasses = new FilterTreeSet(superClasses, innerClasses);
-		// first get all the classes
-		findClassesInPaths(listPaths, listClasses);
-		if (log.isDebugEnabled()) {
-            log.debug("listClasses.size()="+listClasses.size());
-			Iterator tIter = listClasses.iterator();
-			while (tIter.hasNext()) {
-				log.debug("listClasses : " + tIter.next());
-			}
-		}
-        
-//        // Now keep only the required classes
-//		Set subClassList = findAllSubclasses(superClasses, listClasses, innerClasses);
-//        if (log.isDebugEnabled()) {
-//            log.debug("subClassList.size()="+subClassList.size());
-//            Iterator tIter = subClassList.iterator();
-//            while (tIter.hasNext()) {
-//                log.debug("subClassList : " + tIter.next());
-//            }
-//        }
-        
-		return new ArrayList(listClasses);//subClassList);
-	}
-
     /*
-     * Returns the classpath entries that match the search list of jars and paths
+     * Returns the classpath entries that match the search list of jars and
+     * paths
      */
-	private static List getClasspathMatches(String[] strPathsOrJars) {
-		log.debug("Classpath = " + System.getProperty("java.class.path")); // $NON-NLS-1$
-        StringTokenizer stPaths = 
-            new StringTokenizer(System.getProperty("java.class.path"), // $NON-NLS-1$ 
-                System.getProperty("path.separator")); // $NON-NLS-1$
-		if (log.isDebugEnabled()) {
-			for (int i = 0; i < strPathsOrJars.length; i++) {
-				log.debug("strPathsOrJars[" + i + "] : " + strPathsOrJars[i]);
-			}
-		}
+    private static List getClasspathMatches(String[] strPathsOrJars) {
+        log.debug("Classpath = " + System.getProperty("java.class.path")); // $NON-NLS-1$
+        StringTokenizer stPaths = new StringTokenizer(
+            System.getProperty("java.class.path"), // $NON-NLS-1$
+            System.getProperty("path.separator")); // $NON-NLS-1$
+        if (log.isDebugEnabled()) {
+            for (int i = 0; i < strPathsOrJars.length; i++) {
+                log.debug("strPathsOrJars[" + i + "] : " + strPathsOrJars[i]);
+            }
+        }
 
-		// find all jar files or paths that end with strPathOrJar
+        // find all jar files or paths that end with strPathOrJar
         ArrayList listPaths = new ArrayList();
         String strPath = null;
-		while (stPaths.hasMoreTokens()) {
-			strPath = fixPathEntry(stPaths.nextToken());
-			if (strPathsOrJars == null) {
-				log.debug("Adding: " + strPath);
-				listPaths.add(strPath);
-			} else {
-				boolean found = false;
-				for (int i = 0; i < strPathsOrJars.length; i++) {
-					if (strPath.endsWith(strPathsOrJars[i])) {
-						found = true;
-						log.debug("Adding " + strPath + " found at " + i);
-						listPaths.add(strPath);
-						break;// no need to look further
-					}
-				}
-				if (!found) {
-					log.debug("Did not find: " + strPath);
-				}
-			}
-		}
-		return listPaths;
-	}
+        while (stPaths.hasMoreTokens()) {
+            strPath = fixPathEntry(stPaths.nextToken());
+            if (strPathsOrJars == null) {
+                log.debug("Adding: " + strPath);
+                listPaths.add(strPath);
+            } else {
+                boolean found = false;
+                for (int i = 0; i < strPathsOrJars.length; i++) {
+                    if (strPath.endsWith(strPathsOrJars[i])) {
+                        found = true;
+                        log.debug("Adding " + strPath + " found at " + i);
+                        listPaths.add(strPath);
+                        break;// no need to look further
+                    }
+                }
+                if (!found) {
+                    log.debug("Did not find: " + strPath);
+                }
+            }
+        }
+        return listPaths;
+    }
 
     /**
-     * Fix a path:
-     * - replace "." by current directory
-     * - trim any trailing spaces
-     * - replace \ by /
-     * - replace // by /
-     * - remove all trailing /
+     * Fix a path: - replace "." by current directory - trim any trailing spaces -
+     * replace \ by / - replace // by / - remove all trailing /
      */
-    private static String fixPathEntry(String path){
-        if (path == null ) return null;
+    private static String fixPathEntry(String path) {
+        if (path == null)
+            return null;
         if (path.equals(".")) { // $NON-NLS-1$
             return System.getProperty("user.dir"); // $NON-NLS-1$
         }
         path = path.trim().replace('\\', '/'); // $NON-NLS-1$ // $NON-NLS-2$
-        path = JOrphanUtils.substitute(path, "//", "/"); // $NON-NLS-1$// $NON-NLS-2$
+        path = JOrphanUtils.substitute(path, "//", "/"); // $NON-NLS-1$//
+                                                            // $NON-NLS-2$
 
         while (path.endsWith("/")) { // $NON-NLS-1$
             path = path.substring(0, path.length() - 1);
         }
         return path;
     }
-    
-	/*
-	 * NOTUSED * Determine if the class implements the interface.
-	 * 
-	 * @param theClass
-	 *            the class to check
-	 * @param theInterface
-	 *            the interface to look for
-	 * @return boolean true if it implements
-	 * 
-	 * private static boolean classImplementsInterface( Class theClass, Class
-	 * theInterface) { HashMap mapInterfaces = new HashMap(); String strKey =
-	 * null; // pass in the map by reference since the method is recursive
-	 * getAllInterfaces(theClass, mapInterfaces); Iterator iterInterfaces =
-	 * mapInterfaces.keySet().iterator(); while (iterInterfaces.hasNext()) {
-	 * strKey = (String) iterInterfaces.next(); if (mapInterfaces.get(strKey) ==
-	 * theInterface) { return true; } } return false; }
-	 */
 
-	/*
-	 * Finds all classes that extend the classes in the listSuperClasses
-	 * ArrayList, searching in the listAllClasses ArrayList.
-	 * 
-	 * @param superClasses
-	 *            the base classes to find subclasses for
-	 * @param listAllClasses
-	 *            the collection of classes to search in
-	 * @param innerClasses
-	 *            indicate whether to include inner classes in the search
-	 * @return ArrayList of the subclasses
-	 */
-//	private static Set findAllSubclasses(Class []superClasses, Set listAllClasses, boolean innerClasses) {
-//		Set listSubClasses = new TreeSet();
-//		for (int i=0; i< superClasses.length; i++) {
-//			findAllSubclassesOneClass(superClasses[i], listAllClasses, listSubClasses, innerClasses);
-//		}
-//		return listSubClasses;
-//	}
+    /*
+     * NOTUSED * Determine if the class implements the interface.
+     * 
+     * @param theClass the class to check @param theInterface the interface to
+     * look for @return boolean true if it implements
+     * 
+     * private static boolean classImplementsInterface( Class theClass, Class
+     * theInterface) { HashMap mapInterfaces = new HashMap(); String strKey =
+     * null; // pass in the map by reference since the method is recursive
+     * getAllInterfaces(theClass, mapInterfaces); Iterator iterInterfaces =
+     * mapInterfaces.keySet().iterator(); while (iterInterfaces.hasNext()) {
+     * strKey = (String) iterInterfaces.next(); if (mapInterfaces.get(strKey) ==
+     * theInterface) { return true; } } return false; }
+     */
 
-	/*
-	 * Finds all classes that extend the class, searching in the listAllClasses
-	 * ArrayList.
-	 * 
-	 * @param theClass
-	 *            the parent class
-	 * @param listAllClasses
-	 *            the collection of classes to search in
-	 * @param listSubClasses
-	 *            the collection of discovered subclasses
-	 * @param innerClasses
-	 *            indicates whether inners classes should be included in the
-	 *            search
-	 */
-//	private static void findAllSubclassesOneClass(Class theClass, Set listAllClasses, Set listSubClasses,
-//			boolean innerClasses) {
-//        Iterator iterClasses = listAllClasses.iterator();
-//		while (iterClasses.hasNext()) {
-//            String strClassName = (String) iterClasses.next();
-//			// only check classes if they are not inner classes
-//			// or we intend to check for inner classes
-//			if ((strClassName.indexOf("$") == -1) || innerClasses) { // $NON-NLS-1$
-//				// might throw an exception, assume this is ignorable
-//				try {
-//					Class c = Class.forName(strClassName, false, Thread.currentThread().getContextClassLoader());
-//
-//					if (!c.isInterface() && !Modifier.isAbstract(c.getModifiers())) {
-//                        if(theClass.isAssignableFrom(c)){
-//                            listSubClasses.add(strClassName);
-//                        }
-//                    }
-//				} catch (Throwable ignored) {
-//                    log.debug(ignored.getLocalizedMessage());
-//				}
-//			}
-//		}
-//	}
-
+    /*
+     * Finds all classes that extend the classes in the listSuperClasses
+     * ArrayList, searching in the listAllClasses ArrayList.
+     * 
+     * @param superClasses the base classes to find subclasses for @param
+     * listAllClasses the collection of classes to search in @param innerClasses
+     * indicate whether to include inner classes in the search @return ArrayList
+     * of the subclasses
+     */
+    // private static Set findAllSubclasses(Class []superClasses, Set
+    // listAllClasses, boolean innerClasses) {
+    // Set listSubClasses = new TreeSet();
+    // for (int i=0; i< superClasses.length; i++) {
+    // findAllSubclassesOneClass(superClasses[i], listAllClasses,
+    // listSubClasses, innerClasses);
+    // }
+    // return listSubClasses;
+    // }
+    /*
+     * Finds all classes that extend the class, searching in the listAllClasses
+     * ArrayList.
+     * 
+     * @param theClass the parent class @param listAllClasses the collection of
+     * classes to search in @param listSubClasses the collection of discovered
+     * subclasses @param innerClasses indicates whether inners classes should be
+     * included in the search
+     */
+    // private static void findAllSubclassesOneClass(Class theClass, Set
+    // listAllClasses, Set listSubClasses,
+    // boolean innerClasses) {
+    // Iterator iterClasses = listAllClasses.iterator();
+    // while (iterClasses.hasNext()) {
+    // String strClassName = (String) iterClasses.next();
+    // // only check classes if they are not inner classes
+    // // or we intend to check for inner classes
+    // if ((strClassName.indexOf("$") == -1) || innerClasses) { // $NON-NLS-1$
+    // // might throw an exception, assume this is ignorable
+    // try {
+    // Class c = Class.forName(strClassName, false,
+    // Thread.currentThread().getContextClassLoader());
+    //
+    // if (!c.isInterface() && !Modifier.isAbstract(c.getModifiers())) {
+    // if(theClass.isAssignableFrom(c)){
+    // listSubClasses.add(strClassName);
+    // }
+    // }
+    // } catch (Throwable ignored) {
+    // log.debug(ignored.getLocalizedMessage());
+    // }
+    // }
+    // }
+    // }
     /**
      * 
-     * @param parentClasses list of classes to check for
-     * @param strClassName name of class to be checked
-     * @param innerClasses should we allow inner classes?
-     * @param contextClassLoader the classloader to use
+     * @param parentClasses
+     *            list of classes to check for
+     * @param strClassName
+     *            name of class to be checked
+     * @param innerClasses
+     *            should we allow inner classes?
+     * @param contextClassLoader
+     *            the classloader to use
      * @return
      */
-    private static boolean isChildOf(Class [] parentClasses, String strClassName,
-            ClassLoader contextClassLoader){
-            // might throw an exception, assume this is ignorable
-            try {
-                Class c = Class.forName(strClassName, false, contextClassLoader);
+    private static boolean isChildOf(Class[] parentClasses,
+        String strClassName, ClassLoader contextClassLoader) {
+        // might throw an exception, assume this is ignorable
+        try {
+            Class c = Class.forName(strClassName, false, contextClassLoader);
 
-                if (!c.isInterface() && !Modifier.isAbstract(c.getModifiers())) {
-                    for (int i=0; i< parentClasses.length; i++) {
-                        if(parentClasses[i].isAssignableFrom(c)){
-                            return true;
-                        }
+            if (!c.isInterface() && !Modifier.isAbstract(c.getModifiers())) {
+                for (int i = 0; i < parentClasses.length; i++) {
+                    if (parentClasses[i].isAssignableFrom(c)) {
+                        return true;
                     }
                 }
-            } catch (Throwable ignored) {
-                log.debug(ignored.getLocalizedMessage());
             }
+        } catch (Throwable ignored) {
+            log.debug(ignored.getLocalizedMessage());
+        }
         return false;
     }
-    
-    
-	/*
-	 * Converts a class file from the text stored in a Jar file to a version
-	 * that can be used in Class.forName().
-	 * 
-	 * @param strClassName
-	 *            the class name from a Jar file
-	 * @return String the Java-style dotted version of the name
-	 */
-	private static String fixClassName(String strClassName) {
-		strClassName = strClassName.replace('\\', '.'); // $NON-NLS-1$ // $NON-NLS-2$
-		strClassName = strClassName.replace('/', '.'); // $NON-NLS-1$ // $NON-NLS-2$
+
+    /*
+     * Converts a class file from the text stored in a Jar file to a version
+     * that can be used in Class.forName().
+     * 
+     * @param strClassName the class name from a Jar file @return String the
+     * Java-style dotted version of the name
+     */
+    private static String fixClassName(String strClassName) {
+        strClassName = strClassName.replace('\\', '.'); // $NON-NLS-1$ //
+                                                        // $NON-NLS-2$
+        strClassName = strClassName.replace('/', '.'); // $NON-NLS-1$ //
+                                                        // $NON-NLS-2$
         // remove ".class"
-		strClassName = strClassName.substring(0, strClassName.length() - DOT_CLASS_LEN);
-		return strClassName;
-	}
+        strClassName = strClassName.substring(0, strClassName.length()
+            - DOT_CLASS_LEN);
+        return strClassName;
+    }
 
-	private static void findClassesInOnePath(String strPath, Set listClasses) throws IOException {
+    private static void findClassesInOnePath(String strPath, Set listClasses)
+        throws IOException {
         File file = new File(strPath);
-		if (file.isDirectory()) {
-			findClassesInPathsDir(strPath, file, listClasses);
-		} else if (file.exists()) {
+        if (file.isDirectory()) {
+            findClassesInPathsDir(strPath, file, listClasses);
+        } else if (file.exists()) {
             ZipFile zipFile = new ZipFile(file);
             Enumeration entries = zipFile.entries();
-			while (entries.hasMoreElements()) {
-				String strEntry = entries.nextElement().toString();
-				if (strEntry.endsWith(DOT_CLASS)) {
-					listClasses.add(fixClassName(strEntry));
-				}
-			}
-		}
-	}
+            while (entries.hasMoreElements()) {
+                String strEntry = entries.nextElement().toString();
+                if (strEntry.endsWith(DOT_CLASS)) {
+                    listClasses.add(fixClassName(strEntry));
+                }
+            }
+        }
+    }
 
-	private static void findClassesInPaths(List listPaths, Set listClasses) throws IOException {
-		Iterator iterPaths = listPaths.iterator();
-		while (iterPaths.hasNext()) {
-			findClassesInOnePath((String) iterPaths.next(), listClasses);
-		}
-	}
+    private static void findClassesInPaths(List listPaths, Set listClasses)
+        throws IOException {
+        Iterator iterPaths = listPaths.iterator();
+        while (iterPaths.hasNext()) {
+            findClassesInOnePath((String) iterPaths.next(), listClasses);
+        }
+    }
 
-	private static void findClassesInPathsDir(String strPathElement, File dir, Set listClasses) throws IOException {
-		String[] list = dir.list();
-		for (int i = 0; i < list.length; i++) {
+    private static void findClassesInPathsDir(String strPathElement, File dir,
+        Set listClasses) throws IOException {
+        String[] list = dir.list();
+        for (int i = 0; i < list.length; i++) {
             File file = new File(dir, list[i]);
-			if (file.isDirectory()) {
+            if (file.isDirectory()) {
                 // Recursive call
-				findClassesInPathsDir(strPathElement, file, listClasses);
-			} else if (list[i].endsWith(DOT_CLASS) && file.exists() && (file.length() != 0)) {
-				final String path = file.getPath();
-                listClasses.add(path.substring(strPathElement.length() + 1, 
-                        path.lastIndexOf(".")) // $NON-NLS-1$
-						.replace(File.separator.charAt(0), '.')); // $NON-NLS-1$
-			}
-		}
-	}
+                findClassesInPathsDir(strPathElement, file, listClasses);
+            } else if (list[i].endsWith(DOT_CLASS) && file.exists()
+                && (file.length() != 0)) {
+                final String path = file.getPath();
+                listClasses.add(path.substring(
+                    strPathElement.length() + 1,
+                    path.lastIndexOf(".")) // $NON-NLS-1$
+                    .replace(File.separator.charAt(0), '.')); // $NON-NLS-1$
+            }
+        }
+    }
 }
\ No newline at end of file
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/EJBInvocationContext.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/EJBInvocationContext.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/EJBInvocationContext.java	(revision 0)
@@ -0,0 +1,257 @@
+// $Header: /cvsroot/decalog-jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/EJBInvocationContext.java,v 1.2 2006/02/15 08:47:25 glasnier Exp $
+/*
+ * Copyright 2003-2004 The Apache Software Foundation.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ * 
+ */
+
+package org.apache.jmeter.protocol.ejb;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.jmeter.config.Argument;
+import org.apache.jmeter.threads.JMeterContext;
+import org.apache.jorphan.logging.LoggingManager;
+import org.apache.log.Logger;
+
+/**
+ * EJBInvocationContext is used to provide context information to a
+ * JavaSamplerClient implementation. This currently consists of the
+ * initialization parameters which were specified in the GUI. Additional data
+ * may be accessible through EJBInvocationContext in the future.
+ * 
+ * @author <a href="mailto:jeremy_a@bigfoot.com">Jeremy Arnold</a>
+ * @version $Revision: 1.2 $
+ */
+public class EJBInvocationContext {
+    
+    /**
+     * 
+     * @param arguments
+     * @return
+     */
+    public static List cloneArguments(List arguments) {
+        List clonedArguments = null;
+        if (arguments != null) {
+            clonedArguments = new ArrayList(arguments.size());
+            for (Iterator createArgumentsIt = arguments.iterator(); createArgumentsIt.hasNext();) {
+                Argument argument = (Argument) createArgumentsIt.next();
+                clonedArguments.add(argument.clone());                
+            }
+        }
+        return clonedArguments;
+    }
+
+	private static final Logger log = LoggingManager.getLoggerForClass();
+
+	/**
+	 * Map containing the initialization parameters for the JavaSamplerClient.
+	 */
+	private Map params = null;
+	
+	private JMeterContext threadContext = null;
+
+	/**
+	 * Create a new JavaSampler with the specified initialization parameters.
+	 * 
+	 * @param threadContext the current thread context
+	 * @param args
+	 *            the initialization parameters.
+	 */
+	public EJBInvocationContext(JMeterContext threadContext, List args) {
+		super();
+		this.threadContext = threadContext;
+		this.params = new HashMap();
+        for (Iterator iter = args.iterator(); iter.hasNext();) {
+            Argument argument = (Argument) iter.next();
+            this.params.put(argument.getName(), argument);
+		}
+	}
+
+	/**
+	 * Determine whether or not a value has been specified for the parameter
+	 * with this name.
+	 * 
+	 * @param name
+	 *            the name of the parameter to test
+	 * @return true if the parameter value has been specified, false otherwise.
+	 */
+	public boolean containsParameter(String name) {
+		return params.containsKey(name);
+	}
+
+	/**
+	 * Get an iterator of the parameter names. Each entry in the Iterator is a
+	 * String.
+	 * 
+	 * @return an Iterator of Strings listing the names of the parameters which
+	 *         have been specified for this test.
+	 */
+	public Iterator getParameterNamesIterator() {
+		return params.keySet().iterator();
+	}
+
+	/**
+	 * Get the value of a specific parameter as a String, or null if the value
+	 * was not specified.
+	 * 
+	 * @param name
+	 *            the name of the parameter whose value should be retrieved
+	 * @return the value of the parameter, or null if the value was not
+	 *         specified
+	 */
+	public String getParameter(String name) {
+		return getParameter(name, null);
+	}
+
+	/**
+	 * Get the value of a specified parameter as a String, or return the
+	 * specified default value if the value was not specified.
+	 * 
+	 * @param name
+	 *            the name of the parameter whose value should be retrieved
+	 * @param defaultValue
+	 *            the default value to return if the value of this parameter was
+	 *            not specified
+	 * @return the value of the parameter, or the default value if the parameter
+	 *         was not specified
+	 */
+	public String getParameter(String name, String defaultValue) {
+		if (params == null || !params.containsKey(name)) {
+			return defaultValue;
+		}
+		return ((Argument) params.get(name)).getValue();
+	}
+
+	/**
+	 * Get the value of a specified parameter as an integer. An exception will
+	 * be thrown if the parameter is not specified or if it is not an integer.
+	 * The value may be specified in decimal, hexadecimal, or octal, as defined
+	 * by Integer.decode().
+	 * 
+	 * @param name
+	 *            the name of the parameter whose value should be retrieved
+	 * @return the value of the parameter
+	 * 
+	 * @throws NumberFormatException
+	 *             if the parameter is not specified or is not an integer
+	 * 
+	 * @see java.lang.Integer#decode(java.lang.String)
+	 */
+	public int getIntParameter(String name) throws NumberFormatException {
+		if (params == null || !params.containsKey(name)) {
+			throw new NumberFormatException("No value for parameter named '"
+					+ name + "'.");
+		}
+
+		return Integer.decode(((Argument) params.get(name)).getValue()).intValue();
+	}
+
+	/**
+	 * Get the value of a specified parameter as an integer, or return the
+	 * specified default value if the value was not specified or is not an
+	 * integer. A warning will be logged if the value is not an integer. The
+	 * value may be specified in decimal, hexadecimal, or octal, as defined by
+	 * Integer.decode().
+	 * 
+	 * @param name
+	 *            the name of the parameter whose value should be retrieved
+	 * @param defaultValue
+	 *            the default value to return if the value of this parameter was
+	 *            not specified
+	 * @return the value of the parameter, or the default value if the parameter
+	 *         was not specified
+	 * 
+	 * @see java.lang.Integer#decode(java.lang.String)
+	 */
+	public int getIntParameter(String name, int defaultValue) {
+		if (params == null || !params.containsKey(name)) {
+			return defaultValue;
+		}
+
+		try {
+			return Integer.decode(((Argument) params.get(name)).getValue()).intValue();
+		} catch (NumberFormatException e) {
+			log.warn("Value for parameter '" + name + "' not an integer: '"
+					+ params.get(name) + "'.  Using default: '" + defaultValue
+					+ "'.", e);
+			return defaultValue;
+		}
+	}
+
+	/**
+	 * Get the value of a specified parameter as a long. An exception will be
+	 * thrown if the parameter is not specified or if it is not a long. The
+	 * value may be specified in decimal, hexadecimal, or octal, as defined by
+	 * Long.decode().
+	 * 
+	 * @param name
+	 *            the name of the parameter whose value should be retrieved
+	 * @return the value of the parameter
+	 * 
+	 * @throws NumberFormatException
+	 *             if the parameter is not specified or is not a long
+	 * 
+	 * @see Long#decode(String)
+	 */
+	public long getLongParameter(String name) throws NumberFormatException {
+		if (params == null || !params.containsKey(name)) {
+			throw new NumberFormatException("No value for parameter named '"
+					+ name + "'.");
+		}
+
+		return Long.decode(((Argument) params.get(name)).getValue()).longValue();
+	}
+
+	/**
+	 * Get the value of a specified parameter as along, or return the specified
+	 * default value if the value was not specified or is not a long. A warning
+	 * will be logged if the value is not a long. The value may be specified in
+	 * decimal, hexadecimal, or octal, as defined by Long.decode().
+	 * 
+	 * @param name
+	 *            the name of the parameter whose value should be retrieved
+	 * @param defaultValue
+	 *            the default value to return if the value of this parameter was
+	 *            not specified
+	 * @return the value of the parameter, or the default value if the parameter
+	 *         was not specified
+	 * 
+	 * @see Long#decode(String)
+	 */
+	public long getLongParameter(String name, long defaultValue) {
+		if (params == null || !params.containsKey(name)) {
+			return defaultValue;
+		}
+		try {
+			return Long.decode(((Argument) params.get(name)).getValue()).longValue();
+		} catch (NumberFormatException e) {
+			log.warn("Value for parameter '" + name + "' not a long: '"
+					+ params.get(name) + "'.  Using default: '" + defaultValue
+					+ "'.", e);
+			return defaultValue;
+		}
+	}
+
+	/**
+	 * @return Returns the threadContext.
+	 */
+	public JMeterContext getThreadContext() {
+		return threadContext;
+	}
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/VariableMethodParametersFactory.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/VariableMethodParametersFactory.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/VariableMethodParametersFactory.java	(revision 0)
@@ -0,0 +1,60 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.util.TreeMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import org.apache.jorphan.logging.LoggingManager;
+import org.apache.log.Logger;
+
+/**
+ * @author glasnier
+ *
+ */
+public class VariableMethodParametersFactory implements MethodParametersFactory {
+    
+    public static final String VARIABLE_PATTERN_STRING = "var(\\d+)";
+    
+    private static final Pattern VARIABLE_PATTERN = Pattern.compile(VARIABLE_PATTERN_STRING);
+	
+	private static final Logger log = LoggingManager.getLoggerForClass();
+
+	/**
+	 * 
+	 */
+	public VariableMethodParametersFactory() {
+		super();
+	}
+
+	/**
+	 * @see org.apache.jmeter.protocol.ejb.MethodParametersFactory#createParameters(org.apache.jmeter.protocol.ejb.EJBInvocationContext)
+	 */
+	public Object[] createParameters(EJBInvocationContext ejbInvocationContext) {
+		Iterator iterator = ejbInvocationContext.getParameterNamesIterator();
+        
+        // Paramters should be ordered by their name
+        Map parametersMap = new TreeMap();
+        
+		while (iterator.hasNext()) {
+			String parameterName = (String) iterator.next();
+            Matcher matcher = VARIABLE_PATTERN.matcher(parameterName);
+			if (matcher.matches()) {
+				String variableName = ejbInvocationContext.getParameter(parameterName);
+				Object parameter = ejbInvocationContext.getThreadContext().getVariables().getObject(variableName);
+				parametersMap.put(parameterName, parameter);
+			}
+		}
+		
+        Object parameters[] = parametersMap.values().toArray();
+        
+		log.info("createParameters returned: " + parameters);
+		
+		return parameters;
+	}
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodComparator.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodComparator.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodComparator.java	(revision 0)
@@ -0,0 +1,58 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.lang.reflect.Method;
+import java.util.Comparator;
+
+/**
+ * @author glasnier
+ * 
+ */
+public class MethodComparator implements Comparator {
+
+    /**
+     * 
+     */
+    public MethodComparator() {
+        super();
+    }
+
+    /**
+     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
+     */
+    public int compare(Object o1, Object o2) {
+        if (o1 == o2) {
+            return 0;
+        }
+        else if (o1.equals(o2)) {
+            return 0;
+        }
+        else {
+            Method m1 = (Method) o1;
+            Method m2 = (Method) o2;
+            int nameComp = m1.getName().compareTo(m2.getName());
+
+            if (nameComp == 0) {
+                // Handle overrided methods
+                Class[] paramTypes1 = m1.getParameterTypes();
+                Class[] paramTypes2 = m2.getParameterTypes();
+                if (paramTypes1.length == paramTypes2.length) {
+                    for (int i = 0; i < paramTypes1.length; i++) {
+                        Class paramType1 = paramTypes1[i];
+                        Class paramType2 = paramTypes2[i];
+                        if (!paramType1.equals(paramType2))
+                            nameComp = paramType1.getName().compareTo(
+                                paramType2.getName());
+                    }
+                }
+                else {
+                    nameComp = paramTypes1.length - paramTypes2.length;
+                }
+            }
+            return nameComp;
+        }
+    }
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodWrapperCellRenderer.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodWrapperCellRenderer.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodWrapperCellRenderer.java	(revision 0)
@@ -0,0 +1,74 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.awt.Component;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import javax.swing.JList;
+import javax.swing.plaf.basic.BasicComboBoxRenderer;
+
+/**
+ * @author glasnier
+ * 
+ */
+public class MethodWrapperCellRenderer extends BasicComboBoxRenderer {
+  
+    /**
+     * 
+     */
+    private static final long serialVersionUID = -2790461525611270745L;
+
+    private static final String METHOD_PATTERN_STRING = "(?:public|protected|private )?(?:abstract )?(?:static )?(?:final )?(?:synchronized )?((?:\\w+\\.)*(?:\\w+\\$)?\\w+(?:\\[\\])?) (?:[\\w]+(?:\\.|\\$))+(\\w+\\(.*\\))";
+
+    private static final Pattern METHOD_PATTERN = Pattern.compile(METHOD_PATTERN_STRING);
+
+    /**
+     * 
+     * @param method
+     * @return
+     */
+    public static String formatMethod(MethodWrapper method) {
+        String result = method.toString();
+        Matcher matcher = METHOD_PATTERN.matcher(result);
+        
+        if (matcher.find()) {
+             result  = matcher.group(1) + " " + matcher.group(2);
+        }
+        
+        return result.trim();
+    }
+
+    /**
+     * 
+     */
+    public MethodWrapperCellRenderer() {
+        super();
+    }
+
+    /**
+     * @see javax.swing.plaf.basic.BasicComboBoxRenderer#getListCellRendererComponent(javax.swing.JList,
+     *      java.lang.Object, int, boolean, boolean)
+     */
+    public Component getListCellRendererComponent(JList list, Object value,
+        int index, boolean isSelected, boolean cellHasFocus) {
+        if (value != null && !(value instanceof MethodWrapper)) {
+            throw new ClassCastException("Unsupported type: "
+                + value.getClass());
+        }
+
+        if (value != null) {
+            MethodWrapper valueMethodWrapper = (MethodWrapper) value;
+            value = formatMethod(valueMethodWrapper);
+        }
+
+        return super.getListCellRendererComponent(
+            list,
+            value,
+            index,
+            isSelected,
+            cellHasFocus);
+    }
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/ExcludeMethodSetFilter.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/ExcludeMethodSetFilter.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/ExcludeMethodSetFilter.java	(revision 0)
@@ -0,0 +1,37 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.lang.reflect.Method;
+import java.util.Set;
+
+/**
+ * @author glasnier
+ * 
+ */
+public class ExcludeMethodSetFilter implements MethodFilter {
+
+	private Set excludeMethods = null;
+
+
+	/**
+	 * @param excludeMethods
+	 */
+	public ExcludeMethodSetFilter(Set excludeMethods) {
+		super();
+		this.excludeMethods = excludeMethods;
+	}
+
+
+	/**
+	 * @see org.apache.jmeter.protocol.ejb.MethodFilter#accept(java.lang.reflect.Method)
+	 */
+	public boolean accept(Method method) {
+		if (this.excludeMethods.contains(method))
+			return false;
+		else
+			return true;
+	}
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodWrapper.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodWrapper.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodWrapper.java	(revision 0)
@@ -0,0 +1,164 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.io.IOException;
+import java.io.Serializable;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * @author glasnier
+ * 
+ */
+public class MethodWrapper implements Serializable {
+
+    private static final long serialVersionUID = 2841310309069634170L;
+
+    private transient Method method = null;
+    
+    /**
+     * 
+     * @param method
+     */
+    public MethodWrapper(Method method) {
+        super();
+        if (method == null)
+            throw new NullPointerException("method");
+        this.method = method;
+    }
+
+    /**
+     * 
+     * @param out
+     * @throws IOException
+     */
+    private void writeObject(java.io.ObjectOutputStream out) throws IOException {
+        out.writeObject(this.method.getDeclaringClass());
+        out.writeObject(this.method.getName());
+        out.writeObject(this.method.getParameterTypes());
+    }
+
+    /**
+     * 
+     * @param in
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    private void readObject(java.io.ObjectInputStream in) throws IOException,
+        ClassNotFoundException {
+        Class declaringClass = (Class) in.readObject();
+        String methodName = (String) in.readObject();
+        Class[] parameterTypes = (Class[]) in.readObject();
+
+        try {
+            this.method = declaringClass.getMethod(methodName, parameterTypes);
+        } catch (NoSuchMethodException e) {
+            throw new IOException("No such method " + declaringClass.getName()
+                + "." + methodName);
+        }
+    }
+
+    /**
+     * 
+     */
+    public String toString() {
+        return this.method.toString();
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode() {
+        return method.hashCode();
+    }
+
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        final MethodWrapper other = (MethodWrapper) obj;
+        if (method == null) {
+            if (other.method != null)
+                return false;
+        } else if (!method.equals(other.method))
+            return false;
+        return true;
+    }
+
+    /**
+     * @return
+     * @see java.lang.reflect.Method#getDeclaringClass()
+     */
+    public Class getDeclaringClass() {
+        return method.getDeclaringClass();
+    }
+
+    /**
+     * @return
+     * @see java.lang.reflect.Method#getExceptionTypes()
+     */
+    public Class[] getExceptionTypes() {
+        return method.getExceptionTypes();
+    }
+
+    /**
+     * @return
+     * @see java.lang.reflect.Method#getModifiers()
+     */
+    public int getModifiers() {
+        return method.getModifiers();
+    }
+
+    /**
+     * @return
+     * @see java.lang.reflect.Method#getName()
+     */
+    public String getName() {
+        return method.getName();
+    }
+
+    /**
+     * @return
+     * @see java.lang.reflect.Method#getParameterTypes()
+     */
+    public Class[] getParameterTypes() {
+        return method.getParameterTypes();
+    }
+
+    /**
+     * @return
+     * @see java.lang.reflect.Method#getReturnType()
+     */
+    public Class getReturnType() {
+        return method.getReturnType();
+    }
+
+    /**
+     * @param obj
+     * @param args
+     * @return
+     * @throws IllegalAccessException
+     * @throws IllegalArgumentException
+     * @throws InvocationTargetException
+     * @see java.lang.reflect.Method#invoke(java.lang.Object, java.lang.Object[])
+     */
+    public Object invoke(Object obj, Object[] args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
+        return method.invoke(obj, args);
+    }
+
+    /**
+     * @return
+     * @see java.lang.reflect.AccessibleObject#isAccessible()
+     */
+    public boolean isAccessible() {
+        return method.isAccessible();
+    }
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/sampler/SessionBeanSamplerBeanInfo.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/sampler/SessionBeanSamplerBeanInfo.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/sampler/SessionBeanSamplerBeanInfo.java	(revision 0)
@@ -0,0 +1,97 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb.sampler;
+
+import java.beans.PropertyDescriptor;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+
+import javax.ejb.EJBObject;
+
+import org.apache.jmeter.config.Argument;
+import org.apache.jmeter.protocol.ejb.ExcludeMethodSetFilter;
+import org.apache.jmeter.protocol.ejb.MethodParametersFactory;
+import org.apache.jmeter.protocol.ejb.MethodWrapperEditor;
+import org.apache.jmeter.testbeans.BeanInfoSupport;
+import org.apache.jmeter.testbeans.gui.TableEditor;
+import org.apache.jmeter.util.JMeterUtils;
+import org.apache.jorphan.logging.LoggingManager;
+import org.apache.jorphan.reflect.ClassFinder;
+import org.apache.log.Logger;
+
+/**
+ * @author glasnier
+ * 
+ */
+public class SessionBeanSamplerBeanInfo extends BeanInfoSupport {
+
+	private static final Logger log = LoggingManager.getLoggerForClass();
+
+	/**
+	 * @param beanClass
+	 */
+	public SessionBeanSamplerBeanInfo() {
+		super(SessionBeanSampler.class);
+
+		log.debug("initializing SessionBeanSampler...");
+
+		this.createPropertyGroup("ejb", new String[] { "sessionVarName",
+				"sessionMethod" });
+
+		this.createPropertyGroup("parameters", new String[] {
+				"sessionMethodParametersFactoryClassName", "arguments", "resultVarName" });
+
+		// EJB property group
+		PropertyDescriptor p = property("sessionVarName");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setValue(DEFAULT, "bean");
+
+		p = property("sessionMethod");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setValue(NOT_OTHER, Boolean.TRUE);
+		p.setValue(NOT_EXPRESSION, Boolean.TRUE);
+		p.setPropertyEditorClass(MethodWrapperEditor.class);
+		p.setValue(MethodWrapperEditor.BASE_CLASS, EJBObject.class);
+		p.setValue(MethodWrapperEditor.EXCLUDE_METHODS_FILTER,
+				new ExcludeMethodSetFilter(new HashSet(Arrays
+						.asList(EJBObject.class.getMethods()))));
+
+		// Parameters property group
+		p = property("sessionMethodParametersFactoryClassName");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		String possibleClasseNames[] = new String[0];
+		try {
+			List possibleClassesList = ClassFinder.findClassesThatExtend(
+					JMeterUtils.getSearchPaths(),
+					new Class[] { MethodParametersFactory.class }, false, true);
+			possibleClassesList.remove(MethodParametersFactory.class.getName());
+			possibleClasseNames = new String[possibleClassesList.size()];
+			possibleClassesList.toArray(possibleClasseNames);
+		} catch (IOException e) {
+			log.error("Error reading classes", e);
+		} catch (ClassNotFoundException e) {
+			log.error("Error loading classes", e);
+		}
+		p.setValue(NOT_OTHER, Boolean.FALSE);
+		p.setValue(TAGS, possibleClasseNames);
+		p.setValue(DEFAULT, possibleClasseNames.length == 0 ? ""
+				: possibleClasseNames[0]);
+
+		p = property("arguments");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setPropertyEditorClass(TableEditor.class);
+		p.setValue(TableEditor.CLASSNAME, Argument.class.getName());
+		p.setValue(TableEditor.OBJECT_PROPERTIES, new String[] { "name",
+				"value" });
+		p.setValue(TableEditor.HEADERS, new String[] { "Name", "Value" });
+		
+		p = property("resultVarName");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setValue(DEFAULT, "result");
+
+		log.debug("SessionBeanSampler initialized");
+	}
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/sampler/SessionBeanSamplerResources.properties
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/sampler/SessionBeanSamplerResources.properties	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/sampler/SessionBeanSamplerResources.properties	(revision 0)
@@ -0,0 +1,8 @@
+displayName=Session Bean Sampler
+ejb.displayName=Session Bean Definition
+sessionVarName.displayName=Session Bean Variable Name
+sessionMethod.displayName=Interface and Method
+parameters.displayName=Parameters Definition
+sessionMethodParametersFactoryClassName.displayName=Parameters Factory Class
+arguments.displayName=Arguments
+resultVarName.displayName=Returned Value Variable Name
\ No newline at end of file
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/sampler/SessionBeanSampler.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/sampler/SessionBeanSampler.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/sampler/SessionBeanSampler.java	(revision 0)
@@ -0,0 +1,272 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb.sampler;
+
+import java.awt.datatransfer.DataFlavor;
+import java.io.ByteArrayOutputStream;
+import java.io.ObjectOutputStream;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.lang.reflect.InvocationTargetException;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+import javax.ejb.EJBObject;
+
+import org.apache.jmeter.config.Argument;
+import org.apache.jmeter.protocol.ejb.EJBInvocationContext;
+import org.apache.jmeter.protocol.ejb.MethodParametersFactory;
+import org.apache.jmeter.protocol.ejb.MethodWrapper;
+import org.apache.jmeter.samplers.AbstractSampler;
+import org.apache.jmeter.samplers.Entry;
+import org.apache.jmeter.samplers.SampleResult;
+import org.apache.jmeter.testbeans.TestBean;
+import org.apache.jmeter.testelement.TestElement;
+import org.apache.jmeter.testelement.property.JMeterProperty;
+import org.apache.jorphan.logging.LoggingManager;
+import org.apache.log.Logger;
+
+/**
+ * A sampler for executing Sesssion Bean code in each sample.
+ * 
+ * @author glasnier
+ */
+public class SessionBeanSampler extends AbstractSampler implements TestBean {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 4693682443011233271L;
+
+    public static final String SESSION_BEAN = "SessionBeanSampler.sessionBean";
+
+    private static final Logger log = LoggingManager.getLoggerForClass();
+
+    private String sessionVarName = null;
+
+    private List arguments = null;
+
+    private MethodWrapper sessionMethod = null;
+
+    private String sessionMethodParametersFactoryClassName = null;
+
+    private String resultVarName = null;
+
+    private transient MethodParametersFactory sessionMethodParametersFactory = null;
+
+    /**
+     * Set used to register all active JavaSamplers. This is used so that the
+     * samplers can be notified when the test ends.
+     */
+    private static Set allSamplers = new HashSet();
+
+    /**
+     * 
+     */
+    public SessionBeanSampler() {
+        super();
+        this.arguments = new LinkedList();
+        synchronized (allSamplers) {
+            allSamplers.add(this);
+        }
+    }
+
+    /**
+     * @see org.apache.jmeter.testelement.AbstractTestElement#clone()
+     */
+    public Object clone() {
+        SessionBeanSampler clone = (SessionBeanSampler) super.clone();
+        
+        clone.arguments = EJBInvocationContext.cloneArguments(this.arguments);        
+        clone.resultVarName = this.resultVarName;
+        clone.sessionMethod = this.sessionMethod;
+        clone.sessionMethodParametersFactoryClassName = this.sessionMethodParametersFactoryClassName;
+        clone.sessionVarName = this.sessionVarName;
+        
+        return clone;
+    }
+
+    /**
+     * @see org.apache.jmeter.samplers.Sampler#sample(org.apache.jmeter.samplers.Entry)
+     */
+    public SampleResult sample(Entry entry) {
+        log.info("Entered sample");
+
+        SampleResult result = new SampleResult();
+        result.setSampleLabel(this.getName());
+
+        Object[] parameters = null;
+        EJBObject session = null;
+        Object response;
+
+        try {
+            // Initialize session method parameter factory
+            if (this.sessionMethodParametersFactory == null) {
+                Class createMethodParametersFactoryClass = Class.forName(this.sessionMethodParametersFactoryClassName);
+                this.sessionMethodParametersFactory = (MethodParametersFactory) createMethodParametersFactoryClass.newInstance();
+            }
+
+            // Create session bean method parameters
+            List args = this.getArguments();
+            JMeterProperty nameProperty = this.getProperty(TestElement.NAME);
+            args.add(new Argument(
+                nameProperty.getName(),
+                nameProperty.getStringValue()));
+            EJBInvocationContext ejbInvocationContext = new EJBInvocationContext(
+                this.getThreadContext(),
+                args);
+            parameters = this.sessionMethodParametersFactory.createParameters(ejbInvocationContext);
+
+            // Retrieve session bean
+            session = (EJBObject) this.getThreadContext()
+                .getVariables()
+                .getObject(this.sessionVarName);
+            log.debug("Retrieved session bean bound to: " + this.sessionVarName);
+        }
+        catch (Throwable t) {
+            log.error("Session bean pre-invocation error", t);
+            result.setSuccessful(false);
+            result.setResponseCode("400");
+            StringWriter writer = new StringWriter();
+            t.printStackTrace(new PrintWriter(writer));
+            result.setResponseMessage("Session bean pre-invocation error: " + t
+                + "\n" + writer.toString());
+            return result;
+        }
+
+        result.setSamplerData("" + parameters);
+
+        result.sampleStart();
+
+        try {
+            // Invoke method
+            response = this.sessionMethod.invoke(session, parameters);
+            result.sampleEnd();
+            log.debug("Session bean method invoked successuly");
+            this.getThreadContext().getVariables().putObject(
+                this.resultVarName,
+                response);
+            result.setSuccessful(true);
+            result.setResponseCode("200");
+            result.setResponseMessage("OK");
+        }
+        catch (Throwable t) {
+            result.sampleEnd();
+            log.error("Session bean invocation error", t);
+            result.setSuccessful(false);
+            result.setResponseCode("500");
+            if (t instanceof InvocationTargetException) {
+                InvocationTargetException ite = (InvocationTargetException) t;
+                t = ite.getTargetException();
+            }
+            StringWriter writer = new StringWriter();
+            t.printStackTrace(new PrintWriter(writer));
+            result.setResponseMessage("Session bean invocation error: " + t
+                + "\n" + writer.toString());
+
+            return result;
+        }
+
+        try {
+            ByteArrayOutputStream os = new ByteArrayOutputStream();
+            ObjectOutputStream objectOs = new ObjectOutputStream(os);
+            objectOs.writeObject(response);
+            result.setResponseData(os.toByteArray());
+            result.setDataType(SampleResult.BINARY);
+            result.setContentType(DataFlavor.javaSerializedObjectMimeType);
+        }
+        catch (Throwable t) {
+            log.error("Session bean post-invocation error", t);
+            result.setResponseCode("450");
+            StringWriter writer = new StringWriter();
+            t.printStackTrace(new PrintWriter(writer));
+            result.setResponseMessage("Session bean post-invocation error: "
+                + t + "\n" + writer.toString());
+        }
+
+        log.info("Exit sample");
+
+        return result;
+    }
+
+    /**
+     * @return Returns the sessionVarName.
+     */
+    public String getSessionVarName() {
+        return sessionVarName;
+    }
+
+    /**
+     * @param sessionVarName
+     *            The sessionVarName to set.
+     */
+    public void setSessionVarName(String homeVarName) {
+        this.sessionVarName = homeVarName;
+    }
+
+    /**
+     * @return Returns the arguments.
+     */
+    public List getArguments() {
+        return arguments;
+    }
+
+    /**
+     * @param arguments
+     *            The arguments to set.
+     */
+    public void setArguments(List arguments) {
+        this.arguments = arguments;
+    }
+
+    /**
+     * @return Returns the sessionMethod.
+     */
+    public MethodWrapper getSessionMethod() {
+        return sessionMethod;
+    }
+
+    /**
+     * @param sessionMethod
+     *            The sessionMethod to set.
+     */
+    public void setSessionMethod(MethodWrapper sessionMethod) {
+        this.sessionMethod = sessionMethod;
+    }
+
+    /**
+     * @return Returns the sessionMethodParametersFactoryClassName.
+     */
+    public String getSessionMethodParametersFactoryClassName() {
+        return sessionMethodParametersFactoryClassName;
+    }
+
+    /**
+     * @param sessionMethodParametersFactoryClassName
+     *            The sessionMethodParametersFactoryClassName to set.
+     */
+    public void setSessionMethodParametersFactoryClassName(
+        String sessionMethodParametersFactoryClassName) {
+        this.sessionMethodParametersFactoryClassName = sessionMethodParametersFactoryClassName;
+        this.sessionMethodParametersFactory = null;
+    }
+
+    /**
+     * @return Returns the resultVarName.
+     */
+    public String getResultVarName() {
+        return resultVarName;
+    }
+
+    /**
+     * @param resultVarName
+     *            The resultVarName to set.
+     */
+    public void setResultVarName(String resultVarName) {
+        this.resultVarName = resultVarName;
+    }
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/config/SessionBeanConfig.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/config/SessionBeanConfig.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/config/SessionBeanConfig.java	(revision 0)
@@ -0,0 +1,432 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb.config;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Properties;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import javax.ejb.EJBHome;
+import javax.ejb.EJBObject;
+import javax.naming.Context;
+import javax.naming.InitialContext;
+import javax.naming.NamingException;
+import javax.rmi.PortableRemoteObject;
+
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.jmeter.config.Argument;
+import org.apache.jmeter.config.ConfigTestElement;
+import org.apache.jmeter.engine.event.LoopIterationEvent;
+import org.apache.jmeter.engine.event.LoopIterationListener;
+import org.apache.jmeter.protocol.ejb.EJBInvocationContext;
+import org.apache.jmeter.protocol.ejb.MethodParametersFactory;
+import org.apache.jmeter.protocol.ejb.MethodWrapper;
+import org.apache.jmeter.testbeans.TestBean;
+import org.apache.jmeter.testelement.TestElement;
+import org.apache.jmeter.testelement.property.JMeterProperty;
+import org.apache.jorphan.logging.LoggingManager;
+import org.apache.log.Logger;
+
+/**
+ * @author glasnier
+ */
+public class SessionBeanConfig extends ConfigTestElement implements
+    LoopIterationListener, TestBean {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 3586036753841651122L;
+
+    public static final String VARIABLE_PATTERN = "\\$\\{(\\w*)\\}";
+
+    private static final Logger log = LoggingManager.getLoggerForClass();
+
+    private static final Pattern patttern = Pattern.compile(VARIABLE_PATTERN);
+
+    private String namingFactory = null;
+
+    private String serverUrl = null;
+
+    private String principal = null;
+
+    private String credentials = null;
+
+    private String jndiName = null;
+
+    private String homeVarName = null;
+
+    private String sessionVarName = null;
+
+    private boolean statefull = false;
+
+    private MethodWrapper createMethod = null;
+
+    private List createArguments = null;
+
+    private String createMethodParametersFactoryClassName = null;
+
+    private transient MethodParametersFactory createMethodParametersFactory = null;
+
+    /**
+     * 
+     */
+    public SessionBeanConfig() {
+        super();
+        this.createArguments = new LinkedList();
+    }
+
+    protected String replaceVariablesByValues(String value) {
+        if (value != null) {
+            StringBuffer buffer = new StringBuffer(value.length());
+
+            Matcher matcher = patttern.matcher(value);
+
+            int previousMatchIndex = 0;
+            while (matcher.find()) {
+                String varName = matcher.group(1);
+                buffer.append(value.substring(
+                    previousMatchIndex,
+                    matcher.start()));
+                buffer.append(this.getThreadContext().getVariables().get(
+                    varName));
+                previousMatchIndex = matcher.end();
+            }
+            if (previousMatchIndex < value.length())
+                buffer.append(value.substring(
+                    previousMatchIndex,
+                    value.length()));
+
+            if (buffer.length() > 0)
+                return buffer.toString();
+            else
+                return value;
+        } else
+            return null;
+    }
+
+    /**
+     * 
+     * @return
+     */
+    protected Properties createEnvironment() {
+        Properties environment = new Properties();
+
+        if (this.namingFactory != null && this.namingFactory.length() > 0)
+            environment.put(Context.INITIAL_CONTEXT_FACTORY, this.namingFactory);
+        if (this.serverUrl != null && this.serverUrl.length() > 0)
+            environment.put(Context.PROVIDER_URL, this.serverUrl);
+        if (this.principal != null && this.principal.length() > 0)
+            environment.put(Context.SECURITY_PRINCIPAL, this.principal);
+        if (this.credentials != null && this.credentials.length() > 0)
+            environment.put(Context.SECURITY_CREDENTIALS, this.credentials);
+
+        return environment;
+    }
+
+    /**
+     * 
+     * @return
+     * @throws NamingException
+     */
+    protected Context createInitialContext() throws NamingException {
+        Context initialContext = new InitialContext(this.createEnvironment());
+
+        return initialContext;
+    }
+
+    /**
+     * 
+     * @throws Exception
+     */
+    protected void createSessionBean() throws Exception {
+        log.info("Entered createSessionBean");
+
+        // Lookup Home
+        Context context = this.createInitialContext();
+        EJBHome home = (EJBHome) PortableRemoteObject.narrow(
+            context.lookup(this.jndiName),
+            this.createMethod.getDeclaringClass());
+        context.close();
+        this.getThreadContext()
+            .getVariables()
+            .putObject(this.homeVarName, home);
+        log.debug("Home bound to variable: " + this.homeVarName);
+
+        // Create method parameter factory
+        if (this.createMethodParametersFactory == null) {
+            Class createMethodParametersFactoryClass = Class.forName(this.createMethodParametersFactoryClassName);
+            this.createMethodParametersFactory = (MethodParametersFactory) createMethodParametersFactoryClass.newInstance();
+        }
+
+        // Build create method parameters
+        List args = this.getCreateArguments();
+        JMeterProperty nameProperty = this.getProperty(TestElement.NAME);
+        args.add(new Argument(
+            nameProperty.getName(),
+            nameProperty.getStringValue()));
+        EJBInvocationContext ejbInvocationContext = new EJBInvocationContext(
+            this.getThreadContext(),
+            args);
+        Object[] parameters = this.createMethodParametersFactory.createParameters(ejbInvocationContext);
+
+        // Create Session Bean
+        EJBObject sessionBean = (EJBObject) createMethod.invoke(
+            home,
+            parameters);
+
+        this.getThreadContext().getVariables().putObject(
+            this.sessionVarName,
+            sessionBean);
+        log.debug("Session bean bound to variable: " + this.sessionVarName);
+
+        log.info("Exit createSessionBean");
+    }
+
+    /**
+     * 
+     * @throws Exception
+     */
+    protected void removeSessionBean() throws Exception {
+        log.info("Entered removeSessionBean");
+
+        EJBObject sessionBean = (EJBObject) this.getThreadContext()
+            .getVariables()
+            .getObject(this.sessionVarName);
+        if (sessionBean != null) {
+            sessionBean.remove();
+            this.getThreadContext().getVariables().remove(this.sessionVarName);
+            log.debug("Session bean variable unboud");
+        }
+        this.getThreadContext().getVariables().remove(this.homeVarName);
+        log.debug("Home variable unboud");
+
+        log.info("Exit removeSessionBean");
+    }
+
+    /**
+     * @see org.apache.jmeter.testelement.AbstractTestElement#clone()
+     */
+    public Object clone() {
+        SessionBeanConfig clone = (SessionBeanConfig) super.clone();
+
+        clone.createArguments = EJBInvocationContext.cloneArguments(this.createArguments);
+        clone.createMethod = this.createMethod;
+        clone.createMethodParametersFactoryClassName = this.createMethodParametersFactoryClassName;
+        clone.credentials = this.credentials;
+        clone.homeVarName = this.homeVarName;
+        clone.jndiName = this.jndiName;
+        clone.namingFactory = this.namingFactory;
+        clone.principal = this.principal;
+        clone.serverUrl = this.serverUrl;
+        clone.sessionVarName = this.sessionVarName;
+        clone.statefull = this.statefull;
+
+        return clone;
+    }
+
+    /**
+     * @return Returns the credentials.
+     */
+    public String getCredentials() {
+        return credentials;
+    }
+
+    /**
+     * @param credentials
+     *            The credentials to set.
+     */
+    public void setCredentials(String credentials) {
+        this.credentials = credentials;
+    }
+
+    /**
+     * @return Returns the namingFactory.
+     */
+    public String getNamingFactory() {
+        return namingFactory;
+    }
+
+    /**
+     * @param namingFactory
+     *            The namingFactory to set.
+     */
+    public void setNamingFactory(String namingFactory) {
+        this.namingFactory = namingFactory;
+    }
+
+    /**
+     * @return Returns the principal.
+     */
+    public String getPrincipal() {
+        return principal;
+    }
+
+    /**
+     * @param principal
+     *            The principal to set.
+     */
+    public void setPrincipal(String principal) {
+        this.principal = principal;
+    }
+
+    /**
+     * @return Returns the serverUrl.
+     */
+    public String getServerUrl() {
+        return serverUrl;
+    }
+
+    /**
+     * @param serverUrl
+     *            The serverUrl to set.
+     */
+    public void setServerUrl(String serverUrl) {
+        this.serverUrl = serverUrl;
+    }
+
+    /**
+     * @return Returns the jndiName.
+     */
+    public String getJndiName() {
+        return jndiName;
+    }
+
+    /**
+     * @param jndiName
+     *            The jndiName to set.
+     */
+    public void setJndiName(String jndiName) {
+        this.jndiName = jndiName;
+    }
+
+    /**
+     * @return Returns the homeVarName.
+     */
+    public String getHomeVarName() {
+        return homeVarName;
+    }
+
+    /**
+     * @param homeVarName
+     *            The homeVarName to set.
+     */
+    public void setHomeVarName(String homeVarName) {
+        this.homeVarName = homeVarName;
+    }
+
+    /**
+     * @return Returns the createMethodParametersFactoryClassName.
+     */
+    public String getCreateMethodParametersFactoryClassName() {
+        return createMethodParametersFactoryClassName;
+    }
+
+    /**
+     * @param createMethodParametersFactoryClassName
+     *            The createMethodParametersFactoryClassName to set.
+     */
+    public void setCreateMethodParametersFactoryClassName(
+        String createMethodParametersFactoryClassName) {
+        this.createMethodParametersFactoryClassName = createMethodParametersFactoryClassName;
+        this.createMethodParametersFactory = null;
+    }
+
+    /**
+     * @return Returns the createArguments.
+     */
+    public List getCreateArguments() {
+        return createArguments;
+    }
+
+    /**
+     * @param createArguments
+     *            The createArguments to set.
+     */
+    public void setCreateArguments(List createArguments) {
+        this.createArguments = createArguments;
+    }
+
+    /**
+     * @return Returns the sessionVarName.
+     */
+    public String getSessionVarName() {
+        return sessionVarName;
+    }
+
+    /**
+     * @param sessionVarName
+     *            The sessionVarName to set.
+     */
+    public void setSessionVarName(String sessionVarName) {
+        this.sessionVarName = sessionVarName;
+    }
+
+    /**
+     * @return Returns the statefull.
+     */
+    public boolean isStatefull() {
+        return statefull;
+    }
+
+    /**
+     * @param statefull
+     *            The statefull to set.
+     */
+    public void setStatefull(boolean statefull) {
+        this.statefull = statefull;
+    }
+
+    /**
+     * @return Returns the createMethod.
+     */
+    public MethodWrapper getCreateMethod() {
+        return createMethod;
+    }
+
+    /**
+     * @param createMethod
+     *            The createMethod to set.
+     */
+    public void setCreateMethod(MethodWrapper createMethod) {
+        this.createMethod = createMethod;
+    }
+
+    /**
+     * @see org.apache.jmeter.engine.event.LoopIterationListener#iterationEnd(org.apache.jmeter.engine.event.LoopIterationEvent)
+     */
+    public void iterationEnd(LoopIterationEvent iterEvent) {
+        log.debug(this + ".iterationEnd( " + iterEvent + " )");
+        try {
+            this.removeSessionBean();
+        } catch (Exception e) {
+            log.error("Error cleaning up", e);
+            this.getThreadContext().getThread().stop();
+        }
+    }
+
+    /**
+     * @see org.apache.jmeter.engine.event.LoopIterationListener#iterationStart(org.apache.jmeter.engine.event.LoopIterationEvent)
+     */
+    public void iterationStart(LoopIterationEvent iterEvent) {
+        log.debug(this + ".iterationStart( " + iterEvent + " )");
+
+        // Replace variables between ${}
+        this.principal = this.replaceVariablesByValues(this.principal);
+        this.credentials = this.replaceVariablesByValues(this.credentials);
+        this.serverUrl = this.replaceVariablesByValues(this.serverUrl);
+
+        try {
+            this.createSessionBean();
+        } catch (Exception e) {
+            log.error("Error configuring", e);
+            this.getThreadContext().getThread().stop();
+        }
+    }
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/config/SessionBeanConfigBeanInfo.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/config/SessionBeanConfigBeanInfo.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/config/SessionBeanConfigBeanInfo.java	(revision 0)
@@ -0,0 +1,139 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb.config;
+
+import java.beans.PropertyDescriptor;
+import java.io.IOException;
+import java.util.List;
+
+import javax.ejb.EJBHome;
+import javax.naming.spi.InitialContextFactory;
+
+import org.apache.jmeter.config.Argument;
+import org.apache.jmeter.protocol.ejb.MethodNameFilter;
+import org.apache.jmeter.protocol.ejb.MethodParametersFactory;
+import org.apache.jmeter.protocol.ejb.MethodWrapperEditor;
+import org.apache.jmeter.testbeans.BeanInfoSupport;
+import org.apache.jmeter.testbeans.gui.TableEditor;
+import org.apache.jmeter.util.JMeterUtils;
+import org.apache.jorphan.logging.LoggingManager;
+import org.apache.jorphan.reflect.ClassFinder;
+import org.apache.log.Logger;
+
+/**
+ * @author glasnier
+ */
+public class SessionBeanConfigBeanInfo extends BeanInfoSupport {
+
+	private static final Logger log = LoggingManager.getLoggerForClass();
+
+	/**
+	 * @param beanClass
+	 */
+	public SessionBeanConfigBeanInfo() {
+		super(SessionBeanConfig.class);
+
+		log.debug("initializing SessionBeanConfig...");
+
+		// JNDI property group
+		this.createPropertyGroup("jndi", new String[] { "namingFactory",
+				"serverUrl", "principal", "credentials" });
+
+		// EJB property group
+		this.createPropertyGroup("ejb", new String[] { "jndiName",
+				"createMethod", "statefull", "homeVarName", "sessionVarName" });
+
+		this.createPropertyGroup("parameters", new String[] {
+				"createMethodParametersFactoryClassName", "createArguments" });
+
+		// JNDI properties definition
+		PropertyDescriptor p = property("namingFactory");
+		String possibleClasseNames[] = new String[0];
+		try {
+			List possibleClassesList = ClassFinder.findClassesThatExtend(
+					JMeterUtils.getSearchPaths(),
+					new Class[] { InitialContextFactory.class }, false, true);
+			possibleClassesList.remove(InitialContextFactory.class.getName());
+			possibleClasseNames = new String[possibleClassesList.size()];
+			possibleClassesList.toArray(possibleClasseNames);
+		} catch (IOException e) {
+			log.error("Error reading classes", e);
+		} catch (ClassNotFoundException e) {
+			log.error("Error loading classes", e);
+		}
+		p.setValue(NOT_OTHER, Boolean.FALSE);
+		p.setValue(TAGS, possibleClasseNames);
+		p.setValue(DEFAULT, possibleClasseNames.length == 0 ? ""
+				: possibleClasseNames[0]);
+		p.setValue(NOT_UNDEFINED, Boolean.FALSE);
+
+		p = property("serverUrl");
+		p.setValue(NOT_UNDEFINED, Boolean.FALSE);
+
+		p = property("principal");
+		p.setValue(NOT_UNDEFINED, Boolean.FALSE);
+
+		p = property("credentials");
+		p.setValue(NOT_UNDEFINED, Boolean.FALSE);
+
+		// EJB properties definition
+		p = property("jndiName");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setValue(DEFAULT, "ejb.home");
+
+		p = property("createMethod");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setValue(NOT_OTHER, Boolean.TRUE);
+		p.setValue(NOT_EXPRESSION, Boolean.TRUE);
+		p.setPropertyEditorClass(MethodWrapperEditor.class);
+		p.setValue(MethodWrapperEditor.BASE_CLASS, EJBHome.class);
+		p.setValue(MethodWrapperEditor.EXCLUDE_METHODS_FILTER,
+				new MethodNameFilter("create"));
+
+		p = property("statefull");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setValue(NOT_OTHER, Boolean.TRUE);
+		p.setValue(NOT_EXPRESSION, Boolean.TRUE);
+		p.setValue(DEFAULT, Boolean.FALSE);
+		
+		p = property("homeVarName");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setValue(DEFAULT, "home");
+
+		p = property("sessionVarName");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setValue(DEFAULT, "bean");
+
+		p = property("createMethodParametersFactoryClassName");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		possibleClasseNames = new String[0];
+		try {
+			List possibleClassesList = ClassFinder.findClassesThatExtend(
+					JMeterUtils.getSearchPaths(),
+					new Class[] { MethodParametersFactory.class }, false, true);
+			possibleClassesList.remove(MethodParametersFactory.class.getName());
+			possibleClasseNames = new String[possibleClassesList.size()];
+			possibleClassesList.toArray(possibleClasseNames);
+		} catch (IOException e) {
+			log.error("Error reading classes", e);
+		} catch (ClassNotFoundException e) {
+			log.error("Error loading classes", e);
+		}
+		p.setValue(NOT_OTHER, Boolean.FALSE);
+		p.setValue(TAGS, possibleClasseNames);
+		p.setValue(DEFAULT, possibleClasseNames.length == 0 ? ""
+				: possibleClasseNames[0]);
+
+		p = property("createArguments");
+		p.setValue(NOT_UNDEFINED, Boolean.TRUE);
+		p.setPropertyEditorClass(TableEditor.class);
+		p.setValue(TableEditor.CLASSNAME, Argument.class.getName());
+		p.setValue(TableEditor.OBJECT_PROPERTIES, new String[] { "name",
+				"value" });
+		p.setValue(TableEditor.HEADERS, new String[] { "Name", "Value" });
+
+
+		log.debug("SessionBeanConfig initialized");
+	}
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/config/SessionBeanConfigResources.properties
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/config/SessionBeanConfigResources.properties	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/config/SessionBeanConfigResources.properties	(revision 0)
@@ -0,0 +1,15 @@
+displayName=Session Bean Configuration
+jndi.displayName=JNDI Connection Properties
+namingFactory.displayName=Naming Factory
+serverUrl.displayName=Server URL
+principal.displayName=Principal
+credentials.displayName=Credentials
+ejb.displayName=Session Home Definition
+jndiName.displayName=JNDI Name
+createMethod.displayName=Home Interface and Method
+statefull.displayName= Statefull
+homeVarName.displayName=Home Variable Name
+sessionVarName.displayName=Session Bean Variable Name
+parameters.displayName=Create Parameters Definition
+createMethodParametersFactoryClassName.displayName=Parameters Factory Class
+createArguments.displayName=Create Arguments
\ No newline at end of file
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodFilter.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodFilter.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodFilter.java	(revision 0)
@@ -0,0 +1,21 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.lang.reflect.Method;
+
+/**
+ * @author glasnier
+ * 
+ */
+public interface MethodFilter {
+
+	/**
+	 * 
+	 * @param method
+	 * @return
+	 */
+	public abstract boolean accept(Method method);
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodNameFilter.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodNameFilter.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodNameFilter.java	(revision 0)
@@ -0,0 +1,36 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.lang.reflect.Method;
+
+/**
+ * @author glasnier
+ *
+ */
+public class MethodNameFilter implements MethodFilter {
+	
+	private String methodName = null;
+
+	
+	/**
+	 * @param methodName
+	 */
+	public MethodNameFilter(String methodName) {
+		super();
+		this.methodName = methodName;
+	}
+
+
+	/**
+	 * @see org.apache.jmeter.protocol.ejb.MethodFilter#accept(java.lang.reflect.Method)
+	 */
+	public boolean accept(Method method) {
+		if (method.getName().equals(this.methodName))
+			return true;
+		else
+			return false;
+	}
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/EmptyMethodParameterFactory.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/EmptyMethodParameterFactory.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/EmptyMethodParameterFactory.java	(revision 0)
@@ -0,0 +1,26 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+/**
+ * @author glasnier
+ *
+ */
+public class EmptyMethodParameterFactory implements MethodParametersFactory {
+	
+	/**
+	 * 
+	 */
+	public EmptyMethodParameterFactory() {
+		super();
+	}
+
+	/**
+	 * @see org.apache.jmeter.protocol.ejb.MethodParametersFactory#createParameters(org.apache.jmeter.protocol.ejb.EJBInvocationContext)
+	 */
+	public Object[] createParameters(EJBInvocationContext ejbInvocationContext) {
+		return null;
+	}
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodWrapperEditor.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodWrapperEditor.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodWrapperEditor.java	(revision 0)
@@ -0,0 +1,216 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.awt.Component;
+import java.awt.event.ItemEvent;
+import java.awt.event.ItemListener;
+import java.beans.PropertyDescriptor;
+import java.beans.PropertyEditorSupport;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.ListIterator;
+
+import javax.swing.BoxLayout;
+import javax.swing.DefaultComboBoxModel;
+import javax.swing.JComboBox;
+import javax.swing.JPanel;
+
+import org.apache.commons.collections.CollectionUtils;
+import org.apache.commons.collections.Transformer;
+import org.apache.jmeter.testbeans.gui.TestBeanPropertyEditor;
+import org.apache.jmeter.util.JMeterUtils;
+import org.apache.jorphan.logging.LoggingManager;
+import org.apache.jorphan.reflect.ClassFinder;
+import org.apache.log.Logger;
+
+/**
+ * @author glasnier
+ */
+public class MethodWrapperEditor extends PropertyEditorSupport implements
+    ItemListener, TestBeanPropertyEditor {
+
+    private static final Logger log = LoggingManager.getLoggerForClass();
+
+    private static MethodComparator methodComparator = new MethodComparator();
+
+    private static ClassNameComparator classNameComparator = new ClassNameComparator();
+
+    public static final String BASE_CLASS = "MethodWrapperEditor.baseClass";
+
+    public static final String EXCLUDE_METHODS_FILTER = "MethodWrapperEditor.excludeMethodsFilter";
+
+    private PropertyDescriptor descriptor;
+
+    private JPanel panel = null;
+
+    private DefaultComboBoxModel classModel = null;
+
+    private DefaultComboBoxModel methodModel = null;
+
+    private JComboBox classCombo = null;
+
+    private JComboBox methodCombo = null;
+
+    /**
+     * 
+     */
+    public MethodWrapperEditor() {
+        super();
+
+        this.init();
+    }
+
+    /**
+     * 
+     */
+    private void init() {
+        this.panel = new JPanel();
+        this.panel.setLayout(new BoxLayout(this.panel, BoxLayout.Y_AXIS));
+
+        this.classModel = new DefaultComboBoxModel();
+        this.classCombo = new JComboBox(this.classModel);
+        this.classCombo.setRenderer(new ClassCellRenderer());
+        this.panel.add(this.classCombo);
+
+        this.methodModel = new DefaultComboBoxModel();
+        this.methodCombo = new JComboBox(this.methodModel);
+        this.methodCombo.setRenderer(new MethodWrapperCellRenderer());
+        this.panel.add(this.methodCombo);
+
+        this.classCombo.addItemListener(this);
+        this.methodCombo.addItemListener(this);
+    }
+
+    /**
+     * @return
+     */
+    private Class getSelectedClass() {
+        return (Class) this.classModel.getSelectedItem();
+    }
+
+    /**
+     * @see java.beans.PropertyEditorSupport#getCustomEditor()
+     */
+    public Component getCustomEditor() {
+        return this.panel;
+    }
+
+    /**
+     * @see java.beans.PropertyEditorSupport#getValue()
+     */
+    public Object getValue() {
+        return this.methodModel.getSelectedItem();
+    }
+
+    /**
+     * 
+     */
+    public void setValue(Object value) {
+        if ((value != null && !value.equals(this.getValue()))
+            || (value == null && this.getValue() != null)) {
+            if (value == null) {
+                this.classModel.setSelectedItem(null);
+                this.methodModel.setSelectedItem(null);
+            } else if (value instanceof MethodWrapper) {
+                MethodWrapper methodWrapper = (MethodWrapper) value;
+                Class declaringClass = methodWrapper.getDeclaringClass();
+                if (this.getSelectedClass() == null
+                    || !declaringClass.isAssignableFrom(this.getSelectedClass()))
+                    this.classModel.setSelectedItem(declaringClass);
+                this.methodModel.setSelectedItem(methodWrapper);
+            } else
+                throw new ClassCastException("Could not edit value of type: "
+                    + value.getClass());
+        }
+
+        this.firePropertyChange();
+        log.debug("value changed: " + value);
+    }
+
+    /**
+     * @see org.apache.jmeter.testbeans.gui.TestBeanPropertyEditor#setDescriptor(java.beans.PropertyDescriptor)
+     */
+    public void setDescriptor(PropertyDescriptor descriptor) {
+        this.descriptor = descriptor;
+        Class baseClass = (Class) this.descriptor.getValue(BASE_CLASS);
+        List possibleClassesList = Collections.EMPTY_LIST;
+        try {
+            possibleClassesList = ClassFinder.findClassesThatExtend(
+                JMeterUtils.getSearchPaths(),
+                new Class[] { baseClass },
+                false,
+                true);
+            possibleClassesList.remove(baseClass.getName());
+            CollectionUtils.transform(possibleClassesList, new Transformer() {
+
+                public Object transform(Object input) {
+                    try {
+                        return Class.forName((String) input);
+                    } catch (ClassNotFoundException e) {
+                        throw new RuntimeException(e);
+                    }
+                }
+
+            });
+        } catch (Throwable e) {
+            log.error("Error reading classes", e);
+        }
+        Collections.sort(possibleClassesList, classNameComparator);
+        this.classModel.removeAllElements();
+        for (Iterator iter = possibleClassesList.iterator(); iter.hasNext();) {
+            Class sessionClass = (Class) iter.next();
+            this.classModel.addElement(sessionClass);
+        }
+        if (this.classModel.getSize() > 0)
+            this.classModel.setSelectedItem(this.classModel.getElementAt(0));
+    }
+
+    /**
+     * @see java.beans.PropertyEditor#supportsCustomEditor()
+     */
+    public boolean supportsCustomEditor() {
+        return true;
+    }
+
+    /**
+     * @see java.awt.event.ItemListener#itemStateChanged(java.awt.event.ItemEvent)
+     */
+    public void itemStateChanged(ItemEvent e) {
+        if (e.getSource() == this.classCombo
+            && e.getStateChange() == ItemEvent.SELECTED) {
+            this.methodModel.removeAllElements();
+            List methods = new LinkedList(Arrays.asList(this.getSelectedClass()
+                .getMethods()));
+            MethodFilter methodFilter = (MethodFilter) this.descriptor.getValue(EXCLUDE_METHODS_FILTER);
+            for (ListIterator iter = methods.listIterator(); iter.hasNext();) {
+                Method method = (Method) iter.next();
+                if (methodFilter != null && !methodFilter.accept(method))
+                    iter.remove();
+            }
+            Collections.sort(methods, methodComparator);
+            CollectionUtils.transform(methods, new Transformer() {
+
+                public Object transform(Object input) {
+                    Method method = (Method) input;
+                    return new MethodWrapper(method);
+                }
+
+            });
+            for (Iterator iter = methods.iterator(); iter.hasNext();) {
+                MethodWrapper method = (MethodWrapper) iter.next();
+                this.methodModel.addElement(method);
+            }
+            if (this.methodModel.getSize() > 0)
+                this.setValue(this.methodModel.getElementAt(0));
+        } else if (e.getSource() == this.methodCombo
+            && e.getStateChange() == ItemEvent.SELECTED)
+            this.setValue(e.getItem());
+    }
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/ClassCellRenderer.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/ClassCellRenderer.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/ClassCellRenderer.java	(revision 0)
@@ -0,0 +1,52 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.awt.Component;
+
+import javax.swing.JList;
+import javax.swing.plaf.basic.BasicComboBoxRenderer;
+
+/**
+ * @author glasnier
+ * 
+ */
+public class ClassCellRenderer extends BasicComboBoxRenderer {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = -7296796668610989027L;
+
+    /**
+     * 
+     */
+    public ClassCellRenderer() {
+        super();
+    }
+
+    /**
+     * @see javax.swing.plaf.basic.BasicComboBoxRenderer#getListCellRendererComponent(javax.swing.JList,
+     *      java.lang.Object, int, boolean, boolean)
+     */
+    public Component getListCellRendererComponent(JList list, Object value,
+        int index, boolean isSelected, boolean cellHasFocus) {
+        if (value != null && !(value instanceof Class)) {
+            throw new ClassCastException("Unsupported type: "
+                + value.getClass());
+        }
+
+        if (value != null) {
+            Class valueClass = (Class) value;
+            value = valueClass.getName();
+        }
+
+        return super.getListCellRendererComponent(
+            list,
+            value,
+            index,
+            isSelected,
+            cellHasFocus);
+    }
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodParametersFactory.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodParametersFactory.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/MethodParametersFactory.java	(revision 0)
@@ -0,0 +1,20 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+/**
+ * @author glasnier
+ * 
+ */
+public interface MethodParametersFactory {
+
+	/**
+	 * 
+	 * @param ejbInvocationContext
+	 * @return
+	 */
+	public abstract Object[] createParameters(
+			EJBInvocationContext ejbInvocationContext);
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/ClassNameComparator.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/ClassNameComparator.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/ejb/org/apache/jmeter/protocol/ejb/ClassNameComparator.java	(revision 0)
@@ -0,0 +1,32 @@
+/**
+ * 
+ */
+package org.apache.jmeter.protocol.ejb;
+
+import java.util.Comparator;
+
+
+/**
+ * @author glasnier
+ *
+ */
+public class ClassNameComparator implements Comparator {
+
+    /**
+     * 
+     */
+    public ClassNameComparator() {
+        super();
+    }
+
+    /**
+     * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
+     */
+    public int compare(Object o1, Object o2) {
+        Class c1 = (Class) o1;
+        Class c2 = (Class) o2;
+        
+        return c1.getName().compareTo(c2.getName());
+    }
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/control/gui/JndiTestSampleGui.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/control/gui/JndiTestSampleGui.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/control/gui/JndiTestSampleGui.java	(working copy)
@@ -1,86 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.control.gui;
-
-
-import javax.swing.border.Border;
-import javax.swing.border.EmptyBorder;
-import javax.swing.JLabel;
-import javax.swing.JPanel;
-
-import org.apache.jmeter.ejb.jndi.config.JndiConfig;
-import org.apache.jmeter.ejb.jndi.config.gui.JndiConfigGui;
-import org.apache.jmeter.ejb.jndi.control.JndiTestSample;
-import org.apache.jmeter.gui.ModelSupported;
-import org.apache.jmeter.gui.NamePanel;
-import org.apache.jmeter.gui.VerticalLayout;
-import org.apache.jmeter.util.JMeterUtils;
-
-/**
- * Provides the gui to configure JNDI sampling
- *
- * @author	Khor Soon Hin
- * Created	20 Dec 2001
- * @version $Revision$ Last Updated: $Date$
- */
-public class JndiTestSampleGui extends JPanel implements ModelSupported
-{
-  JndiTestSample model;
-  NamePanel namePanel;
-
-  JndiConfigGui jndiConfigGui;
-
-  public JndiTestSampleGui()
-  {
-  }
-
-  public void updateGui()
-  {
-    namePanel.updateGui();
-    jndiConfigGui.updateGui();
-  }
-
-  public void setModel(Object model)
-  {
-    this.model = (JndiTestSample)model;
-    init();
-  }
-
-  protected void init()
-  {
-    this.setLayout(new VerticalLayout(5, VerticalLayout.LEFT, 
-	VerticalLayout.TOP));
-    
-    // main panel
-    JPanel mainPanel = new JPanel();
-    Border margin = new EmptyBorder(10, 10, 5, 10);
-    mainPanel.setBorder(margin);
-    mainPanel.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-
- 
-    mainPanel.add(makeTitlePanel());
-
-    // jndi
-    jndiConfigGui = new JndiConfigGui(false);
-    jndiConfigGui.setModel(model.getDefaultJndiConfig());
-    mainPanel.add(jndiConfigGui);
-
-    this.add(mainPanel);
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/control/JndiTestSample.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/control/JndiTestSample.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/control/JndiTestSample.java	(working copy)
@@ -1,124 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.control;
-
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.Set;
-
-import org.apache.jmeter.control.AbstractGenerativeController;
-import org.apache.jmeter.ejb.jndi.config.JndiConfig;
-import org.apache.jmeter.ejb.jndi.config.LookupConfig;
-import org.apache.jmeter.ejb.jndi.config.MethodConfig;
-import org.apache.jmeter.ejb.jndi.control.gui.JndiTestSampleGui;
-import org.apache.jmeter.ejb.jndi.sampler.JNDISampler;
-import org.apache.jmeter.samplers.Entry;
-import org.apache.jmeter.util.JMeterUtils;
-import org.apache.log4j.Category;
-/**
- * Controls how the sampling is done
- *
- * @author	Khor Soon Hin
- * Created	20 Dec 2001
- * @version $Revision$ Last Updated: $Date$
- */
-public class JndiTestSample extends AbstractGenerativeController 
-	implements Serializable
-{
-  private static Category catClass = Category.getInstance(
-	JndiTestSample.class.getName());
-
-  protected JndiConfig defaultJndiConfig;
-
-  protected static Set addableList;
-
-  public JndiTestSample()
-  {
-    defaultJndiConfig = new JndiConfig();
-  }
-
-  public JndiConfig getDefaultJndiConfig()
-  {
-    return defaultJndiConfig;
-  }
-
-  public void setDefaultJndiConfig(JndiConfig config)
-  {
-    defaultJndiConfig = config;
-  }
-
-  public void uncompile()
-  {
-    super.uncompile();
-  }
-
-  public String getClassLabel()
-  {
-    return JMeterUtils.getResString("jndi_testing_title");
-  }
-
-  public Class getGuiClass()
-  {
-    return org.apache.jmeter.ejb.jndi.control.gui.JndiTestSampleGui.class;
-  }
-
-  public Class getTagHandlerClass()
-  {
-    return org.apache.jmeter.ejb.jndi.save.JndiTestSampleHandler.class;
-  }
-
-  /**
-   * Returns a <code>Collaction</code> containing a list of all 
-   * elements which can be added to this element
-   *
-   * @return	a collection of elements
-   */
-  public Collection getAddList()
-  {
-    if(addableList == null)
-    {
-      addableList = new HashSet();
-      addableList.add(new LookupConfig().getClassLabel());
-      addableList.add(new MethodConfig().getClassLabel());
-    }
-    return addableList;
-  }
-
-  public Object clone()
-  {
-    catClass.info("Start : clone1");
-    JndiTestSample control = new JndiTestSample();
-    control.setDefaultJndiConfig(defaultJndiConfig);
-    this.standardCloneProc(control);
-    catClass.info("End : clone1");
-    return control;
-  }
-
-  protected Entry createEntry()
-  {
-    catClass.info("Start : createEntry1");
-    Entry entry = new Entry();
-    entry.setSamplerClass(JNDISampler.class);
-    entry.addConfigElement(defaultJndiConfig);
-    catClass.info("End : createEntry1");
-    return entry;
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/sampler/JNDISampler.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/sampler/JNDISampler.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/sampler/JNDISampler.java	(working copy)
@@ -1,519 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.sampler;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Hashtable;
-import java.util.Map;
-import java.util.Vector;
-
-import javax.naming.InitialContext;
-import javax.naming.NamingException;
-
-import org.apache.jmeter.samplers.Entry;
-import org.apache.jmeter.samplers.SampleResult;
-import org.apache.jmeter.samplers.Sampler;
-import org.apache.jorphan.logging.LoggingManager;
-import org.apache.log.Logger;
-/**
- * Samples the JNDI performance and records them
- *
- * @author	Khor Soon Hin
- * Created	2001 Dec 18
- * @version $Revision$ Last Updated: $Date$
- */
-public class JNDISampler implements Sampler
-{
-  transient private static Logger log = LoggingManager.getLoggerForClass();
-
-  public static final String QUERY = "JNDISampler.query";
-
-  protected static Map keyMap = new HashMap();
-
-  public JNDISampler()
-  {
-  }
-
-  /**
-   * The main method which samples and records the JNDI performance
-   *
-   * @param e	the JNDI sampling configuration
-   * @return	the measurements captured
-   */
-  public SampleResult sample(Entry e)
-  {
-    log.info("Start : sample1");
-    boolean reflectionStatus = false;
-    // There is a row of ifs condition which may be executed depending on the
-    // state of the MethodConfig state.  During reflection only one of these
-    // condition should be become true.  However, once one condition becomes
-    // true it will set the MethodConfig state and this will cause the next 
-    // condition to become true and so on.  Thus else-ifs should be used BUT
-    // these same conditions need to be used such that more than one condition
-    // can be true during sampling so ifs and NOT else-ifs must be used.  To 
-    // resolve this conflict, ifs are used with stateJustChange is used to act 
-    // like else-if 
-    boolean stateJustChanged = false;
-    long start = (long)0;
-    long end = (long)0;
-    long ctxTime = (long)0;
-    long lookupTime = (long)0;
-    long homeMethodTime = (long)0;
-    long remoteMethodTime = (long)0;
-
-    Object remoteInterface = null;
-    Object results = null;
-    Object ref = null;
-    
-    SampleResult res = new SampleResult();
-    SampleResult contextLookupRes = new SampleResult();
-    contextLookupRes.putValue(SampleResult.DISPLAY_NAME, "Context Lookup");
-    SampleResult lookupRes = new SampleResult();
-    SampleResult homeMethodRes = null;
-    SampleResult remoteMethodRes = null;
-    Hashtable ht = new Hashtable();
-    JndiConfig jndiConfig = null;
-    InitialContext ctx = null;
-    try
-    {
-      jndiConfig = (JndiConfig)e.getConfigElement(JndiConfig.class);
-      // check if InitialContext is already obtained previously
-      ctx = jndiConfig.getInitialContext();
-      if(ctx == null)
-      {
-        // setup the hashtable
-        for(int i = 0 ; i < JndiConfig.JNDI_PROPS.length; i++)
-        {
-          String value = jndiConfig.getValue(i);
-          if(value != null)
-          {
-            if(log.isDebugEnabled())
-            {
-              log.debug("sample1 : JNDI env - " + 
-		JndiConfig.JNDI_PROPS[i] + " = " + value);
-            }
-            ht.put(JndiConfig.JNDI_PROPS[i], value);
-          }
-        }
-        // initialize initial context
-        start = System.currentTimeMillis();
-        ctx = new InitialContext(ht);
-        end = System.currentTimeMillis();
-        log.info("sample1 : Got initial context");
-        // store the initial context for reuse
-        jndiConfig.setInitialContext(ctx);
-      }
-      // set the initial context lookup time
-      ctxTime = end - start;
-      contextLookupRes.setTime(ctxTime);
-
-      // look up the name
-      LookupConfig lookupConfig = 
-		(LookupConfig)e.getConfigElement(LookupConfig.class);
-      String lookupName = null;
-      if(lookupConfig != null)
-      {
-        lookupName = lookupConfig.getLookupName();
-        if(log.isDebugEnabled())
-        {
-          log.debug("sample1 : LookupName - " + lookupName);
-        }
-        start = System.currentTimeMillis();
-        ref = ctx.lookup(lookupName);
-        end = System.currentTimeMillis();
-        lookupTime = end - start;
-        log.info("Got remote interface");
-        lookupRes.setTime(lookupTime);
-        lookupRes.putValue(SampleResult.DISPLAY_NAME, 
-		"Remote Interface Lookup - " + lookupName);
-      }
-      Class lookupNameClass = ref.getClass();
- 
-      // lookup method name
-      MethodConfig methodConfig = 
-		(MethodConfig)e.getConfigElement(MethodConfig.class);
-      // store all reflections result in the model of the gui and not the
-      // MethodConfig obtained from getConfigElement() 'cos that's the clone.
-      // To get the model of the MethodConfigGui, get the MethodConfigGui
-      // from the MethodConfig clone first.  All MethodConfig clones cloned
-      // from the same MethodConfig shares the same MethodConfigGui.
-      MethodConfigGui methodConfigGui =  methodConfig.getGui();
-      MethodConfig model = methodConfigGui.getModel();
-      // Make all changes on the model of the gui and not the MethodConfig
-      // obtained from getConfigElement() because that is the clone.
-      int state = model.getState();
-      reflectionStatus = model.getReflectionStatus();
-      String[] strings = null;
-      if(log.isDebugEnabled())
-      {
-        log.debug("sample1 : state - " + state);
-        log.debug("sample1 : reflectionStatus - " + reflectionStatus);
-      }
-      // Perform only if : 
-      // 1. doing a reflection and in this state
-      // 2. sampling does not perform this step
-      if((state == MethodConfig.METHOD_GET_HOME_NAMES && reflectionStatus 
-	&& !stateJustChanged)) 
-//	|| (state >= MethodConfig.METHOD_GET_HOME_NAMES && !reflectionStatus))
-      {
-        // for this state, get the list of all methods in the home
-        // interface
-        Method[] methods = lookupNameClass.getMethods();
-        strings = new String[methods.length];
-        for(int i = 0; i < methods.length; i++)
-        {
-          // create method name which includes method signatures
-          strings[i] = getMethodSignature(methods[i]);
-        }
-        model.setMethodHomeList(strings);
-        model.setState(MethodConfig.METHOD_GET_HOME_PARMS);
-        stateJustChanged = true;
-      }
-      // Perform only if : 
-      // 1. doing a reflection and in this state
-      // 2. sampling does not perform this step
-      if((state == MethodConfig.METHOD_GET_HOME_PARMS && reflectionStatus
-	&& !stateJustChanged)) 
-//	|| (state >= MethodConfig.METHOD_GET_HOME_PARMS && !reflectionStatus))
-      {
-        // for this state, get all the required parms for the selected
-        // method
-        String methodHomeName = methodConfig.getMethodHomeName();
-        if(log.isDebugEnabled())
-        {
-          log.debug("sample1 : selected methodHomeName - " +
-		methodHomeName);
-        }
-        Vector returnValues = 
-		getMethodParmsTypes(methodHomeName, lookupNameClass);
-        // the first object of returnValues will be the Method while the
-        // the second object will be the parm types of Method
-        Method method = (Method)returnValues.get(0);
-        Class[] methodParmTypes = (Class[])returnValues.get(1);
-        // once the method is obtained store the parms
-        model.setMethodHomeParms(methodParmTypes);
-        model.setHomeMethod(method);
-        model.setState(MethodConfig.METHOD_INVOKE_HOME);
-        stateJustChanged = true;
-      }
-      // Perform only if : 
-      // 1. doing a reflection and in this state
-      // 2. sampling and reflection has been done at least this state
-      //    if reflection has not been done till this state then user is not
-      //    interested in sampling till this state
-      if((state == MethodConfig.METHOD_INVOKE_HOME && reflectionStatus
-	&& !stateJustChanged)
-	|| (state >= MethodConfig.METHOD_INVOKE_HOME && !reflectionStatus))
-      {
-        log.debug("sample1 : METHOD_INVOKE_HOME");
-        Method method = model.getHomeMethod();
-        if(log.isDebugEnabled())
-        {
-          log.debug("sample1 : home method to be invoked - " + method);
-        }
-        // only initialize homeMethodRes if method execution is to be measured
-        homeMethodRes = new SampleResult();
-        // gather all parms from MethodConfigGui
-        Object[] parmsArray = null;
-        try
-        {
-          parmsArray = methodConfigGui.getMethodParmsValues(
-		MethodConfig.METHOD_INVOKE_HOME);
-          if(log.isDebugEnabled())
-          {
-            log.debug("sample1 : home method parms - " + parmsArray);
-          }
-          // invoke the method
-          start = System.currentTimeMillis();
-          remoteInterface = method.invoke(ref, parmsArray);
-			log.info("return - " + remoteInterface);
-        }
-        catch(IllegalAccessException err)
-        {
-          log.error(err);
-        }
-        catch(InvocationTargetException err)
-        {
-          log.error(err);
-        }
-        catch(MethodConfigUserObjectException err)
-        {
-          log.error(err);
-        }
-        end = System.currentTimeMillis();
-        if(!reflectionStatus)
-        {
-          // if sampling then get the time lapsed
-          homeMethodTime = end - start;
-          homeMethodRes.setTime(homeMethodTime);
-          homeMethodRes.putValue(SampleResult.DISPLAY_NAME, "Home Method Execution - "
-                + method.getName());
-          homeMethodRes.putValue(SampleResult.SUCCESS, Boolean.TRUE);
-        }
-        else
-        {
-          // if reflection then get all the info required
-          model.setState(MethodConfig.METHOD_GET_REMOTE_NAMES);
-          stateJustChanged = true;
-          // store list of remote interfaces returned
-          model.setRemoteInterfaceList(remoteInterface);
-        }
-      }
-      // Perform only if : 
-      // 1. doing a reflection and in this state
-      // 2. sampling does NOT perform this step
-      if((state == MethodConfig.METHOD_GET_REMOTE_NAMES && reflectionStatus
-	&& !stateJustChanged))
-//	|| (state >= MethodConfig.METHOD_GET_REMOTE_NAMES && !reflectionStatus))
-      {
-        // for this state, get the list of all methods in the remote
-        // interface
-        remoteInterface = model.getRemoteInterfaceType();
-        Class remoteInterfaceClass = remoteInterface.getClass();
-        if(log.isDebugEnabled())
-        {
-          log.debug("updateGui1 : remoteInterfaceClass - " +
-		remoteInterfaceClass);
-        }
-        Method[] methods = remoteInterfaceClass.getMethods();
-        strings = new String[methods.length];
-        for(int i = 0; i < methods.length; i++)
-        {
-          strings[i] = getMethodSignature(methods[i]);
-        }
-        model.setMethodRemoteList(strings);
-        model.setState(MethodConfig.METHOD_GET_REMOTE_PARMS);
-        stateJustChanged = true;
-      }
-      // Perform only if : 
-      // 1. doing a reflection and in this state
-      // 2. sampling does NOT perform this step
-      if((state == MethodConfig.METHOD_GET_REMOTE_PARMS && reflectionStatus
-	&& !stateJustChanged))
-//	|| (state >= MethodConfig.METHOD_GET_REMOTE_PARMS && !reflectionStatus))
-      {
-        // for this state, get all the required parms for the selected
-        // method
-        String methodRemoteName = methodConfig.getMethodRemoteName();
-        if(log.isDebugEnabled())
-        {
-          log.debug("sample1 : selected methodRemoteName - " +
-		methodRemoteName);
-        }
-        Object selectedRemoteInterfaceType = model.getRemoteInterfaceType();
-        Class selectedRemoteInterfaceTypeClass = 
-		selectedRemoteInterfaceType.getClass();
-        Vector returnValues = getMethodParmsTypes(methodRemoteName, 
-		selectedRemoteInterfaceTypeClass);
-        // the first object of returnValues contains the Method while the
-        // the second object the parm types of the Method
-        Method method = (Method)returnValues.get(0);
-        Class[] methodParmTypes = (Class[])returnValues.get(1);
-        // once the method is obtained store the parms
-        model.setMethodRemoteParms(methodParmTypes);
-        model.setRemoteMethod(method);
-        model.setState(MethodConfig.METHOD_INVOKE_REMOTE);
-        stateJustChanged = true;
-      }
-      // Perform only if : 
-      // 1. doing a reflection and in this state
-      // 2. sampling and reflection has been done at least this state
-      //    if reflection has not been done till this state then user is not
-      //    interested in sampling till this state
-      if((state == MethodConfig.METHOD_INVOKE_REMOTE && reflectionStatus
-	&& !stateJustChanged)
-	|| (state >= MethodConfig.METHOD_INVOKE_REMOTE && !reflectionStatus))
-      {
-        log.debug("sample1 : METHOD_INVOKE_REMOTE");
-        Method method = model.getRemoteMethod();
-        if(log.isDebugEnabled())
-        {
-          log.debug("sample1 : remote method to be invoked - " + method);
-        }
-        Object selectedRemoteInterfaceType = model.getRemoteInterfaceType();
-        // only initialize homeMethodRes if method execution is to be measured
-        remoteMethodRes = new SampleResult();
-        // gather all parms from MethodConfigGui
-        Object[] parmsArray = null;
-        try
-        {
-          parmsArray = methodConfigGui.getMethodParmsValues(
-		MethodConfig.METHOD_INVOKE_REMOTE);
-          // invoke the method
-          start = System.currentTimeMillis();
-          results = method.invoke(selectedRemoteInterfaceType, parmsArray);
-			log.info("return - " + results);
-        }
-        catch(IllegalAccessException err)
-        {
-          log.error(err);
-        }
-        catch(InvocationTargetException err)
-        {
-          log.error(err);
-        }
-        catch(MethodConfigUserObjectException err)
-        {
-          log.error(err);
-        }
-        end = System.currentTimeMillis();
-        if(!reflectionStatus)
-        {
-          // if sampling get the time lapse
-          remoteMethodTime = end - start;
-          remoteMethodRes.setTime(remoteMethodTime);
-          remoteMethodRes.putValue(SampleResult.DISPLAY_NAME, "Remote Method Execution - "
-                + method.getName());
-          String resultsString = results.toString();
-          byte[] resultBytes = null;
-          if(resultsString != null)
-          {
-            resultBytes = resultsString.getBytes();
-          }
-          remoteMethodRes.putValue(SampleResult.TEXT_RESPONSE, resultBytes);
-          remoteMethodRes.putValue(SampleResult.SUCCESS, new Boolean(true));
-        }
-        else
-        {
-          // if reflection the set state
-          model.setState(MethodConfig.METHOD_COMPLETE);
-          stateJustChanged = true;
-        }
-      }
-
-      long totalTime = ctxTime + lookupTime + homeMethodTime + remoteMethodTime;
-      res.setTime(0);
-      res.putValue(SampleResult.DISPLAY_NAME, lookupName);
-      ArrayList resultList = new ArrayList();
-      // don't need to test for null in contextLookupRes and lookupRes
-      // because both cannot be null otherwise error will be thrown
-      resultList.add(contextLookupRes);
-      resultList.add(lookupRes);
-      // test for null in homeMethodRes 'cos a null means that user just want
-      // to get a list of all home methods
-      if(homeMethodRes != null)
-      {
-        resultList.add(homeMethodRes);
-      }
-      // test for null in remoteMethodRes 'cos a null means that user just want
-      // to get a list of all methods of the remote interfaces
-      if(remoteMethodRes != null)
-      {
-        resultList.add(remoteMethodRes);
-      }
-      res.putValue(SampleResult.RESULT_LIST, resultList);
-      res.putValue(SampleResult.TOTAL_TIME, new Long(totalTime));
-
-      log.info("!!!!! ctxTime : " + ctxTime);
-      log.info("!!!!! lookupTime : " + lookupTime);
-      log.info("!!!!! homeMethodTime : " + homeMethodTime);
-    }
-    catch(NamingException err)
-    {
-      log.error(err);
-    }
-    
-    log.info("End : sample1");
-    return res;
-  }
-
-  /**
-   * From the <code>Method</code>, return the method signature i.e.
-   * method name followed by all the parms separated by commas and within
-   * parentheses
-   *
-   * @param method	the method which the method signature is required
-   * @return	method signature of the method
-   */
-  protected String getMethodSignature(Method method)
-  {
-    log.debug("Start : getMethodSignature1");
-    StringBuffer strbuff = new StringBuffer();
-    Class[] parameterTypes = method.getParameterTypes();
-    strbuff.append(method.getName());
-    strbuff.append("(");
-    if(parameterTypes.length > 0)
-    {
-      for(int j = 0; j < (parameterTypes.length - 1); j++)
-      {
-        strbuff.append(parameterTypes[j].toString());
-        strbuff.append(", ");
-      }
-      strbuff.append(parameterTypes[parameterTypes.length - 1]);
-    }
-    strbuff.append(")");
-    String returnVal = strbuff.toString();
-    log.debug("getMethodSignature1 : method signature - " + returnVal);
-    log.debug("End : getMethodSignature1");
-    return returnVal;
-  }
-
-  /**
-   * Given a method name and a class, compares the method name against all
-   * the methods in the class to look for a match.  Once found, return an
-   * array containing all the Class of the parms of the method.
-   */
-  protected Vector getMethodParmsTypes(String methodName, Class objectClass)
-  {
-    log.debug("Start : getMethodParms1");
-    Method[] methods = objectClass.getMethods();
-    Method method = null;
-    Class[] methodParmTypes = null;
-    Class[] parameterTypes = null;
-    StringBuffer strbuff = new StringBuffer();
-    for(int i = 0; i < methods.length; i++)
-    {
-      // create method name which includes method signatures
-      parameterTypes = methods[i].getParameterTypes();
-      strbuff.delete(0, strbuff.length());
-      strbuff.append(methods[i].getName());
-      strbuff.append("(");
-      if(parameterTypes.length > 0)
-      {
-        for(int j = 0; j < (parameterTypes.length - 1); j++)
-        {
-          strbuff.append(parameterTypes[j].toString());
-          strbuff.append(", ");
-        }
-        strbuff.append(parameterTypes[parameterTypes.length - 1]);
-      }
-      strbuff.append(")");
-      String name = strbuff.toString();
-      if(log.isDebugEnabled())
-      {
-        log.debug("getMethodParms1 : current method to be compared - " 
-		+ name);
-      }
-      if(name.equals(methodName))
-      {
-        method = methods[i];
-        methodParmTypes = parameterTypes;
-        break;
-      }
-    }
-    Vector returnValues = new Vector();
-    returnValues.add(method);
-    returnValues.add(methodParmTypes);
-    log.debug("End : getMethodParms1");
-    return returnValues;
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/LookupConfig.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/LookupConfig.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/LookupConfig.java	(working copy)
@@ -1,86 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.config;
-
-import java.io.Serializable;
-
-import org.apache.jmeter.config.AbstractConfigElement;
-import org.apache.jmeter.config.ConfigElement;
-import org.apache.jmeter.ejb.jndi.config.gui.LookupConfigGui;
-import org.apache.jmeter.util.JMeterUtils;
-import org.apache.log4j.Category;
-
-/**
- * Stores the configuration for JNDI lookup
- *
- * @author	Khor Soon Hin
- * Created	2001 Dec 19
- * @version $Revision$ Last Updated: $Date$
- */
-public class LookupConfig extends AbstractConfigElement implements Serializable
-{
-  private static Category catClass = Category.getInstance(
-	LookupConfig.class.getName());
-
-  protected static final String LOOKUP_NAME = "lookup_name";
-
-  public LookupConfig()
-  {
-  }
-
-  public Class getGuiClass()
-  {
-    return org.apache.jmeter.ejb.jndi.config.gui.LookupConfigGui.class;
-  }
-
-  public Object clone()
-  {
-    LookupConfig newConfig = new LookupConfig();
-    configureClone(newConfig);
-    return newConfig;
-  }
-
-  public String getLookupName()
-  {
-    String string = (String)this.getProperty(LOOKUP_NAME);
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("getLookupName1 : lookup name - " + string);
-    }
-    return string;
-  }
-
-  public void setLookupName(String string)
-  {
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("setLookupName1 : lookup name  - " + string);
-    }
-    this.putProperty(LOOKUP_NAME, string);
-  }
-
-  public String getClassLabel()
-  {
-    return JMeterUtils.getResString("jndi_lookup_title");
-  }
-
-  public void addConfigElement(ConfigElement config)
-  {
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/JndiConfigGui.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/JndiConfigGui.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/JndiConfigGui.java	(working copy)
@@ -1,174 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.config.gui;
-
-import javax.swing.*;
-import javax.swing.border.*;
-import java.awt.event.*;
-import javax.naming.InitialContext;
-import java.awt.*;
-import java.util.*;
-
-import org.apache.jmeter.gui.ModelSupported;
-import org.apache.jmeter.gui.NamePanel;
-import org.apache.jmeter.gui.VerticalLayout;
-import org.apache.jmeter.config.gui.ArgumentsPanel;
-import org.apache.jmeter.config.Arguments;
-import org.apache.jmeter.util.JMeterUtils;
-import org.apache.jmeter.ejb.jndi.config.JndiConfig;
-import org.apache.log4j.Category;
-
-/**
- * Provides the gui interface to configure JNDI sampling
- * @author	Khor Soon Hin
- * @version	$Revision$  Last updated: $Date$
- * Created	    2001 Dec 17
- */
-public class JndiConfigGui extends JPanel implements ModelSupported,
-	KeyListener
-{
-  private static Category catClass = Category.getInstance(
-	JndiConfigGui.class.getName());
-
-  protected JTextField[] jndi_fields = new JTextField[JndiConfig.JNDI_PROPS.length];
-
-  protected NamePanel namePanel;
-  protected boolean displayName;
-  protected JndiConfig model;
-
-  public JndiConfigGui()
-  {
-    displayName = true;
-  }
-
-  public JndiConfigGui(boolean displayName)
-  {
-    this.displayName = displayName;
-  }
-
-  public void setModel(Object model)
-  {
-    this.model = (JndiConfig)model;
-    init();
-  }
-
-  public void updateGui()
-  {
-    for(int i = 0; i < JndiConfig.JNDI_PROPS.length; i++)
-    {
-      jndi_fields[i].setText(model.getValue(i)); 
-    }
-  }
-
-  protected void init()
-  {
-    for(int i = 0; i < JndiConfig.JNDI_PROPS.length; i++)
-    {
-      jndi_fields[i] = new JTextField(20);
-    }
-    if(displayName)
-    {
-      this.setLayout(new VerticalLayout(5, VerticalLayout.LEFT, 
-	VerticalLayout.TOP));
-      // main panel
-      JPanel mainPanel = new JPanel();
-      Border margin = new EmptyBorder(10, 10, 5, 10);
-      mainPanel.setBorder(margin);
-      mainPanel.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-
-      mainPanel.add(makeTitlePanel());
-
-      // jndi properties
-      JPanel urlJNDIPanel = new JPanel();
-      urlJNDIPanel.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-      urlJNDIPanel.setBorder(BorderFactory.createTitledBorder(
-	JMeterUtils.getResString("jndi_url_jndi_props")));
-
-      for(int i = 0; i < JndiConfig.JNDI_PROPS.length; i++)
-      {
-        urlJNDIPanel.add(getPanel(i));
-      }
-
-      mainPanel.add(urlJNDIPanel);
-      this.add(mainPanel);
-    }
-    else
-    {
-      this.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-
-      // url and driver class
-      JPanel urlJNDIPanel = new JPanel();
-      urlJNDIPanel.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-      urlJNDIPanel.setBorder(BorderFactory.createTitledBorder(
-	JMeterUtils.getResString("jndi_url_jndi_props")));
-
-      for(int i = 0; i < JndiConfig.JNDI_PROPS.length; i++)
-      {
-        urlJNDIPanel.add(getPanel(i));
-      }
-
-      this.add(urlJNDIPanel);
-    }
-  }
-
-  protected JPanel getPanel(int i)
-  {
-    catClass.info("Start : getPanel1");
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("getPanel1 : Panel no. - " + i);
-      catClass.debug("getPanel1 : Panel name - " + JndiConfig.JNDI_PROPS[i]);
-      catClass.debug("getPanel1 : Panel value - " + model.getValue(i));
-    }
-    JPanel panel = new JPanel();
-    panel.add(new JLabel(JndiConfig.JNDI_PROPS[i]));
-    jndi_fields[i].setText(model.getValue(i));
-    jndi_fields[i].setName(JndiConfig.JNDI_PROPS[i]);
-    jndi_fields[i].addKeyListener(this);
-    panel.add(jndi_fields[i]);
-    catClass.info("End : getPanel1");
-    return panel;
-  }
-
-  public void keyPressed(KeyEvent e)
-  {
-  }
-
-  public void keyTyped(KeyEvent e)
-  {
-  }
-
-  public void keyReleased(KeyEvent e)
-  {
-    String name = e.getComponent().getName();
-    int i = 0;
-    while(i < JndiConfig.JNDI_PROPS.length) 
-    {
-      if(name.equals(JndiConfig.JNDI_PROPS[i]))
-      {
-        break;
-      }
-      i++;
-    }
-    if(i < JndiConfig.JNDI_PROPS.length)
-    {
-      model.setValue(i, jndi_fields[i].getText());
-    }
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/LookupConfigGui.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/LookupConfigGui.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/LookupConfigGui.java	(working copy)
@@ -1,162 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.config.gui;
-
-import javax.swing.*;
-import javax.swing.border.*;
-import java.awt.event.*;
-import javax.naming.InitialContext;
-import java.awt.*;
-import java.util.*;
-
-import org.apache.jmeter.gui.ModelSupported;
-import org.apache.jmeter.gui.NamePanel;
-import org.apache.jmeter.gui.VerticalLayout;
-import org.apache.jmeter.config.gui.ArgumentsPanel;
-import org.apache.jmeter.config.Arguments;
-import org.apache.jmeter.util.JMeterUtils;
-import org.apache.jmeter.ejb.jndi.config.LookupConfig;
-import org.apache.log4j.Category;
-
-/**
- * Provides the gui interface to configure JNDI lookup
- * @author	     Khor Soon Hin
- * @version	$Revision$ Last updated: $Date$
- * Created	    2001 Dec 18
- */
-public class LookupConfigGui extends JPanel implements ModelSupported,
-	KeyListener
-{
-  private static Category catClass = Category.getInstance(
-	LookupConfigGui.class.getName());
-
-  protected JTextField lookupField;
-
-  protected NamePanel namePanel;
-  protected boolean displayName;
-  protected LookupConfig model;
-
-  public LookupConfigGui()
-  {
-    displayName = true;
-  }
-
-  public LookupConfigGui(boolean displayName)
-  {
-    this.displayName = displayName;
-  }
-
-  public void setModel(Object model)
-  {
-    this.model = (LookupConfig)model;
-    init();
-  }
-
-  public void updateGui()
-  {
-    lookupField.setText(model.getLookupName());
-    if(displayName)
-    {
-      namePanel.updateGui();
-    }
-  }
-
-  protected void init()
-  {
-    lookupField = new JTextField(20);
-    if(displayName)
-    {
-      this.setLayout(new VerticalLayout(5, VerticalLayout.LEFT, 
-	VerticalLayout.TOP));
-      // main panel
-      JPanel mainPanel = new JPanel();
-      Border margin = new EmptyBorder(10, 10, 5, 10);
-      mainPanel.setBorder(margin);
-      mainPanel.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-
-      // title
-      JLabel panelTitleLabel = new JLabel(
-	JMeterUtils.getResString("jndi_lookup_title"));
-      Font curFont = panelTitleLabel.getFont();
-      int curFontSize = curFont.getSize();
-      curFontSize += 4;
-      panelTitleLabel.setFont(new Font(curFont.getFontName(), curFont.getStyle(), curFontSize));
-      mainPanel.add(panelTitleLabel);
-
-      // name
-      namePanel = new NamePanel(model);
-      mainPanel.add(namePanel);
-
-      // jndi properties
-      JPanel jndiPanel = new JPanel();
-      jndiPanel.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-      jndiPanel.setBorder(BorderFactory.createTitledBorder(
-	JMeterUtils.getResString("jndi_lookup_name")));
-
-      jndiPanel.add(getLookupNamePanel());
-
-      mainPanel.add(jndiPanel);
-      this.add(mainPanel);
-    }
-    else
-    {
-      this.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-
-      // url and driver class
-      JPanel jndiPanel = new JPanel();
-      jndiPanel.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-      jndiPanel.setBorder(BorderFactory.createTitledBorder(
-	JMeterUtils.getResString("jndi_lookup_name")));
-
-      jndiPanel.add(getLookupNamePanel());
-
-      this.add(jndiPanel);
-    }
-  }
-
-  protected JPanel getLookupNamePanel()
-  {
-    catClass.info("Start : getLookupNamePanel1");
-    JPanel panel = new JPanel();
-    panel.add(new JLabel(JMeterUtils.getResString("jndi_lookup_name")));
-    lookupField.setText(model.getLookupName());
-    lookupField.setName(JMeterUtils.getResString("jndi_lookup_name"));
-    lookupField.addKeyListener(this);
-    panel.add(lookupField);
-    catClass.info("End : getLookupNamePanel1");
-    return panel;
-  }
-
-  public void keyPressed(KeyEvent e)
-  {
-  }
-
-  public void keyTyped(KeyEvent e)
-  {
-  }
-
-  public void keyReleased(KeyEvent e)
-  {
-    String name = e.getComponent().getName();
-    if(name.equals(JMeterUtils.getResString("jndi_lookup_name")))
-    {
-      model.setLookupName(lookupField.getText());
-    }
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/MethodConfigDialog.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/MethodConfigDialog.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/MethodConfigDialog.java	(working copy)
@@ -1,154 +0,0 @@
-// $Header$
-/*
- * Copyright 2002-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.config.gui;
-
-import java.awt.*;
-import java.awt.event.*;
-import java.beans.*;
-import javax.swing.*;
-import javax.swing.event.*;
-
-import org.apache.jmeter.ejb.jndi.config.MethodConfigUserObject;
-import org.apache.jmeter.ejb.jndi.config.MethodConfigUserObjectException;
-import org.apache.log4j.Category;
-
-/**
- * Dialog to allow user to key in value for their method parameters
- *
- * @author	  Khor Soon Hin
- * @version  $Revision$ Last Updated: $Date$
- * Created	  2002 Jan 08
- */
-public class MethodConfigDialog extends JDialog
-{
-  private static Category catClass = Category.getInstance(
-	MethodConfigDialog.class.getName());
-
-  protected JOptionPane optionPane;
-  protected JTextField textField;
-  protected JLabel classLabel;
-  protected MethodConfigUserObject userObject;
-
-  public MethodConfigDialog(Frame aFrame, final Class type)
-  {
-    super(aFrame, true);
-    classLabel = new JLabel(type.getName());
-    textField = new JTextField(10);
-    Object[] array = {classLabel, textField};
-
-    final String btnString1 = "Ok";
-    final String btnString2 = "Cancel";
-    Object[] options = {btnString1, btnString2};
-
-    optionPane = new JOptionPane(
-			array,
-			JOptionPane.QUESTION_MESSAGE,
-			JOptionPane.OK_CANCEL_OPTION,
-			null,
-			options,
-			options[0]);
-    setContentPane(optionPane);
-    setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
-    addWindowListener(new WindowAdapter()
-	{
-	}
-	);
-    textField.addActionListener(new ActionListener()
-	{
-          public void actionPerformed(ActionEvent e)
-	  {
-	    optionPane.setValue(btnString1);
-	  }
-	}
-	);
-    optionPane.addPropertyChangeListener(new PropertyChangeListener()
-	{
-	  public void propertyChange(PropertyChangeEvent e)
-	  {
-	    catClass.debug("Start : propertyChange1");
-	    String prop = e.getPropertyName();
-	    if(catClass.isDebugEnabled())
-	    {
-	      catClass.debug("propertyChange1 : property name - " + prop);
-	    }
-catClass.debug("JOptionPane.INPUT_VALUE_PROPERTY - " + JOptionPane.INPUT_VALUE_PROPERTY);
-catClass.debug("optionPane.getValue() - " + optionPane.getValue());
-catClass.debug("optionPane.getInputValue() - " + optionPane.getInputValue());
-	    Object value = null;
-	    if(isVisible()
-		&& (e.getSource() == optionPane)
-		&& prop.equals(JOptionPane.VALUE_PROPERTY))
-            {
-              value = optionPane.getValue();
-	      if(catClass.isDebugEnabled())
-	      {
-	        catClass.debug("propertyChange1 : optionPane value - " + value);
-	      }
-
-              // reset the JOptionPane's value
-	      // If you don't don this then the next time the user
-	      // presses ths same button no event will be fired
-              optionPane.setValue(JOptionPane.UNINITIALIZED_VALUE);
-
-	      String input = null;
-              if(value.equals(btnString1))
-	      {
-	        try
-	        {
-	          input = textField.getText();
-	          if(catClass.isDebugEnabled())
-	          {
-	            catClass.debug("MethodConfigDialog1 : input - " + input);
-	          }
-	          userObject = new MethodConfigUserObject(type, input);
-	          setVisible(false);
-	        }
-	        catch(MethodConfigUserObjectException ex)
-	        {
-	          // the input is not compatible with the class
-		  catClass.debug(
-			"propertyChange1 : input incompatible with class");
-	          textField.selectAll();
-	          JOptionPane.showMessageDialog(
-  			MethodConfigDialog.this,
-  			"Sorry, \"" + input + "\" "
-  			+ "is not valid for Class "
-  			+ type,
-  			"Try again",
-  			JOptionPane.ERROR_MESSAGE);
-  		  input = null;
-  		  userObject = null;
-	        }
-  	      }
-              else
-              {
-                setVisible(false);
-              }
-	    }
-	    catClass.debug("End - propertyChange1");
-	  }
-	}
-	);
-  }
-
-  public MethodConfigUserObject getValidatedInput()
-  {
-    return userObject;
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/MethodConfigGui.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/MethodConfigGui.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/gui/MethodConfigGui.java	(working copy)
@@ -1,871 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.config.gui;
-import java.awt.Component;
-import java.awt.Dimension;
-import java.awt.Font;
-import java.awt.Frame;
-import java.awt.event.ActionEvent;
-import java.awt.event.ActionListener;
-import java.awt.event.MouseAdapter;
-import java.awt.event.MouseEvent;
-import java.awt.event.MouseListener;
-import java.lang.reflect.Field;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import javax.swing.BorderFactory;
-import javax.swing.JButton;
-import javax.swing.JComboBox;
-import javax.swing.JLabel;
-import javax.swing.JPanel;
-import javax.swing.JTree;
-import javax.swing.border.Border;
-import javax.swing.border.EmptyBorder;
-import javax.swing.event.TreeSelectionEvent;
-import javax.swing.event.TreeSelectionListener;
-import javax.swing.tree.DefaultMutableTreeNode;
-import javax.swing.tree.DefaultTreeModel;
-import javax.swing.tree.TreePath;
-import javax.swing.tree.TreeSelectionModel;
-import org.apache.jmeter.gui.GuiPackage;
-import org.apache.jmeter.gui.NamePanel;
-import org.apache.jmeter.gui.util.VerticalLayout;
-import org.apache.jmeter.testelement.TestPlan;
-import org.apache.jmeter.threads.ThreadGroup;
-import org.apache.jmeter.util.JMeterUtils;
-import org.apache.jorphan.logging.LoggingManager;
-import org.apache.log.Logger;
-/**
- * Provides the gui interface to configure remote method execution
- * @author	Khor Soon Hin
- * @version	$Revision$ Last Updated: $Date$
- * Created	2001 Dec 24
- */
-public class MethodConfigGui
-	extends JPanel
-	implements ModelSupported, ActionListener, TreeSelectionListener
-{
-	transient private static Logger log = LoggingManager.getLoggerForClass();
-	protected static final String REFLECT = "MethodConfigGui.reflect";
-	protected static final String INVOKE = "MethodConfigGui.invoke";
-	protected static final String STRING_CLASS = "java.lang.String";
-	protected JComboBox methodHomeNameBox;
-	protected JComboBox methodRemoteNameBox;
-	protected JComboBox remoteInterfaceBox;
-	protected DefaultMutableTreeNode rootHome;
-	protected DefaultMutableTreeNode rootRemote;
-	protected DefaultTreeModel treeModelHome;
-	protected DefaultTreeModel treeModelRemote;
-	protected NamePanel namePanel;
-	protected JPanel methodHomeNamePanel;
-	protected JPanel methodHomeParmsPanel;
-	protected JPanel remoteInterfaceListPanel;
-	protected JPanel methodRemoteNamePanel;
-	protected JPanel methodRemoteParmsPanel;
-	protected JPanel controlPanel;
-	protected JButton actionButton;
-	protected JTree jTreeHome;
-	protected JTree jTreeRemote;
-	protected boolean displayName;
-	protected MethodConfig model;
-	protected Frame frame;
-	// The frame is required because the JDialog we create must be modal
-	// and to be modal it must be modal relative to a frame.  We want
-	// the dialog boxes to be modal so that user must fill them up before
-	// they can do anything with jmeter
-	public MethodConfigGui()
-	{
-		displayName = true;
-	}
-	public MethodConfigGui(boolean displayName)
-	{
-		this.displayName = displayName;
-	}
-	//----- ModelSupported interface : start -----
-	public void setModel(Object model)
-	{
-		this.model = (MethodConfig) model;
-		init();
-	}
-	public void updateGui()
-	{
-		log.debug("Start : updateGui1");
-		log.info("updateGui1");
-		// the method name box will always be displayed regardless of the state
-		// of the MethodConfig of this gui
-		String methodName = model.getMethodHomeName();
-		log.debug("updateGui1 : home method name - " + methodName);
-		String[] strings = model.getMethodHomeList();
-		setupPullDown(methodHomeNameBox, methodName, strings);
-		// if methodName is null set the home method to be the first entry
-		// as setup in the home method name JComboBox by setupPullDown
-		// This is to ensure that if the user does not change the JComboBox
-		// the first value is set anyway.
-		if (methodName == null && strings != null)
-		{
-			model.setMethodHomeName(strings[0]);
-		}
-		// if the state of the MethodConfig of this gui after 
-		// MethodConfig.METHOD_GET_HOME_NAMES, display panel to get
-		// parms of the selected method
-		int childCount = treeModelHome.getChildCount(rootHome);
-		if (log.isDebugEnabled())
-		{
-			log.debug("updateGui1 : state - " + model.getState());
-			log.debug("updateGui1 : METHOD_GET_HOME_NAMES");
-			log.debug("updateGui1 : rootHome child count - " + childCount);
-		}
-		// if model is in state after getting home method name AND
-		// rootHome(method) has no child(parms set) yet then get them
-		if (model.getState() > MethodConfig.METHOD_GET_HOME_PARMS
-			&& childCount == 0)
-		{
-			log.debug("updateGui1 : METHOD_GET_HOME_PARMS");
-			rootHome.setUserObject(model.getMethodHomeName());
-			//      methodParmsPanel.setVisible(true);
-			// get all the parms
-			Class[] parmTypes = model.getMethodHomeParms();
-			// add all the parms into a JTree
-			for (int i = 0; i < parmTypes.length; i++)
-			{
-				log.debug("updateGui1 : parmType #" + i + " - " + parmTypes[i]);
-				recurseParm(parmTypes[i], rootHome, i, treeModelHome);
-			}
-			// if the chosen method has no parms then updating the value of
-			// root node with the method name doesn't seem to trigger a redraw of
-			// the tree so call treeDidChange()
-			if (parmTypes.length == 0)
-			{
-				jTreeHome.treeDidChange();
-			}
-		}
-		// if model is in state after getting home method name and
-		// all home method parms gave been obtained then get list of
-		// remote interfaces
-		if (model.getState() > MethodConfig.METHOD_SELECT_REMOTE_INTERFACE)
-		{
-			log.debug("METHOD_SELECT_REMOTE_INTERFACE");
-			// remoteInterfaceType is the remote interface selected by the user
-			// remoteInterfaces contains the list of remote interfaces returned
-			// by home method
-			Object remoteInterfaceType = model.getRemoteInterfaceType();
-			String interfaceName = null;
-			if (remoteInterfaceType != null)
-			{
-				interfaceName = remoteInterfaceType.toString();
-			}
-			ArrayList remoteInterfaces = (ArrayList) model.getRemoteInterfaceList();
-			if (log.isDebugEnabled())
-			{
-				log.debug("updateGui1 : remote interfaces - " + remoteInterfaces);
-				log.debug(
-					"updateGui1 : remoteInterfacesType - " + remoteInterfaces.getClass());
-			}
-			// prepare variable strings to contain a list of all the names of
-			// the remote interfaces
-			Object[] remoteInterfacesArray = remoteInterfaces.toArray();
-			strings = new String[remoteInterfacesArray.length];
-			for (int i = 0; i < remoteInterfacesArray.length; i++)
-			{
-				strings[i] = remoteInterfacesArray[i].toString();
-			}
-			setupPullDown(remoteInterfaceBox, interfaceName, strings);
-			// if interfaceName is null set the remote interface to be the first 
-			// entry as setup in the remote interface name JComboBox by setupPullDown.
-			// This is to ensure that if the user does not change the JComboBox
-			// the first value is set anyway.
-			if (interfaceName == null && remoteInterfacesArray != null)
-			{
-				model.setRemoteInterfaceType(remoteInterfacesArray[0]);
-			}
-		}
-		// if model is in state after user selects the list of remote interface
-		// then get a list of remote method names
-		if (model.getState() > MethodConfig.METHOD_GET_REMOTE_NAMES)
-		{
-			log.debug("METHOD_GET_REMOTE_NAMES");
-			methodName = model.getMethodRemoteName();
-			log.debug("updateGui1 : remote method name - " + methodName);
-			strings = model.getMethodRemoteList();
-			setupPullDown(methodRemoteNameBox, methodName, strings);
-			childCount = treeModelRemote.getChildCount(rootRemote);
-			if (log.isDebugEnabled())
-			{
-				log.debug("updateGui1 : rootRemote child count - " + childCount);
-			}
-		}
-		// if model is in state after getting remote interface AND
-		// rootRemote(method) has no child(parms set) yet then get them
-		if (model.getState() > MethodConfig.METHOD_GET_REMOTE_PARMS
-			&& childCount == 0)
-		{
-			log.debug("METHOD_GET_REMOTE_PARMS");
-			rootRemote.setUserObject(model.getMethodRemoteName());
-			//      methodParmsPanel.setVisible(true);
-			// get all the parms
-			Class[] parmTypes = model.getMethodRemoteParms();
-			// add all the parms into a JTree
-			for (int i = 0; i < parmTypes.length; i++)
-			{
-				log.debug("updateGui1 : parmType #" + i + " - " + parmTypes[i]);
-				recurseParm(parmTypes[i], rootHome, i, treeModelHome);
-			}
-			// if the chosen method has no parms then updating the value of
-			// root node with the method name doesn't seem to trigger a redraw of
-			// the tree so call treeDidChange()
-			if (parmTypes.length == 0)
-			{
-				jTreeRemote.treeDidChange();
-			}
-		}
-		// if the state of the MethodConfig of this gui is
-		// MethodConfig.METHOD_GET_HOME_PARMS, display panel
-		if (displayName)
-		{
-			namePanel.updateGui();
-		}
-		log.debug("End : updateGui1");
-	}
-	//----- ModelSupported interface : end -----
-	protected void init()
-	{
-		log.info("Start : init1");
-		// The frame is required because the JDialog we create must be modal
-		// and to be modal it must be modal relative to a frame.  We want
-		// the dialog boxes to be modal so that user must fill them up before
-		// they can do anything with jmeter
-		GuiPackage guiPkg = GuiPackage.getInstance();
-		frame = guiPkg.getMainFrame();
-		model.setState(MethodConfig.METHOD_GET_HOME_NAMES);
-		model.setGui(this);
-		methodHomeNameBox = new JComboBox();
-		methodHomeNameBox.setEditable(false);
-		methodHomeNameBox.setAlignmentX(Component.LEFT_ALIGNMENT);
-		methodHomeNameBox.addActionListener(new ActionListener()
-		{
-			public void actionPerformed(ActionEvent e)
-			{
-				log.debug("actionPerformed1 : Home name method JComboBox changed");
-				// change in method name so do the following
-				JComboBox comboBox = (JComboBox) e.getSource();
-				String method = (String) methodHomeNameBox.getSelectedItem();
-				model.setMethodHomeName(method);
-				model.setState(MethodConfig.METHOD_GET_HOME_PARMS);
-				resetHomeMethodParms();
-				resetRemoteInterfaceList();
-				resetRemoteMethodName();
-				resetRemoteMethodParms();
-				//            methodParmsPanel.setVisible(false);
-				actionButton.setText(
-					JMeterUtils.getResString("jndi_method_button_reflect"));
-				updateGui();
-			}
-		});
-		remoteInterfaceBox = new JComboBox();
-		remoteInterfaceBox.setEditable(false);
-		remoteInterfaceBox.setAlignmentX(Component.LEFT_ALIGNMENT);
-		remoteInterfaceBox.addActionListener(new ActionListener()
-		{
-			public void actionPerformed(ActionEvent e)
-			{
-				log.debug("actionPerformed1 : Remote Interface JComboBox changed");
-				JComboBox comboBox = (JComboBox) e.getSource();
-				String interfaceName = (String) remoteInterfaceBox.getSelectedItem();
-				// compare interface selected with the ones in the remote interface
-				// list and store the corresponding object in MethodConfig
-				ArrayList remoteInterfaceList =
-					(ArrayList) model.getRemoteInterfaceList();
-				if (remoteInterfaceList != null)
-				{
-					Object[] remoteInterfaceListArray = remoteInterfaceList.toArray();
-					int i = 0;
-					boolean found = false;
-					String remoteInterfaceListName = null;
-					Object selectedInterface = null;
-					while (i < remoteInterfaceListArray.length && !found)
-					{
-						remoteInterfaceListName = remoteInterfaceListArray[i].toString();
-						if (remoteInterfaceListName.equals(interfaceName))
-						{
-							found = true;
-							selectedInterface = remoteInterfaceListArray[i];
-						}
-						i++;
-					}
-					model.setRemoteInterfaceType(selectedInterface);
-					model.setState(MethodConfig.METHOD_GET_REMOTE_NAMES);
-				}
-				resetRemoteMethodName();
-				resetRemoteMethodParms();
-				//            methodParmsPanel.setVisible(false);
-				actionButton.setText(
-					JMeterUtils.getResString("jndi_method_button_reflect"));
-				updateGui();
-			}
-		});
-		methodRemoteNameBox = new JComboBox();
-		methodRemoteNameBox.setEditable(false);
-		methodRemoteNameBox.setAlignmentX(Component.LEFT_ALIGNMENT);
-		methodRemoteNameBox.addActionListener(new ActionListener()
-		{
-			public void actionPerformed(ActionEvent e)
-			{
-				log.debug("actionPerformed1 : Remote method name JComboBox changed");
-				// change in method name so do the following
-				JComboBox comboBox = (JComboBox) e.getSource();
-				String method = (String) methodRemoteNameBox.getSelectedItem();
-				model.setMethodRemoteName(method);
-				model.setState(MethodConfig.METHOD_GET_REMOTE_PARMS);
-				resetRemoteMethodParms();
-				//            methodParmsPanel.setVisible(false);
-				actionButton.setText(
-					JMeterUtils.getResString("jndi_method_button_reflect"));
-				updateGui();
-			}
-		});
-		//rootHome = new DefaultMutableTreeNode("Root");
-		//treeModelHome = new DefaultTreeModel(rootHome);
-		this.setLayout(
-			new VerticalLayout(5, VerticalLayout.LEFT, VerticalLayout.TOP));
-		JPanel mainPanel = new JPanel();
-		Border margin = new EmptyBorder(10, 10, 5, 10);
-		mainPanel.setBorder(margin);
-		mainPanel.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-		// title
-		JLabel panelTitleLabel =
-			new JLabel(JMeterUtils.getResString("jndi_method_title"));
-		Font curFont = panelTitleLabel.getFont();
-		int curFontSize = curFont.getSize();
-		curFontSize += 4;
-		panelTitleLabel.setFont(
-			new Font(curFont.getFontName(), curFont.getStyle(), curFontSize));
-		mainPanel.add(panelTitleLabel);
-		// name
-		namePanel = new NamePanel(model);
-		mainPanel.add(namePanel);
-		// method properties
-		JPanel jndiPanel = new JPanel();
-		jndiPanel.setLayout(new VerticalLayout(5, VerticalLayout.LEFT));
-		jndiPanel.setBorder(
-			BorderFactory.createTitledBorder(
-				JMeterUtils.getResString("jndi_method_name")));
-		methodHomeNamePanel = getMethodHomeNamePanel();
-		methodHomeParmsPanel = getMethodHomeParmsPanel();
-		remoteInterfaceListPanel = getRemoteInterfaceListPanel();
-		methodRemoteNamePanel = getMethodRemoteNamePanel();
-		methodRemoteParmsPanel = getMethodRemoteParmsPanel();
-		jndiPanel.add(methodHomeNamePanel);
-		jndiPanel.add(methodHomeParmsPanel);
-		jndiPanel.add(remoteInterfaceListPanel);
-		jndiPanel.add(methodRemoteNamePanel);
-		jndiPanel.add(methodRemoteParmsPanel);
-		controlPanel = new JPanel();
-		actionButton =
-			new JButton(JMeterUtils.getResString("jndi_method_button_reflect"));
-		actionButton.addActionListener(this);
-		actionButton.setActionCommand(REFLECT);
-		controlPanel.add(actionButton);
-		jndiPanel.add(controlPanel);
-		mainPanel.add(jndiPanel);
-		this.add(mainPanel);
-		//methodHomeParmsPanel.setVisible(false);
-		log.info("End : init1");
-	}
-	/**
-	 * Given a parameter type of a method, this method will find out
-	 * if the parm type is a primitive.  If so, it'll just add the parm type
-	 * as a node into the tree model (used to store all parm types of the method).
-	 * If however, the parm type is not a primitive, then the parm type will be
-	 * further recursed i.e. a reflection of all the fields is obtained
-	 * and each of which will be examined to determined if they are primitives.
-	 * For those which are primitives, they'll be added to the tree model
-	 * and those otherwise will be further recursed.
-	 *
-	 * @param parmType	the parmType of a method which will be examined
-	 * @param parentNode	the node under which the parmType will be added to
-	 * @param childIndex	the index of the this parmType if it were to be added
-	 *			under the parent node
-	 */
-	protected void recurseParm(
-		Class parmType,
-		DefaultMutableTreeNode parentNode,
-		int childIndex,
-		DefaultTreeModel treeModel)
-	{
-		log.debug("Start - recurseParm1");
-		DefaultMutableTreeNode node = new DefaultMutableTreeNode(parmType);
-		treeModel.insertNodeInto(node, parentNode, childIndex);
-		log.info("recurseParm1 - parent : " + parentNode);
-		log.info("recurseParm1 - parent : " + treeModel.getChildCount(parentNode));
-		log.info("recurseParm1 - child : " + treeModel.getChildCount(node));
-		if (parmType.isPrimitive())
-		{
-			// if parmType is primitive then no need to recurse the parm
-		}
-		else if (parmType.getName().equals(STRING_CLASS))
-		{
-			// consider String as a primitive i.e. there is not need to recurse parm
-		}
-		else if (parmType.isArray())
-		{
-			// if parmType is array then need to handle differently
-		}
-		else
-		{
-			// if parmType is NOT primitive then need to recurse the parm since
-			// it's an object.
-			// to recurse the object, use reflections to get all fields
-			Field[] fields = parmType.getFields();
-			for (int i = 0; i < fields.length; i++)
-			{
-				Class fieldClass = fields[i].getType();
-				log.debug("recurseParm1 : field #" + i + " - " + fieldClass);
-				recurseParm(fieldClass, node, i, treeModel);
-			}
-		}
-		log.debug("End - recurseParm1");
-	}
-	protected JPanel getMethodHomeNamePanel()
-	{
-		log.info("Start : getMethodHomeNamePanel1");
-		JPanel panel = new JPanel();
-		panel.add(new JLabel(JMeterUtils.getResString("jndi_method_home_name")));
-		String methodName = model.getMethodHomeName();
-		if (methodName != null)
-		{
-			methodHomeNameBox.setSelectedItem(methodName);
-		}
-		panel.add(methodHomeNameBox);
-		log.info("End : getMethodHomeNamePanel1");
-		return panel;
-	}
-	protected JPanel getRemoteInterfaceListPanel()
-	{
-		log.info("Start : getRemoteInterfaceListPanel1");
-		JPanel panel = new JPanel();
-		panel.add(
-			new JLabel(
-				JMeterUtils.getResString("jndi_method_remote_interface_list")));
-		Object remoteInterfaceType = model.getRemoteInterfaceType();
-		if (remoteInterfaceType != null)
-		{
-			remoteInterfaceBox.setSelectedItem(remoteInterfaceType.toString());
-		}
-		panel.add(remoteInterfaceBox);
-		log.info("End : getRemoteInterfaceListPanel1");
-		return panel;
-	}
-	protected JPanel getMethodRemoteNamePanel()
-	{
-		log.info("Start : getMethodRemoteNamePanel1");
-		JPanel panel = new JPanel();
-		panel.add(new JLabel(JMeterUtils.getResString("jndi_method_remote_name")));
-		String methodName = model.getMethodRemoteName();
-		if (methodName != null)
-		{
-			methodRemoteNameBox.setSelectedItem(methodName);
-		}
-		panel.add(methodRemoteNameBox);
-		log.info("End : getMethodRemoteNamePanel1");
-		return panel;
-	}
-	protected JPanel getMethodHomeParmsPanel()
-	{
-		log.info("Start : getMethodHomeParmsPanel1");
-		JPanel panel = new JPanel();
-		panel.add(new JLabel(JMeterUtils.getResString("jndi_method_home_parms")));
-		rootHome = new DefaultMutableTreeNode("Root");
-		treeModelHome = new DefaultTreeModel(rootHome);
-		jTreeHome = new JTree(treeModelHome);
-		jTreeHome.getSelectionModel().setSelectionMode(
-			TreeSelectionModel.SINGLE_TREE_SELECTION);
-		jTreeHome.addTreeSelectionListener(this);
-		jTreeHome.setPreferredSize(new Dimension(200, 50));
-		JPanel jTreePanel = new JPanel();
-		jTreePanel.add(jTreeHome);
-		panel.add(jTreePanel);
-		// set mouse listener to listen for double clicks
-		MouseListener ml = new MouseAdapter()
-		{
-			public void mousePressed(MouseEvent e)
-			{
-				TreePath selPath = jTreeHome.getPathForLocation(e.getX(), e.getY());
-				if (e.getClickCount() == 2)
-				{
-					log.info("Double clicked on - " + selPath.getLastPathComponent());
-					DefaultMutableTreeNode node =
-						(DefaultMutableTreeNode) selPath.getLastPathComponent();
-					int childCount = node.getChildCount();
-					// if node is a leaf and has a parent (i.e. not root)
-					// then node is a parm which needs a value so pop out
-					// dialog for user to fill in
-					if (childCount == 0 && node.getParent() != null)
-					{
-						log.info("Pop!!!");
-						Object userObject = node.getUserObject();
-						Class type = null;
-						if (userObject instanceof Class)
-						{
-							type = (Class) userObject;
-						}
-						else if (userObject instanceof MethodConfigUserObject)
-						{
-							type = (Class) ((MethodConfigUserObject) userObject).getType();
-						}
-						MethodConfigDialog dialog = new MethodConfigDialog(frame, type);
-						dialog.pack();
-						dialog.setVisible(true);
-						MethodConfigUserObject input = dialog.getValidatedInput();
-						log.info("input - " + input);
-						if (input != null)
-						{
-							node.setUserObject(input);
-						}
-					}
-				}
-			}
-		};
-		jTreeHome.addMouseListener(ml);
-		log.info("End : getMethodHomeParmsPanel1");
-		return panel;
-	}
-	protected JPanel getMethodRemoteParmsPanel()
-	{
-		log.info("Start : getMethodRemoteParmsPanel1");
-		JPanel panel = new JPanel();
-		panel.add(new JLabel(JMeterUtils.getResString("jndi_method_remote_parms")));
-		rootRemote = new DefaultMutableTreeNode("Root");
-		treeModelRemote = new DefaultTreeModel(rootRemote);
-		jTreeRemote = new JTree(treeModelRemote);
-		jTreeRemote.getSelectionModel().setSelectionMode(
-			TreeSelectionModel.SINGLE_TREE_SELECTION);
-		jTreeRemote.addTreeSelectionListener(this);
-		jTreeRemote.setPreferredSize(new Dimension(200, 50));
-		JPanel jTreePanel = new JPanel();
-		jTreePanel.add(jTreeRemote);
-		panel.add(jTreePanel);
-		// set mouse listener to listen for double clicks
-		MouseListener ml = new MouseAdapter()
-		{
-			public void mousePressed(MouseEvent e)
-			{
-				TreePath selPath = jTreeRemote.getPathForLocation(e.getX(), e.getY());
-				if (e.getClickCount() == 2)
-				{
-					log.info("Double clicked on - " + selPath.getLastPathComponent());
-					DefaultMutableTreeNode node =
-						(DefaultMutableTreeNode) selPath.getLastPathComponent();
-					int childCount = node.getChildCount();
-					if (childCount == 0)
-					{
-						log.info("Pop!!!");
-						Object userObject = node.getUserObject();
-						Class type = null;
-						if (userObject instanceof Class)
-						{
-							type = (Class) userObject;
-						}
-						else if (userObject instanceof MethodConfigUserObject)
-						{
-							type = (Class) ((MethodConfigUserObject) userObject).getType();
-						}
-						MethodConfigDialog dialog = new MethodConfigDialog(frame, type);
-						dialog.pack();
-						dialog.setVisible(true);
-						MethodConfigUserObject input = dialog.getValidatedInput();
-						log.info("input - " + input);
-						if (input != null)
-						{
-							node.setUserObject(input);
-						}
-					}
-				}
-			}
-		};
-		jTreeRemote.addMouseListener(ml);
-		log.info("End : getMethodHomeParmsPanel1");
-		return panel;
-	}
-	public MethodConfig getModel()
-	{
-		return model;
-	}
-	/**
-	 * Caller needs to be able to get Method Parms for both the Home Method
-	 * and Remote Method.  Based on the state this method will call
-	 * <code>getMethodParmsValues</code> witht the appropriate root.  NOTE :
-	 * parms for Home and Remote Methods are stored under different roots.
-	 */
-	public Object[] getMethodParmsValues(int state)
-		throws MethodConfigUserObjectException
-	{
-		Object[] objects = null;
-		if (state == MethodConfig.METHOD_INVOKE_HOME)
-		{
-			objects = getMethodParmsValues(rootHome);
-		}
-		else if (state == MethodConfig.METHOD_INVOKE_REMOTE)
-		{
-			objects = getMethodParmsValues(rootRemote);
-		}
-		return objects;
-	}
-	public Object[] getMethodParmsValues(DefaultMutableTreeNode root)
-		throws MethodConfigUserObjectException
-	{
-		log.info("Start : getMethodParmsValues1");
-		// go through jTree to get all arguments
-		int childCount = root.getChildCount();
-		Object[] parmsValues = new Object[childCount];
-		for (int i = 0; i < childCount; i++)
-		{
-			parmsValues[i] =
-				formObject((DefaultMutableTreeNode) treeModelHome.getChild(root, i));
-		}
-		log.info("End : getMethodParmsValues1");
-		return parmsValues;
-	}
-	protected Object formObject(DefaultMutableTreeNode node)
-		throws MethodConfigUserObjectException
-	{
-		log.info("Start : formObject1");
-		Object obj = node.getUserObject();
-		Object returnVal = null;
-		if (obj instanceof MethodConfigUserObject)
-		{
-			// then node contains a primitive so just get the object
-			MethodConfigUserObject userObject = (MethodConfigUserObject) obj;
-			returnVal = userObject.getObject();
-			if (log.isDebugEnabled())
-			{
-				log.debug("formObject1 : primitive - " + userObject);
-			}
-		}
-		else if (obj instanceof Class)
-		{
-			// there are cases when the tree node will contain only class
-			// and not MethodConfigUserObject -
-			// 1. its value has not been input by the user but it's a primitive
-			// 2. it's not a primitive but an object
-			Class type = (Class) obj;
-			if (type.isPrimitive())
-			{
-				// it's a primitive but the user has not input a value for it
-				String errorStr =
-					type.getName() + " is a primitive with uninitialized values";
-				log.error("formObject1 : " + errorStr);
-				throw new MethodConfigUserObjectException(errorStr);
-			}
-			else
-			{
-				// then node is an object which contains other primitives
-				if (log.isDebugEnabled())
-				{
-					log.debug("formObject1 : Creating object - " + type);
-				}
-				int childCount = node.getChildCount();
-				Object[] constituents = new Object[childCount];
-				for (int i = 0; i < childCount; i++)
-				{
-					constituents[i] =
-						formObject(
-							(DefaultMutableTreeNode) treeModelHome.getChild(node, i));
-				}
-				// get the fields of the class
-				// gather all constituents to form object
-				Field[] fields = type.getFields();
-				try
-				{
-					for (int i = 0; i < constituents.length; i++)
-					{
-						log.debug("formObject1 : setting - " + fields[i].getName());
-						log.debug(
-							"formObject1 : to value - "
-								+ constituents[i]
-								+ " of - "
-								+ constituents[i].getClass());
-						returnVal = type.newInstance();
-						fields[i].set(returnVal, constituents[i]);
-					}
-				}
-				catch (IllegalAccessException e)
-				{
-					log.error(e);
-					throw new MethodConfigUserObjectException(e.getMessage());
-				}
-				catch (InstantiationException e)
-				{
-					log.error(e);
-					throw new MethodConfigUserObjectException(e.getMessage());
-				}
-			}
-		}
-		log.info("End : formObject1");
-		return returnVal;
-	}
-	/**
-	 * Sets up the pull-down menus to contain all the <code>String</code>s
-	 * passed in as well as displaying the user's selection.
-	 *
-	 * @param methodNameBox	the <code>JComboBox</code> to be manipulated
-	 * @param methodName		the user's selection
-	 * @param strings		the list of <code>String</code>s to be added
-	 *				into the <code>JComboBox</code>
-	 */
-	protected void setupPullDown(
-		JComboBox methodNameBox,
-		String methodName,
-		String[] strings)
-	{
-		log.info("Start : setupPullDown1");
-		// if the list is empty then try to fill it
-		if (methodNameBox.getItemCount() == 0)
-		{
-			if (strings != null)
-			{
-				for (int i = 0; i < strings.length; i++)
-				{
-					log.debug("setupPullDown1 :  adding method - " + strings[i]);
-					methodNameBox.addItem(strings[i]);
-				}
-			}
-		}
-		// change the methodBox selected item only if there's a change in the
-		// methodName to avoid triggering actionPerformed each time
-		String methodNameBoxSelected = (String) methodNameBox.getSelectedItem();
-		if ((methodName != null) && !methodName.equals(methodNameBoxSelected))
-		{
-			methodNameBox.setSelectedItem(methodName);
-		}
-		log.info("End : setupPullDown1");
-	}
-	/**
-	 * Resets the home method parms.  This method will be called when the user
-	 * makes any changes which requires the resetting the method home parms
-	 * e.g. when user decides to call another home method.
-	 */
-	protected void resetHomeMethodParms()
-	{
-		log.info("Start : resetHomeMethodParms1");
-		// remove all parms of the old method
-		int totalChild = rootHome.getChildCount();
-		for (int i = 0; i < totalChild; i++)
-		{
-			// the child to be removed will always be 0 'cos as the child
-			// is removed the nth node will become (n-1)th
-			treeModelHome.removeNodeFromParent(
-				(DefaultMutableTreeNode) rootHome.getChildAt(0));
-		}
-		rootHome.setUserObject("Root");
-		log.info("End : resetHomeMethodParms1");
-	}
-	/**
-	 * Resets the remote interface list returned by the home method.  This method
-	 * will be called when the user makes any changes which requires the 
-	 * remote interface list to be modified e.g. when user decides to call 
-	 * another home method.
-	 */
-	protected void resetRemoteInterfaceList()
-	{
-		log.info("Start : resetRemoteInterfaceList1");
-		model.setRemoteInterfaceList(null);
-		model.setRemoteInterfaceType(null);
-		remoteInterfaceBox.removeAllItems();
-		log.info("End : resetRemoteInterfaceList1");
-	}
-	/**
-	 * Resets the selected remote interface.  This method will be called when 
-	 * the user makes any changes which requires the resetting the selected
-	 * remote interface e.g. when user decides to call another home method,
-	 * when the user decides to change the remote interface to be executed.
-	 */
-	protected void resetRemoteMethodName()
-	{
-		log.info("Start : resetRemoteMethodName1");
-		model.setMethodRemoteName(null);
-		methodRemoteNameBox.removeAllItems();
-		log.info("End : resetRemoteMethodName1");
-	}
-	/** 
-	  * Resets the remote method parms.  This method will be called when the user 
-	  * makes any changes which requires the resetting the method remote parms
-	  * e.g. when user decides to call another home method, when user changes the
-	  * remote interface to be executed, when user changes the remote method
-	  * to be run.
-	  */
-	protected void resetRemoteMethodParms()
-	{
-		log.info("Start : resetRemoteMethodParms1");
-		// remove all parms of the old method
-		int totalChild = rootRemote.getChildCount();
-		for (int i = 0; i < totalChild; i++)
-		{
-			// the child to be removed will always be 0 'cos as the child
-			// is removed the nth node will become (n-1)th
-			treeModelRemote.removeNodeFromParent(
-				(DefaultMutableTreeNode) rootRemote.getChildAt(0));
-		}
-		rootRemote.setUserObject("Root");
-		log.info("End : resetRemoteMethodParms1");
-	}
-	//----- ActionListener interface : start -----
-	public void actionPerformed(ActionEvent e)
-	{
-		String command = e.getActionCommand();
-		ReflectionJMeterEngine engine = null;
-		GuiPackage guiPackage = null;
-		if (log.isDebugEnabled())
-		{
-			log.debug("actionPerformed1 : command - " + command);
-		}
-		if (command.equals(REFLECT))
-		{
-			guiPackage = GuiPackage.getInstance();
-			Collection groups = TestPlan.createTestPlan(null).compileTestPlan();
-			engine = new ReflectionJMeterEngine();
-			for (Iterator i = groups.iterator(); i.hasNext();)
-			{
-				ThreadGroup tg = (ThreadGroup) i.next();
-				if (log.isDebugEnabled())
-				{
-					log.debug("actionPerformed1 : threadgroup - " + tg);
-				}
-				engine.addThreadGroup(tg);
-			}
-			guiPackage.getMainFrame().setRunning(true);
-			model.setReflectionStatus(true);
-			engine.runTest();
-			guiPackage.getMainFrame().setRunning(false);
-			model.setReflectionStatus(false);
-			updateGui();
-		}
-		if (command.equals(INVOKE))
-		{
-		}
-	}
-	//----- ActionListener interface : end -----
-	//----- TreeSelectionListener interface : start -----
-	public void valueChanged(TreeSelectionEvent e)
-	{
-		log.debug("Start : valueChanged1");
-		log.debug("End : valueChanged1");
-	}
-	//----- TreeSelectionListener interface : end -----
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/MethodConfig.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/MethodConfig.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/MethodConfig.java	(working copy)
@@ -1,294 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.config;
-
-import java.io.Serializable;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-
-import org.apache.jmeter.config.AbstractConfigElement;
-import org.apache.jmeter.config.ConfigElement;
-import org.apache.jmeter.ejb.jndi.config.gui.MethodConfigGui;
-import org.apache.jmeter.util.JMeterUtils;
-import org.apache.log4j.Category;
-
-/**
- * Stores the configuration for remote method execution
- *
- * @author	Khor Soon Hin
- * Created	2001 Dec 24
- * @version $Revision$ Last Updated: $Date$
- */
-public class MethodConfig extends AbstractConfigElement implements Serializable
-{
-  private static Category catClass = Category.getInstance(
-	MethodConfig.class.getName());
-
-  protected static final String METHOD_HOME_NAME = 
-	"MethodConfig.method_home_name";
-  protected static final String METHOD_HOME_LIST = 
-	"MethodConfig.method_home_list";
-  protected static final String METHOD_HOME_PARMS = 
-	"MethodConfig.method_home_parms";
-  protected static final String METHOD_REMOTE_INTERFACE_LIST = 
-	"MethodConfig.method_remote_name_list";
-  protected static final String METHOD_REMOTE_NAME =
-	"MethodConfig.method_remote_name";
-  protected static final String METHOD_REMOTE_LIST =
-	"MethodConfig.method_remote_list";
-  protected static final String METHOD_REMOTE_PARMS =
-	"MethodConfig.method_remote_parms";
-  protected static final String METHOD_CONFIG_GUI =
-	"MethodConfig.method_config_gui";
-	// Attach the gui to the model.  This enables us to get the gui
-	// instance given the model.  This is important for MethodConfig
-	// class since sampling this class generates Method names
-	// and parameters (through reflection) which will be used in the
-	// MethodConfigGui
-  protected static final String METHOD_REMOTE_INTERFACE_TYPE = 
-	"MethodConfig.method_remote_interface_type";
-
-  // Below are the states the MethodConfig can be in. Depending on the state
-  // which MethodConfig is in, when 'Run' is executed, the sampler
-  // will perform different things.  See explanation of each state below.
-  public static final int METHOD_GET_HOME_NAMES = 0;
-	// reflect on all the method names of the Home interface
-  public static final int METHOD_GET_HOME_PARMS = 1;
-	// with a Home method selected reflect on all parms of the method
-  public static final int METHOD_INVOKE_HOME = 2;
-	// with all parms of the selected method filled, invoke the method
-  public static final int METHOD_SELECT_REMOTE_INTERFACE = 3;
-  public static final int METHOD_GET_REMOTE_NAMES = 4;
-	// reflect on all the method names of the Remote interface
-  public static final int METHOD_GET_REMOTE_PARMS = 5;
-	// with a Remote method selected reflect on all parms of the method
-  public static final int METHOD_INVOKE_REMOTE = 6;
-  public static final int METHOD_COMPLETE = 7;
-
-  protected Method homeMethod;
-  protected Method remoteMethod;
-  protected int state;
-  // This variable is always false until the 'Reflect' button on the
-  // ejb method config panel is clicked.  This allows the JNDISampler
-  // to differentiate between sampling and relfection since it does both.
-  // When it does reflection, it will only run one reflection step at each time
-  // e.g. the first reflection will expose all methods of the home object
-  // returned by the lookup, the second the parms of the selected home object
-  // method etc.  For sampling all the steps will be run.
-  protected boolean reflectionStatus = false;
-	
-  public MethodConfig()
-  {
-  }
-
-  public Class getGuiClass()
-  {
-    return org.apache.jmeter.ejb.jndi.config.gui.MethodConfigGui.class;
-  }
-
-  public Object clone()
-  {
-    MethodConfig newConfig = new MethodConfig();
-    configureClone(newConfig);
-    return newConfig;
-  }
-
-  public String getMethodHomeName()
-  {
-    String string = (String)this.getProperty(METHOD_HOME_NAME);
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("getMethodHomeName1 : method home name - " + string);
-    }
-    return string;
-  }
-
-  public void setMethodHomeName(String string)
-  {
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("setMethodHomeName1 : method home name  - " + string);
-    }
-    this.putProperty(METHOD_HOME_NAME, string);
-  }
-
-  public String getMethodRemoteName()
-  {
-    String string = (String)this.getProperty(METHOD_REMOTE_NAME);
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("getMethodRemoteName1 : method remote name - " + string);
-    }
-    return string;
-  }
-
-  public void setMethodRemoteName(Object ref)
-  {
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("setMethodRemoteName1 : method remote name  - " + ref);
-    }
-    this.putProperty(METHOD_REMOTE_NAME, ref);
-  }
-
-  public Object getRemoteInterfaceType()
-  {
-    Object ref  = this.getProperty(METHOD_REMOTE_INTERFACE_TYPE);
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("getRemoteInterfaceType1 : remote interface - " + 
-	ref);
-    }
-    return ref;
-  }
-
-  public void setRemoteInterfaceType(Object ref)
-  {
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("setRemoteInterfaceType1 : remote interface - " +
-	ref);
-    }
-    this.putProperty(METHOD_REMOTE_INTERFACE_TYPE, ref);
-  }
-
-  public Object getRemoteInterfaceList()
-  {
-    Object ref = this.getProperty(METHOD_REMOTE_INTERFACE_LIST);
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("getRemoteInterfaceList1 : remote interface list - " + 
-	ref);
-    }
-    return ref;
-  }
-
-  public void setRemoteInterfaceList(Object ref)
-  {
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("setRemoteInterfaceList1 : remote interface list - " +
-	ref);
-    }
-    this.putProperty(METHOD_REMOTE_INTERFACE_LIST, ref);
-  }
-
-  public String[] getMethodHomeList()
-  {
-    String[] strings = (String[])this.getProperty(METHOD_HOME_LIST);
-    return strings;
-  }
-
-  public void setMethodHomeList(String[] list)
-  {
-    this.putProperty(METHOD_HOME_LIST, list);
-  }
-
-  public String[] getMethodRemoteList()
-  {
-    String[] strings = (String[])this.getProperty(METHOD_REMOTE_LIST);
-    return strings;
-  }
-
-  public void setMethodRemoteList(String[] list)
-  {
-    this.putProperty(METHOD_REMOTE_LIST, list);
-  }
-
-  public Class[] getMethodHomeParms()
-  {
-    Class[] classes= (Class[])this.getProperty(METHOD_HOME_PARMS);
-    return classes;
-  }
-
-  public void setMethodHomeParms(Class[] list)
-  {
-    this.putProperty(METHOD_HOME_PARMS, list);
-  }
-
-  public  Class[] getMethodRemoteParms()
-  {
-    Class[] classes= (Class[])this.getProperty(METHOD_REMOTE_PARMS);
-    return classes;
-  }
-
-  public void setMethodRemoteParms(Class[] list)
-  {
-    this.putProperty(METHOD_REMOTE_PARMS, list);
-  }
-
-  public int getState()
-  {
-    return state;
-  }
-
-  public void setState(int current)
-  {
-    state = current;
-  }
-
-  public String getClassLabel()
-  {
-    return JMeterUtils.getResString("jndi_method_title");
-  }
-
-  public void addConfigElement(ConfigElement config)
-  {
-  }
-
-  public void setGui(MethodConfigGui gui)
-  {
-    this.putProperty(METHOD_CONFIG_GUI, gui);
-  }
-
-  public MethodConfigGui getGui()
-  {
-    return (MethodConfigGui)this.getProperty(METHOD_CONFIG_GUI);
-  }
-
-  public void setHomeMethod(Method aMethod)
-  {
-    homeMethod = aMethod;
-  }
-
-  public Method getHomeMethod()
-  {
-    return homeMethod;
-  }
-
-  public void setRemoteMethod(Method aMethod)
-  {
-    remoteMethod = aMethod;
-  }
-
-  public Method getRemoteMethod()
-  {
-    return remoteMethod;
-  }
-
-  public void setReflectionStatus(boolean status)
-  { 
-    reflectionStatus = status;
-  }
-
-  public boolean getReflectionStatus()
-  {
-    return reflectionStatus;
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/JndiConfig.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/JndiConfig.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/JndiConfig.java	(working copy)
@@ -1,140 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.config;
-
-import java.io.Serializable;
-
-import javax.naming.InitialContext;
-
-import org.apache.jmeter.config.AbstractConfigElement;
-import org.apache.jmeter.config.ConfigElement;
-import org.apache.jmeter.ejb.jndi.config.LookupConfig;
-import org.apache.jmeter.util.JMeterUtils;
-import org.apache.log4j.Category;
-
-/**
- * Stores the configuration for JNDI sampling
- *
- * @author	Khor Soon Hin
- * Created	2001 Dec 17
- * @version $Revision$ Last Updated: $Date$
- */
-public class JndiConfig extends AbstractConfigElement implements Serializable
-{
-  private static Category catClass = Category.getInstance(
-	JndiConfig.class.getName());
-
-  public static final int JNDI_INITIAL_CONTEXT_FACTORY = 0;
-  public static final int JNDI_OBJECT_FACTORIES = 1;
-  public static final int JNDI_STATE_FACTORIES = 2;
-  public static final int JNDI_URL_PKG_PREFIXES = 3;
-  public static final int JNDI_PROVIDER_URL = 4;
-  public static final int JNDI_DNS_URL = 5;
-  public static final int JNDI_AUTHORITATIVE = 6;
-  public static final int JNDI_BATCHSIZE = 7;
-  public static final int JNDI_REFERRAL = 8;
-  public static final int JNDI_SECURITY_PROTOCOL = 9;
-  public static final int JNDI_SECURITY_AUTHENTICATION = 10;
-  public static final int JNDI_SECURITY_PRINCIPAL = 11;
-  public static final int JNDI_SECURITY_CREDENTIALS = 12;
-  public static final int JNDI_LANGUAGE = 13;
-  public static final int JNDI_APPLET = 14;
-
-  public static final String[] JNDI_PROPS = {
-	InitialContext.INITIAL_CONTEXT_FACTORY,
-	InitialContext.OBJECT_FACTORIES,
-	InitialContext.STATE_FACTORIES,
-	InitialContext.URL_PKG_PREFIXES,
-	InitialContext.PROVIDER_URL,
-	InitialContext.DNS_URL,
-	InitialContext.AUTHORITATIVE,
-	InitialContext.BATCHSIZE,
-	InitialContext.REFERRAL,
-	InitialContext.SECURITY_PROTOCOL,
-	InitialContext.SECURITY_AUTHENTICATION,
-	InitialContext.SECURITY_PRINCIPAL,
-	InitialContext.SECURITY_CREDENTIALS,
-	InitialContext.LANGUAGE,
-	InitialContext.APPLET
-	};
-
-  protected InitialContext initCtx = null;
-
-  public JndiConfig()
-  {
-  }
-
-  public Class getGuiClass()
-  {
-    return org.apache.jmeter.ejb.jndi.config.gui.JndiConfigGui.class;
-  }
-
-  public Object clone()
-  {
-    JndiConfig newConfig = new JndiConfig();
-    configureClone(newConfig);
-    return newConfig;
-  }
-
-  public String getValue(int i)
-  {
-    String string = (String)this.getProperty(JNDI_PROPS[i]);
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("getValue1 : int - " + i);
-      catClass.debug("getValue1 : name - " + JNDI_PROPS[i]);
-      catClass.debug("getValue1 : value - " + string);
-    }
-    return string;
-  }
-
-  public void setValue(int i, String string)
-  {
-    if(catClass.isDebugEnabled())
-    {
-      catClass.debug("setValue1 : int - " + i);
-      catClass.debug("setValue1 : name - " + JNDI_PROPS[i]);
-      catClass.debug("setValue1 : value - " + string);
-    }
-    this.putProperty(JNDI_PROPS[i], string);
-  }
-
-  public String getClassLabel()
-  {
-    return JMeterUtils.getResString("jndi_config_title");
-  }
-
-  public void addConfigElement(ConfigElement config)
-  {
-    if(config instanceof JndiConfig)
-    {
-      updatePropertyIfAbsent((JndiConfig)config);
-    }
-  }
-
-  public void setInitialContext(InitialContext initCtx)
-  {
-    this.initCtx = initCtx;
-  }
-
-  public InitialContext getInitialContext()
-  { 
-    return initCtx;
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/MethodConfigUserObjectException.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/MethodConfigUserObjectException.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/MethodConfigUserObjectException.java	(working copy)
@@ -1,41 +0,0 @@
-// $Header$
-/*
- * Copyright 2002-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.config;
-
-import java.lang.Exception;
-
-import org.apache.log4j.Category;
-/**
- * Exception thrown when creating MethodConfigUserObject if the value
- * is not compatible for the class.
- *
- * @author	Khor Soon Hin
- * @version	$Revision$ Last Updated: $Date$
- * Created	2002 Jan 08
- */
-public class MethodConfigUserObjectException extends Exception
-{
-  private static Category catClass = Category.getInstance(
-	MethodConfigUserObjectException.class.getName());
-
-  public MethodConfigUserObjectException(String string)
-  {
-    super(string);
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/MethodConfigUserObject.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/MethodConfigUserObject.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/config/MethodConfigUserObject.java	(working copy)
@@ -1,135 +0,0 @@
-// $Header$
-/*
- * Copyright 2001-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
-*/
-
-package org.apache.jmeter.ejb.jndi.config;
-
-import java.lang.Character;
-
-import org.apache.jmeter.ejb.jndi.config.MethodConfigUserObjectException;
-import org.apache.log4j.Category;
-/**
- * Given the class of the parameter and its string value this class will
- * attempt to create an appropriate object to represent it e.g. if given
- * a class of int and value 8, a Integer object with the 8 value will be
- * created.  Failing which a MethodConfigUserObjectException will be thrown.
- *
- * @author	Khor Soon Hin
- * @version $Revision$ Last Updated: $Date$
- * Created	2001 Jan 08
- */
-public class MethodConfigUserObject 
-{
-  private static Category catClass = Category.getInstance(
-	MethodConfigUserObject.class.getName());
-
-  protected static final String INTEGER = "int";
-  protected static final String LONG = "long";
-  protected static final String FLOAT = "float";
-  protected static final String DOUBLE = "double";
-  protected static final String BOOLEAN = "boolean";
-  protected static final String CHAR = "char";
-  protected static final String BYTE = "byte";
-  protected static final String SHORT = "short";
-  protected static final String STRING_CLASS = "java.lang.String";
-
-  protected Object object = null;
-  protected Class type = null;
-
-  public MethodConfigUserObject(Class type, String value)
-	throws MethodConfigUserObjectException
-  {
-    if(type == null || value == null)
-    {
-      throw new MethodConfigUserObjectException(
-	"Parameters of MethodConfigUserObject constructor cannot be null");
-    }
-    this.type = type;
-    // ensure that the class type is one of the 8 primitives
-    try
-    { 
-      if(type.getName().equals(INTEGER))
-      {
-        object = new Integer(value);
-      }
-      else if(type.getName().equals(LONG))
-      {
-        object = new Long(value);
-      }
-      else if(type.getName().equals(FLOAT))
-      {
-        object = new Float(value);
-      }
-      else if(type.getName().equals(DOUBLE))
-      {
-        object = new Double(value);
-      }
-      else if(type.getName().equals(BOOLEAN))
-      {
-        object = Boolean.valueOf(value);
-      }
-      else if(type.getName().equals(CHAR))
-      {
-        if(value.length() == 1)
-        {
-          object = new Character(value.charAt(0));
-        }
-        else
-        {
-          throw new MethodConfigUserObjectException(
-		"Value format not compatible with class");
-        }
-      }
-      else if(type.getName().equals(BYTE))
-      {
-        object = new Byte(value);
-      }
-      else if(type.getName().equals(SHORT))
-      {
-        object = new Short(value);
-      }
-      else if(type.getName().equals(STRING_CLASS))
-      {
-        object = new String(value);
-      }
-    }
-    catch(NumberFormatException e)
-    { 
-      throw new MethodConfigUserObjectException(
-	"Value format not compatible with class");
-    }
-  }
-
-  public Object getObject()
-  {
-    return object;
-  }
-
-  public Class getType()
-  {
-    return type;
-  }
-
-  public String toString()
-  {
-    StringBuffer strbuff = new StringBuffer();
-    strbuff.append(type.getName());
-    strbuff.append(" : ");
-    strbuff.append(object);
-    return strbuff.toString();
-  }
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/org/apache/jmeter/ejb/jndi/config/LookupConfig.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/org/apache/jmeter/ejb/jndi/config/LookupConfig.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/org/apache/jmeter/ejb/jndi/config/LookupConfig.java	(working copy)
@@ -20,9 +20,7 @@
 
 import java.io.Serializable;
 
-import org.apache.jmeter.config.AbstractConfigElement;
 import org.apache.jmeter.config.ConfigElement;
-import org.apache.jmeter.ejb.jndi.config.gui.LookupConfigGui;
 import org.apache.jmeter.util.JMeterUtils;
 import org.apache.log4j.Category;
 
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/org/apache/jmeter/ejb/jndi/config/gui/JndiConfigGui.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/org/apache/jmeter/ejb/jndi/config/gui/JndiConfigGui.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/org/apache/jmeter/ejb/jndi/config/gui/JndiConfigGui.java	(working copy)
@@ -18,20 +18,20 @@
 
 package org.apache.jmeter.ejb.jndi.config.gui;
 
-import javax.swing.*;
-import javax.swing.border.*;
-import java.awt.event.*;
-import javax.naming.InitialContext;
-import java.awt.*;
-import java.util.*;
+import java.awt.event.KeyEvent;
+import java.awt.event.KeyListener;
 
-import org.apache.jmeter.gui.ModelSupported;
+import javax.swing.BorderFactory;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JTextField;
+import javax.swing.border.Border;
+import javax.swing.border.EmptyBorder;
+
+import org.apache.jmeter.ejb.jndi.config.JndiConfig;
 import org.apache.jmeter.gui.NamePanel;
-import org.apache.jmeter.gui.VerticalLayout;
-import org.apache.jmeter.config.gui.ArgumentsPanel;
-import org.apache.jmeter.config.Arguments;
 import org.apache.jmeter.util.JMeterUtils;
-import org.apache.jmeter.ejb.jndi.config.JndiConfig;
+import org.apache.jorphan.gui.layout.VerticalLayout;
 import org.apache.log4j.Category;
 
 /**
Index: D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/org/apache/jmeter/ejb/jndi/config/MethodConfig.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/org/apache/jmeter/ejb/jndi/config/MethodConfig.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/protocol/jndi/org/apache/jmeter/ejb/jndi/config/MethodConfig.java	(working copy)
@@ -20,9 +20,7 @@
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
-import java.util.ArrayList;
 
-import org.apache.jmeter.config.AbstractConfigElement;
 import org.apache.jmeter.config.ConfigElement;
 import org.apache.jmeter.ejb.jndi.config.gui.MethodConfigGui;
 import org.apache.jmeter.util.JMeterUtils;
Index: D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/InterleaveControl.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/InterleaveControl.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/InterleaveControl.java	(working copy)
@@ -77,12 +77,13 @@
 	 * 
 	 * @see org.apache.jmeter.control.Controller#next()
 	 */
-	public Sampler next() {
+	public Sampler doNext() {
 		if (isSkipNext()) {
+            fireIterationEnd();
 			reInitialize();
 			return null;
 		}
-		return super.next();
+		return super.doNext();
 	}
 
 	/*
@@ -94,8 +95,8 @@
 		Sampler sampler = controller.next();
 		if (sampler == null) {
 			currentReturnedNull(controller);
-			return next();
-		}
+			return doNext();
+		} else {
 		currentReturnedAtLeastOne = true;
 		if (getStyle() == IGNORE_SUB_CONTROLLERS) {
 			incrementCurrent();
@@ -105,6 +106,7 @@
 		}
 		return sampler;
 	}
+	}
 
 	/*
 	 * (non-Javadoc)
@@ -123,9 +125,9 @@
 	 * 
 	 * @see org.apache.jmeter.testelement.AbstractTestElement#nextIsNull()
 	 */
-	protected Sampler nextIsNull() {
+	protected Sampler doNextIsNull() {
 		resetCurrent();
-		return next();
+		return doNext();
 	}
 
 	/*
Index: D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/TransactionController.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/TransactionController.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/TransactionController.java	(working copy)
@@ -67,7 +67,7 @@
 	/**
 	 * @see org.apache.jmeter.control.Controller#next()
 	 */
-	public Sampler next() {
+	public Sampler doNext() {
 		Sampler returnValue = null;
 		if (isFirst()) // must be the start of the subtree
 		{
@@ -79,7 +79,7 @@
 
 		calls++;
 
-		returnValue = super.next();
+		returnValue = super.doNext();
 
 		if (returnValue == null) // Must be the end of the controller
 		{
Index: D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/OnceOnlyController.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/OnceOnlyController.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/OnceOnlyController.java	(working copy)
@@ -45,7 +45,16 @@
 		}
 	}
 
-	protected Sampler nextIsNull() throws NextIsNullException {
+    /**
+     * @see LoopIterationListener#iterationEnd(LoopIterationEvent)
+     */
+    public void iterationEnd(LoopIterationEvent iterEvent) {
+    }
+
+    /**
+     * @see GenericController#nextIsNull()
+     */
+	protected Sampler doNextIsNull() {
 		return null;
 	}
 }
Index: D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/ForeachController.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/ForeachController.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/ForeachController.java	(working copy)
@@ -95,9 +95,9 @@
 	public boolean isDone() {
 		JMeterContext context = getThreadContext();
 		String inputVariable = getInputVal() + getSeparator() + (loopCount + 1);
-		if (context.getVariables().get(inputVariable) != null) {
-			context.getVariables().put(getReturnVal(), context.getVariables().get(inputVariable));
-			log.debug("ForEach resultstring isDone=" + context.getVariables().get(getReturnVal()));
+		if (context.getVariables().getObject(inputVariable) != null) {
+			context.getVariables().putObject(getReturnVal(), context.getVariables().getObject(inputVariable));
+			log.debug("ForEach resultstring isDone=" + context.getVariables().getObject(getReturnVal()));
 			return false;
 		}
 		return super.isDone();
@@ -106,7 +106,7 @@
 	private boolean endOfArguments() {
 		JMeterContext context = getThreadContext();
 		String inputVariable = getInputVal() + getSeparator() + (loopCount + 1);
-		if (context.getVariables().get(inputVariable) != null) {
+		if (context.getVariables().getObject(inputVariable) != null) {
 			log.debug("ForEach resultstring eofArgs= false");
 			return false;
 		}
@@ -115,12 +115,12 @@
 	}
 
 	// Prevent entry if nothing to do
-	public Sampler next() {
+	public Sampler doNext() {
 		if (emptyList()) {
 			reInitialize();
 			return null;
 		}
-		return super.next();
+		return super.doNext();
 	}
 
 	/**
@@ -131,26 +131,25 @@
 	private boolean emptyList() {
 		JMeterContext context = getThreadContext();
 		String inputVariable = getInputVal() + getSeparator() + "1";
-		if (context.getVariables().get(inputVariable) != null) {
+		if (context.getVariables().getObject(inputVariable) != null) {
 			return false;
 		}
 		log.debug("No entries found - null first entry: " + inputVariable);
 		return true;
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.jmeter.control.GenericController#nextIsNull()
+	/**
+     * @see org.apache.jmeter.control.GenericController#doNextIsNull()
 	 */
-	protected Sampler nextIsNull() throws NextIsNullException {
+	protected Sampler doNextIsNull() {
 		reInitialize();
 		if (endOfArguments()) {
 			// setDone(true);
 			resetLoopCount();
 			return null;
+		} else {
+			return doNext();
 		}
-		return next();
 	}
 
 	protected void incrementLoopCount() {
Index: D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/ThroughputController.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/ThroughputController.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/control/ThroughputController.java	(working copy)
@@ -165,9 +165,10 @@
 	protected int getExecutions() {
 		if (!isPerThread()) {
 			return globalNumExecutions;
-		}
+		} else {
 		return numExecutions;
 	}
+	}
 
 	private void increaseExecutions() {
 		setExecutions(getExecutions() + 1);
@@ -183,9 +184,10 @@
 	protected int getIteration() {
 		if (!isPerThread()) {
 			return globalIteration;
-		}
+		} else {
 		return iteration;
 	}
+	}
 
 	private void increaseIteration() {
 		setIteration(getIteration() + 1);
@@ -194,9 +196,9 @@
 	/**
 	 * @see org.apache.jmeter.control.Controller#next()
 	 */
-	public Sampler next() {
+	public Sampler doNext() {
 		if (runThisTime) {
-			return super.next();
+			return super.doNext();
 		}
 		return null;
 	}
@@ -211,9 +213,10 @@
 		iterations = getIteration();
 		if (getStyle() == BYNUMBER) {
 			return executions < getMaxThroughputAsInt();
-		}
+		} else {
 		return (100.0 * executions + 50.0) / (iterations + 1) < getPercentThroughputAsFloat();
 	}
+	}
 
 	/**
 	 * @see org.apache.jmeter.control.Controller#isDone()
@@ -245,10 +248,8 @@
 		counterLock = new Object();
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see LoopIterationListener#iterationStart(LoopIterationEvent)
+	/**
+     * @see LoopIterationListener#iterationStart(LoopIterationEvent)
 	 */
 	public void iterationStart(LoopIterationEvent iterEvent) {
 		if (!isPerThread()) {
@@ -266,43 +267,38 @@
 		}
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.jmeter.testelement.TestListener#testStarted()
+    /**
+     * @see LoopIterationListener#iterationEnd(LoopIterationEvent)
+     */
+    public void iterationEnd(LoopIterationEvent iterEvent) {        
+    }
+
+	/**
+     * @see org.apache.jmeter.testelement.TestListener#testStarted()
 	 */
 	public void testStarted() {
 		setExecutions(0);
 		setIteration(-1);
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.jmeter.testelement.TestListener#testEnded()
+	/**@see org.apache.jmeter.testelement.TestListener#testEnded()
 	 */
 	public void testEnded() {
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
+	/**
 	 * @see TestListener#testStarted(String)
 	 */
 	public void testStarted(String host) {
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
+	/**
 	 * @see TestListener#testEnded(String)
 	 */
 	public void testEnded(String host) {
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
+	/**
 	 * @see TestListener#testIterationStart(LoopIterationEvent)
 	 */
 	public void testIterationStart(LoopIterationEvent event) {
Index: D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/modifiers/UserParameters.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/modifiers/UserParameters.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/modifiers/UserParameters.java	(working copy)
@@ -157,6 +157,13 @@
 			setValues();
 		}
 	}
+    
+    /**
+     * @see LoopIterationListener#iterationEnd(LoopIterationEvent)
+     */
+    public void iterationEnd(LoopIterationEvent iterEvent) {
+     
+    }
 
 	/*
 	 * (non-Javadoc) A new instance is created for each thread group, and the
Index: D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/modifiers/CounterConfig.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/modifiers/CounterConfig.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/modifiers/CounterConfig.java	(working copy)
@@ -80,6 +80,12 @@
             perTheadNumber.set(new Long(current));
 		}
 	}
+    
+    /**
+     * @see LoopIterationListener#iterationEnd(LoopIterationEvent)
+     */
+    public synchronized void iterationEnd(LoopIterationEvent event) {
+    }
 
     // Use format to create number; if it fails, use the default
     private String formatNumber(long value){
Index: D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/timers/ConstantTimer.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/timers/ConstantTimer.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/timers/ConstantTimer.java	(working copy)
@@ -105,6 +105,12 @@
 		delay = getPropertyAsLong(DELAY);
 
 	}
+    
+    /**
+     * @see LoopIterationListener#iterationEnd(LoopIterationEvent)
+     */
+    public void iterationEnd(LoopIterationEvent event) {
+    }
 
 	/*
 	 * This method doesn't appear to be used anymore. jeremy_a@bigfoot.com 02
Index: D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/config/CSVDataSet.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/config/CSVDataSet.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/components/org/apache/jmeter/config/CSVDataSet.java	(working copy)
@@ -52,12 +52,12 @@
     
 	transient private String[] vars;
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.jmeter.engine.event.LoopIterationListener#iterationStart(org.apache.jmeter.engine.event.LoopIterationEvent)
+	/**
+     * @see LoopIterationListener#iterationStart(org.apache.jmeter.engine.event.LoopIterationEvent)
 	 */
 	public void iterationStart(LoopIterationEvent iterEvent) {
+        log.debug("iteration start for " + this.getName());
+        
 		FileServer server = FileServer.getFileServer();
 		if (vars == null) {
 			server.reserveFile(getFilename());
@@ -84,6 +84,13 @@
 			log.error(e.toString());
 		}
 	}
+    
+    /**
+     * @see LoopIterationListener#iterationEnd(org.apache.jmeter.engine.event.LoopIterationEvent)
+     */
+    public void iterationEnd(LoopIterationEvent iterEvent) {
+        log.debug("iteration end  for " + this.getName());
+    }
 
 	/**
 	 * @return Returns the filename.
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/GenericController.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/GenericController.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/GenericController.java	(working copy)
@@ -79,9 +79,15 @@
 	/**
 	 * @see org.apache.jmeter.control.Controller#next()
 	 */
-	public Sampler next() {
+	public final Sampler next() {
 		fireIterEvents();
 		log.debug("Calling next on: " + this.getClass().getName());
+		Sampler returnValue = doNext();
+		return returnValue;
+	}
+	
+	protected Sampler doNext()
+	{
 		if (isDone())
 			return null;
 		Sampler returnValue = null;
@@ -141,11 +147,19 @@
 		return element;
 	}
 
-	protected Sampler nextIsNull() throws NextIsNullException {
-		reInitialize();
-		return null;
+	protected final Sampler nextIsNull() throws NextIsNullException {
+        fireIterationEnd();
+        return doNextIsNull();
 	}
 
+    /**
+     * @return
+     */
+    protected Sampler doNextIsNull() {
+        reInitialize();
+        return null;
+    }
+
 	protected void currentReturnedNull(Controller c) {
 		if (c.isDone()) {
 			removeCurrentElement();
@@ -225,6 +239,17 @@
 		}
 	}
 
+	protected void fireIterationEnd()
+	{
+		Iterator iter = iterationListeners.iterator();
+		LoopIterationEvent event = new LoopIterationEvent(this, getIterCount());
+		while(iter.hasNext())
+		{
+			LoopIterationListener item = (LoopIterationListener)iter.next();
+			item.iterationEnd(event);
+		}
+	}
+
 	protected int getIterCount() {
 		return iterCount;
 	}
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/IfController.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/IfController.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/IfController.java	(working copy)
@@ -144,11 +144,11 @@
 	 *      time this is run. The first time is special cause it is called prior
 	 *      the iteration even starts !
 	 */
-	public Sampler next() {
+	public Sampler doNext() {
 		boolean result = evaluateCondition(getCondition());
-		if (result) {
-			return super.next();
-		}
+		if (result)
+			return super.doNext();
+		else
 		try {
 			return nextIsNull();
 		} catch (NextIsNullException e1) {
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/RunTime.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/RunTime.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/RunTime.java	(working copy)
@@ -73,29 +73,29 @@
 		return System.currentTimeMillis() - startTime >= 1000 * getRuntime();
 	}
 
-	public Sampler next() {
+	public Sampler doNext() {
 		if (startTime == 0)
 			startTime = System.currentTimeMillis();
 		if (endOfLoop()) {
+            fireIterationEnd();
 			reInitialize();// ??
 			resetLoopCount();
 			return null;
 		}
-		return super.next();
+		return super.doNext();
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.jmeter.control.GenericController#nextIsNull()
+	/**
+     * @see org.apache.jmeter.control.GenericController#doNextIsNull()
 	 */
-	protected Sampler nextIsNull() throws NextIsNullException {
-		reInitialize();
+	protected Sampler doNextIsNull() {
+        reInitialize();
 		if (endOfLoop()) {
 			resetLoopCount();
 			return null;
+		} else {
+			return doNext();
 		}
-		return next();
 	}
 
 	protected void incrementLoopCount() {
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/WhileController.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/WhileController.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/WhileController.java	(working copy)
@@ -31,109 +31,109 @@
  * @version $Revision$
  */
 public class WhileController extends GenericController implements Serializable {
-	private static Logger log = LoggingManager.getLoggerForClass();
+    private static Logger log = LoggingManager.getLoggerForClass();
 
-	private final static String CONDITION = "WhileController.condition"; // $NON-NLS-1$
+    private final static String CONDITION = "WhileController.condition"; // $NON-NLS-1$
 
-	static boolean testMode = false; // To make testing easier
+    static boolean testMode = false; // To make testing easier
 
-	static boolean testModeResult = false; // dummy sample result
+    static boolean testModeResult = false; // dummy sample result
 
-	public WhileController() {
-	}
+    public WhileController() {
+    }
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.jmeter.control.Controller#isDone()
-	 */
-	public boolean isDone() {
-		if (getSubControllers().size() == 0) // Nothing left to run
-		{
-			return true;
-		}
-		return false;// Never want to remove the controller from the tree
-	}
+    /*
+     * (non-Javadoc)
+     * 
+     * @see org.apache.jmeter.control.Controller#isDone()
+     */
+    public boolean isDone() {
+        if (getSubControllers().size() == 0) // Nothing left to run
+        {
+            return true;
+        }
+        return false;// Never want to remove the controller from the tree
+    }
 
-	/*
-	 * Evaluate the condition, which can be: blank or LAST = was the last
-	 * sampler OK? otherwise, evaluate the condition to see if it is not "false"
-	 * If blank, only evaluate at the end of the loop
-	 * 
-	 * Must only be called at start and end of loop
-	 * 
-	 * @param loopEnd - are we at loop end? @return true means OK to continue
-	 */
-	private boolean endOfLoop(boolean loopEnd) {
-		String cnd = getCondition();
-		log.debug("Condition string:" + cnd);
-		boolean res;
-		// If blank, only check previous sample when at end of loop
-		if ((loopEnd && cnd.length() == 0) || "LAST".equalsIgnoreCase(cnd)) {// $NON-NLS-1$
-			if (testMode) {
-				res = !testModeResult;
-			} else {
-				JMeterVariables threadVars = JMeterContextService.getContext().getVariables();
-				// Use !false rather than true, so that null is treated as true
-				res = "false".equalsIgnoreCase(threadVars.get(JMeterThread.LAST_SAMPLE_OK));// $NON-NLS-1$
-			}
-		} else {
-			// cnd may be blank if next() called us
-			res = "false".equalsIgnoreCase(cnd);// $NON-NLS-1$
-		}
-		log.debug("Condition value: " + res);
-		return res;
-	}
+    /*
+     * Evaluate the condition, which can be: blank or LAST = was the last
+     * sampler OK? otherwise, evaluate the condition to see if it is not "false"
+     * If blank, only evaluate at the end of the loop
+     * 
+     * Must only be called at start and end of loop
+     * 
+     * @param loopEnd - are we at loop end? @return true means OK to continue
+     */
+    private boolean endOfLoop(boolean loopEnd) {
+        String cnd = getCondition();
+        log.debug("Condition string:" + cnd);
+        boolean res;
+        // If blank, only check previous sample when at end of loop
+        if ((loopEnd && cnd.length() == 0) || "LAST".equalsIgnoreCase(cnd)) {// $NON-NLS-1$
+            if (testMode) {
+                res = !testModeResult;
+            } else {
+                JMeterVariables threadVars = JMeterContextService.getContext().getVariables();
+                // Use !false rather than true, so that null is treated as true
+                res = "false".equalsIgnoreCase(threadVars.get(JMeterThread.LAST_SAMPLE_OK));// $NON-NLS-1$
+            }
+        } else {
+            // cnd may be blank if next() called us
+            res = "false".equalsIgnoreCase(cnd);// $NON-NLS-1$
+        }
+        log.debug("Condition value: " + res);
+        return res;
+    }
 
-	/*
-	 * (non-Javadoc) Only called at End of Loop
-	 * 
-	 * @see org.apache.jmeter.control.GenericController#nextIsNull()
-	 */
-	protected Sampler nextIsNull() throws NextIsNullException {
-		reInitialize();
-		if (!endOfLoop(true)) {
-			return super.next();
-		}
-		setDone(true);
-		return null;
-	}
+    /**
+     * @see org.apache.jmeter.control.GenericController#doNextIsNull()
+     */
+    protected Sampler doNextIsNull() {
+        reInitialize();
+        if (!endOfLoop(true)) {
+            return super.next();
+        }
+        setDone(true);
+        return null;
+    }
 
-	/*
-	 * This skips controller entirely if the condition is false
-	 * 
-	 * TODO consider checking for previous sampler failure here - would need to
-	 * distinguish this from previous failure *inside* loop
-	 * 
-	 */
-	public Sampler next() {
-		if (current != 0) { // in the middle of the loop
-			return super.next();
-		}
-		// Must be start of loop
-		if (!endOfLoop(false)) {
-			return super.next(); // OK to continue
-		}
-		reInitialize(); // Don't even start the loop
-		return null;
-	}
+    /*
+     * This skips controller entirely if the condition is false
+     * 
+     * TODO consider checking for previous sampler failure here - would need to
+     * distinguish this from previous failure *inside* loop
+     * 
+     */
+    public Sampler doNext() {
+        if (current != 0) { // in the middle of the loop
+            return super.doNext();
+        }
+        // Must be start of loop
+        if (!endOfLoop(false)) {
+            return super.doNext(); // OK to continue
+        } else {
+            fireIterationEnd();
+            reInitialize(); // Don't even start the loop
+            return null;
+        }
+    }
 
-	/**
-	 * @param string
-	 *            the condition to save
-	 */
-	public void setCondition(String string) {
-		log.debug("setCondition(" + string + ")");
-		setProperty(new StringProperty(CONDITION, string));
-	}
+    /**
+     * @param string
+     *            the condition to save
+     */
+    public void setCondition(String string) {
+        log.debug("setCondition(" + string + ")");
+        setProperty(new StringProperty(CONDITION, string));
+    }
 
-	/**
-	 * @return the condition
-	 */
-	public String getCondition() {
-		String cnd;
-		cnd = getPropertyAsString(CONDITION);
-		log.debug("getCondition() => " + cnd);
-		return cnd;
-	}
+    /**
+     * @return the condition
+     */
+    public String getCondition() {
+        String cnd;
+        cnd = getPropertyAsString(CONDITION);
+        log.debug("getCondition() => " + cnd);
+        return cnd;
+    }
 }
\ No newline at end of file
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/LoopController.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/LoopController.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/control/LoopController.java	(working copy)
@@ -93,22 +93,23 @@
 		return (getLoops() > -1) && loopCount >= getLoops();
 	}
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.jmeter.control.GenericController#nextIsNull()
+	/**
+	 * @see org.apache.jmeter.control.GenericController#doNextIsNull()
 	 */
-	protected Sampler nextIsNull() throws NextIsNullException {
-		reInitialize();
+	protected Sampler doNextIsNull() {
+        reInitialize();
 		if (endOfLoop()) {
 			if (!getContinueForever()) {
 				setDone(true);
 			} else {
 				resetLoopCount();
 			}
+            resetCurrent();
 			return null;
+		} else {
+			//super.fireIterationStart();
+			return doNext();
 		}
-		return next();
 	}
 
 	protected void incrementLoopCount() {
@@ -134,9 +135,9 @@
 	 * @see org.apache.jmeter.control.GenericController#reInitialize()
 	 */
 	protected void reInitialize() {
-		setFirst(true);
 		resetCurrent();
 		incrementLoopCount();
+        setFirst(true);
 		recoverRunningVersion();
 	}
 }
\ No newline at end of file
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/services/FileServer.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/services/FileServer.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/services/FileServer.java	(working copy)
@@ -112,7 +112,7 @@
 		}
 	}
 
-   /**
+	/**
 	 * Get the next line of the named file, recycle by default.
 	 *
      * @param filename
@@ -126,7 +126,7 @@
    /**
 	 * Get the next line of the named file.
 	 * 
-     * @param filename
+	 * @param filename
      * @param recycle - should file be restarted at EOF?
 	 * @return String containing the next line in the file (null if EOF reached and not recycle)
 	 * @throws IOException
@@ -191,7 +191,12 @@
     private void closeFile(String name, FileEntry fileEntry) throws IOException {
         if (fileEntry != null && fileEntry.inputOutputObject != null) {
             log.info("Close: "+name);
-			((Reader) fileEntry.inputOutputObject).close();
+            if (fileEntry.inputOutputObject instanceof Reader)
+                ((Reader) fileEntry.inputOutputObject).close();
+            else if (fileEntry.inputOutputObject instanceof Writer)
+                ((Writer) fileEntry.inputOutputObject).close();
+            else 
+                log.error("Unknow inputOutputObject type : " + fileEntry.inputOutputObject.getClass());
 			fileEntry.inputOutputObject = null;
 		}
     }
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/TestBeanPropertyEditor.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/TestBeanPropertyEditor.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/TestBeanPropertyEditor.java	(revision 0)
@@ -0,0 +1,10 @@
+package org.apache.jmeter.testbeans.gui;
+
+import java.beans.PropertyDescriptor;
+import java.beans.PropertyEditor;
+
+public interface TestBeanPropertyEditor extends PropertyEditor {
+	
+	public void setDescriptor(PropertyDescriptor descriptor);
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/GenericTestBeanCustomizer.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/GenericTestBeanCustomizer.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/GenericTestBeanCustomizer.java	(working copy)
@@ -225,6 +225,10 @@
 					log.debug("Editor for property " + name + " is wrapped in " + propertyEditor);
 				}
 			}
+			if(propertyEditor instanceof TestBeanPropertyEditor)
+			{
+				((TestBeanPropertyEditor)propertyEditor).setDescriptor(descriptors[i]);
+			}
 			if (propertyEditor.getCustomEditor() instanceof JScrollPane) {
 				scrollerCount++;
 			}
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/TestBeanGUI.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/TestBeanGUI.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/TestBeanGUI.java	(working copy)
@@ -241,7 +241,7 @@
 					element.removeProperty(name);
 				}
 			} else {
-				setPropertyInElement(element, name, propertyMap.get(name));
+				setPropertyInElement(element, name, value);
 			}
 		}
 	}
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/TableEditor.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/TableEditor.java	(revision 0)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/gui/TableEditor.java	(revision 0)
@@ -0,0 +1,274 @@
+package org.apache.jmeter.testbeans.gui;
+
+import java.awt.BorderLayout;
+import java.awt.Component;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.FocusEvent;
+import java.awt.event.FocusListener;
+import java.beans.PropertyDescriptor;
+import java.beans.PropertyEditorSupport;
+import java.lang.reflect.Method;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+
+import javax.swing.CellEditor;
+import javax.swing.JButton;
+import javax.swing.JComponent;
+import javax.swing.JPanel;
+import javax.swing.JScrollPane;
+import javax.swing.JTable;
+import javax.swing.ListSelectionModel;
+import javax.swing.event.TableModelEvent;
+import javax.swing.event.TableModelListener;
+
+import org.apache.jmeter.testelement.property.TestElementProperty;
+import org.apache.jmeter.util.JMeterUtils;
+import org.apache.jorphan.gui.ObjectTableModel;
+import org.apache.jorphan.logging.LoggingManager;
+import org.apache.jorphan.reflect.Functor;
+import org.apache.log.Logger;
+
+public class TableEditor extends PropertyEditorSupport implements FocusListener,TestBeanPropertyEditor,TableModelListener{
+	Logger log = LoggingManager.getLoggerForClass();
+	
+	public static final String CLASSNAME = "tableObject.classname";
+	public static final String HEADERS = "table.headers";
+	public static final String OBJECT_PROPERTIES = "tableObject.properties";
+	
+	JTable table;
+	ObjectTableModel model;
+	Class clazz;
+	PropertyDescriptor descriptor;
+	JButton addButton,removeButton,clearButton;
+
+	public TableEditor() {
+		addButton = new JButton(JMeterUtils.getResString("add"));
+		addButton.addActionListener(new AddListener());
+		removeButton = new JButton(JMeterUtils.getResString("remove"));
+		removeButton.addActionListener(new RemoveListener());
+		clearButton = new JButton(JMeterUtils.getResString("clear"));
+		clearButton.addActionListener(new ClearListener());
+	}
+
+	/* (non-Javadoc)
+	 * @see java.beans.PropertyEditor#getAsText()
+	 */
+	public String getAsText() {
+		return null;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.beans.PropertyEditor#getCustomEditor()
+	 */
+	public Component getCustomEditor() {
+		JComponent pane = makePanel();
+		pane.doLayout();
+		pane.validate();
+		return pane;
+	}
+	
+	private JComponent makePanel()
+	{
+		JPanel p = new JPanel(new BorderLayout());
+		JScrollPane scroller = new JScrollPane(table);
+		scroller.setPreferredSize(scroller.getMinimumSize());
+		p.add(scroller,BorderLayout.CENTER);
+		JPanel south = new JPanel();
+		south.add(addButton);
+		south.add(removeButton);
+		south.add(clearButton);
+		p.add(south,BorderLayout.SOUTH);
+		return p;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.beans.PropertyEditor#getValue()
+	 */
+	public Object getValue() {
+		return model.getObjectList();
+	}
+
+	/* (non-Javadoc)
+	 * @see java.beans.PropertyEditor#setAsText(java.lang.String)
+	 */
+	public void setAsText(String text) throws IllegalArgumentException {
+		//not interested in this method.		
+	}
+
+	/* (non-Javadoc)
+	 * @see java.beans.PropertyEditor#setValue(java.lang.Object)
+	 */
+	public void setValue(Object value) {
+		if(value != null)
+		{
+			model.setRows(convertCollection((Collection)value));
+		}
+		else model.clearData();
+		this.firePropertyChange();
+	}
+	
+	private Collection convertCollection(Collection values)
+	{
+		List l = new LinkedList();
+        for (Iterator iter = values.iterator(); iter.hasNext();) {
+            Object obj = iter.next();
+            if(obj instanceof TestElementProperty)
+			{
+				l.add(((TestElementProperty)obj).getElement());
+			}
+			else
+			{
+				l.add(obj);
+			}
+		}
+		return l;
+	}
+
+	/* (non-Javadoc)
+	 * @see java.beans.PropertyEditor#supportsCustomEditor()
+	 */
+	public boolean supportsCustomEditor() {
+		return true;
+	}
+
+	/**
+	 * For the table editor, the tag must simply be the name of the class of object it will hold 
+	 * where each row holds one object. 
+	 */
+	public void setDescriptor(PropertyDescriptor descriptor) {
+		try {
+			this.descriptor = descriptor;
+			clazz = Class.forName((String)descriptor.getValue(CLASSNAME));
+			initializeModel();
+		} catch (ClassNotFoundException e) {
+			throw new RuntimeException("The Table Editor requires one TAG be set - the name of the object to represent a row",e);
+		}
+	}
+	
+	void initializeModel()
+	{
+		if(clazz == String.class)
+		{
+			model = new ObjectTableModel((String[])descriptor.getValue(HEADERS),new Functor[0],new Functor[0],new Class[]{String.class});
+			model.addTableModelListener(this);
+		}
+		else
+		{
+			String[] props = (String[])descriptor.getValue(OBJECT_PROPERTIES);
+			Functor[] writers = new Functor[props.length];
+			Functor[] readers = new Functor[props.length];
+			Class[] editors = new Class[props.length];
+			int count = 0;
+            for (int i = 0; i < props.length; i++) {
+                String propName = props[i];
+				propName = propName.substring(0,1).toUpperCase() + propName.substring(1);
+				writers[count] = createWriter(clazz,propName);
+				readers[count] = createReader(clazz,propName);
+				editors[count] = getArgForWriter(clazz,propName);
+				count++;
+			}
+			model = new ObjectTableModel((String[])descriptor.getValue(HEADERS),readers,writers,editors);
+			model.addTableModelListener(this);
+		}
+		table = new JTable(model);
+		table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+		table.addFocusListener(this);
+	}
+	
+	Functor createWriter(Class c,String propName)
+	{
+		String setter = "set" + propName;
+		return new Functor(setter);
+	}
+	
+	Functor createReader(Class c,String propName)
+	{
+		String getter = "get" + propName;
+		try
+		{
+			c.getMethod(getter,new Class[0]);
+			return new Functor(getter);
+		}
+		catch(Exception e) { return new Functor("is" + propName); }
+	}
+	
+	Class getArgForWriter(Class c,String propName)
+	{
+		String setter = "set" + propName;
+        for (int i = 0; i < c.getMethods().length; i++) {
+            Method m = c.getMethods()[i];
+			if(m.getName().equals(setter))
+			{
+				return m.getParameterTypes()[0];
+			}
+		}
+		return null;
+	}
+
+	/* (non-Javadoc)
+	 * @see javax.swing.event.TableModelListener#tableChanged(javax.swing.event.TableModelEvent)
+	 */
+	public void tableChanged(TableModelEvent e) {
+		this.firePropertyChange();		
+	}
+
+	/* (non-Javadoc)
+	 * @see java.awt.event.FocusListener#focusGained(java.awt.event.FocusEvent)
+	 */
+	public void focusGained(FocusEvent e) {
+		
+	}
+
+	/* (non-Javadoc)
+	 * @see java.awt.event.FocusListener#focusLost(java.awt.event.FocusEvent)
+	 */
+	public void focusLost(FocusEvent e) {
+		if (table.getEditingColumn() >= 0 && table.getEditingRow() > 0) {
+			CellEditor ce = table.getCellEditor(table.getEditingRow(),table.getEditingColumn());
+			Component editor = table.getEditorComponent();
+			if(ce != null && (editor == null || editor != e.getOppositeComponent()))
+			{
+				ce.stopCellEditing();
+			}
+			else if(editor != null)
+			{
+				editor.addFocusListener(this);
+			}
+			this.firePropertyChange();
+		}
+	}
+	
+	private class AddListener implements ActionListener
+	{
+		public void actionPerformed(ActionEvent e)
+		{
+			try
+			{
+				model.addRow(clazz.newInstance());
+			}catch(Exception err)
+			{
+				log.error("The class type given to TableEditor was not instantiable. ",err);
+			}
+		}
+	}
+	
+	private class RemoveListener implements ActionListener
+	{
+		public void actionPerformed(ActionEvent e)
+		{
+			model.removeRow(table.getSelectedRow());
+		}
+	}
+	
+	private class ClearListener implements ActionListener
+	{
+		public void actionPerformed(ActionEvent e)
+		{
+			model.clearData();
+		}
+	}
+
+}
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/TestBeanHelper.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/TestBeanHelper.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testbeans/TestBeanHelper.java	(working copy)
@@ -1,127 +0,0 @@
-/*
- * Copyright 2004 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not
- * use this file except in compliance with the License. You may obtain a copy
- * of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package org.apache.jmeter.testbeans;
-
-import java.beans.BeanInfo;
-import java.beans.IntrospectionException;
-import java.beans.Introspector;
-import java.beans.PropertyDescriptor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-
-import org.apache.jmeter.testelement.TestElement;
-import org.apache.jmeter.testelement.property.JMeterProperty;
-import org.apache.jorphan.logging.LoggingManager;
-import org.apache.jorphan.util.Converter;
-import org.apache.log.Logger;
-
-/**
- * This is an experimental class. An attempt to address the complexity of
- * writing new JMeter components.
- * <p>
- * TestBean currently extends AbstractTestElement to support
- * backward-compatibility, but the property-value-map may later on be separated
- * from the test beans themselves. To ensure this will be doable with minimum
- * damage, all inherited methods are deprecated.
- * 
- * @author <a href="mailto:jsalvata@apache.org">Jordi Salvat i Alabart </a>
- * @version $Revision$ updated on $Date$
- */
-public class TestBeanHelper {
-	protected static final Logger log = LoggingManager.getLoggerForClass();
-
-	/**
-	 * Prepare the bean for work by populating the bean's properties from the
-	 * property value map.
-	 * <p>
-	 * 
-	 * @deprecated to limit it's usage in expectation of moving it elsewhere.
-	 */
-	public static void prepare(TestElement el) {
-		if (!(el instanceof TestBean)) {
-			return;
-		}
-		try {
-			BeanInfo beanInfo = Introspector.getBeanInfo(el.getClass());
-			PropertyDescriptor[] desc = beanInfo.getPropertyDescriptors();
-			Object[] param = new Object[1];
-
-			if (log.isDebugEnabled())
-				log.debug("Preparing " + el.getClass());
-
-			for (int x = 0; x < desc.length; x++) {
-				// Obtain a value of the appropriate type for this property.
-				JMeterProperty jprop = el.getProperty(desc[x].getName());
-				Class type = desc[x].getPropertyType();
-				Object value = Converter.convert(jprop.getStringValue(), type);
-
-				if (log.isDebugEnabled())
-					log.debug("Setting " + jprop.getName() + "=" + value);
-
-				// Set the bean's property to the value we just obtained:
-				if (value != null || !type.isPrimitive())
-				// We can't assign null to primitive types.
-				{
-					param[0] = value;
-					Method writeMethod = desc[x].getWriteMethod();
-					if (writeMethod!=null) invokeOrBailOut(el, writeMethod, param);
-				}
-			}
-		} catch (IntrospectionException e) {
-			log.error("Couldn't set properties for " + el.getClass().getName(), e);
-		}
-	}
-
-	/**
-	 * Utility method that invokes a method and does the error handling around
-	 * the invocation.
-	 * 
-	 * @param method
-	 * @param params
-	 * @return the result of the method invocation.
-	 */
-	private static Object invokeOrBailOut(Object invokee, Method method, Object[] params) {
-		try {
-			return method.invoke(invokee, params);
-		} catch (IllegalArgumentException e) {
-			log.error("This should never happen.", e);
-			throw new Error(e.toString()); // Programming error: bail out.
-		} catch (IllegalAccessException e) {
-			log.error("This should never happen.", e);
-			throw new Error(e.toString()); // Programming error: bail out.
-		} catch (InvocationTargetException e) {
-			log.error("This should never happen.", e);
-			throw new Error(e.toString()); // Programming error: bail out.
-		}
-	}
-
-	/**
-	 * Utility method to obtain the value of a property in the given type.
-	 * <p>
-	 * I plan to get rid of this sooner than later, so please don't use it much.
-	 * 
-	 * @param property
-	 *            Property to get the value of.
-	 * @param type
-	 *            Type of the result.
-	 * @return an object of the given type if it is one of the known supported
-	 *         types, or the value returned by property.getObjectValue
-	 * @deprecated
-	 */
-	private static Object unwrapProperty(JMeterProperty property, Class type) {
-		return Converter.convert(property.getObjectValue(), type);
-	}
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testelement/property/CollectionProperty.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testelement/property/CollectionProperty.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testelement/property/CollectionProperty.java	(working copy)
@@ -1,208 +0,0 @@
-/*
- * Copyright 2003-2004 The Apache Software Foundation.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *   http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- * 
- */
-
-package org.apache.jmeter.testelement.property;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-
-import org.apache.jmeter.testelement.TestElement;
-
-/**
- * @version $Revision$
- */
-public class CollectionProperty extends MultiProperty {
-	private Collection value;
-
-	transient private Collection savedValue;
-
-	public CollectionProperty(String name, Collection value) {
-		super(name);
-		this.value = normalizeList(value);
-	}
-
-	public CollectionProperty() {
-		super();
-		value = new ArrayList();
-	}
-
-	public boolean equals(Object o) {
-		if (o instanceof CollectionProperty) {
-			if (value != null) {
-				return value.equals(((JMeterProperty) o).getObjectValue());
-			}
-		}
-		return false;
-	}
-
-	public int hashCode() {
-		return (value == null ? 0 : value.hashCode());
-	}
-
-	public void remove(String prop) {
-		PropertyIterator iter = iterator();
-		while (iter.hasNext()) {
-			if (iter.next().getName().equals(prop)) {
-				iter.remove();
-			}
-		}
-	}
-
-	public void set(int index, String prop) {
-		if (value instanceof List) {
-			((List) value).set(index, new StringProperty(prop, prop));
-		}
-	}
-
-	public void set(int index, JMeterProperty prop) {
-		if (value instanceof List) {
-			((List) value).set(index, prop);
-		}
-	}
-
-	public JMeterProperty get(int row) {
-		if (value instanceof List) {
-			return (JMeterProperty) ((List) value).get(row);
-		}
-		return null;
-	}
-
-	public void remove(int index) {
-		if (value instanceof List) {
-			((List) value).remove(index);
-		}
-	}
-
-	public void setObjectValue(Object v) {
-		if (v instanceof Collection) {
-			setCollection((Collection) v);
-		}
-
-	}
-
-	public PropertyIterator iterator() {
-		return getIterator(value);
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see JMeterProperty#getStringValue()
-	 */
-	public String getStringValue() {
-		return value.toString();
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see JMeterProperty#getObjectValue()
-	 */
-	public Object getObjectValue() {
-		return value;
-	}
-
-	public int size() {
-		return value.size();
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see Object#clone()
-	 */
-	public Object clone() {
-		CollectionProperty prop = (CollectionProperty) super.clone();
-		prop.value = cloneCollection();
-		return prop;
-	}
-
-	private Collection cloneCollection() {
-		try {
-			Collection newCol = (Collection) value.getClass().newInstance();
-			PropertyIterator iter = iterator();
-			while (iter.hasNext()) {
-				newCol.add(iter.next().clone());
-			}
-			return newCol;
-		} catch (Exception e) {
-			log.error("Couldn't clone collection", e);
-			return value;
-		}
-	}
-
-	public void setCollection(Collection coll) {
-		value = normalizeList(coll);
-	}
-
-	public void clear() {
-		value.clear();
-	}
-
-	/**
-	 * Easy way to add properties to the list.
-	 * 
-	 * @param prop
-	 */
-	public void addProperty(JMeterProperty prop) {
-		value.add(prop);
-	}
-
-	public void addItem(Object item) {
-		addProperty(convertObject(item));
-	}
-
-	/**
-	 * Figures out what kind of properties this collection is holding and
-	 * returns the class type.
-	 * 
-	 * @see AbstractProperty#getPropertyType()
-	 */
-	protected Class getPropertyType() {
-		if (value.size() > 0) {
-			return value.iterator().next().getClass();
-		}
-		return NullProperty.class;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see JMeterProperty#recoverRunningVersion(TestElement)
-	 */
-	public void recoverRunningVersion(TestElement owner) {
-		if (savedValue != null) {
-			value = savedValue;
-		}
-		recoverRunningVersionOfSubElements(owner);
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see JMeterProperty#setRunningVersion(boolean)
-	 */
-	public void setRunningVersion(boolean running) {
-		super.setRunningVersion(running);
-		if (running) {
-			savedValue = value;
-		} else {
-			savedValue = null;
-		}
-	}
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testelement/property/AbstractProperty.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testelement/property/AbstractProperty.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testelement/property/AbstractProperty.java	(working copy)
@@ -1,402 +0,0 @@
-/*
- * Copyright 2001-2005 The Apache Software Foundation.
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not
- * use this file except in compliance with the License. You may obtain a copy
- * of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- *  
- */
-
-package org.apache.jmeter.testelement.property;
-
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.Map;
-
-import org.apache.jmeter.testelement.TestElement;
-import org.apache.jorphan.logging.LoggingManager;
-import org.apache.log.Logger;
-
-/**
- * @version $Revision$
- */
-public abstract class AbstractProperty implements JMeterProperty {
-    //TODO consider using private logs for each derived class
-	protected static final Logger log = LoggingManager.getLoggerForClass();
-
-	private String name;
-
-	transient private boolean runningVersion = false;
-
-	// private static StringProperty defaultProperty = new StringProperty();
-
-	public AbstractProperty(String name) {
-		if (name == null)
-			throw new IllegalArgumentException("Name cannot be null");
-		this.name = name;
-	}
-
-	public AbstractProperty() {
-		this("");
-	}
-
-	protected boolean isEqualType(JMeterProperty prop) {
-		if (this.getClass().equals(prop.getClass())) {
-			return true;
-		} else {
-			return false;
-		}
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see JMeterProperty#isRunningVersion()
-	 */
-	public boolean isRunningVersion() {
-		return runningVersion;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see JMeterProperty#getName()
-	 */
-	public String getName() {
-		return name;
-	}
-
-	public void setName(String name) {
-		if (name == null)
-			throw new IllegalArgumentException("Name cannot be null");
-		this.name = name;
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see JMeterProperty#setRunningVersion(boolean)
-	 */
-	public void setRunningVersion(boolean runningVersion) {
-		this.runningVersion = runningVersion;
-	}
-
-	protected PropertyIterator getIterator(Collection values) {
-		return new PropertyIteratorImpl(values);
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see Object#clone()
-	 */
-	public Object clone() {
-		try {
-			AbstractProperty prop = (AbstractProperty) this.getClass().newInstance();
-			prop.name = name;
-			prop.runningVersion = runningVersion;
-			return prop;
-		} catch (InstantiationException e) {
-			return null;
-		} catch (IllegalAccessException e) {
-			return null;
-		}
-	}
-
-	/**
-	 * Returns 0 if string is invalid or null.
-	 * 
-	 * @see JMeterProperty#getIntValue()
-	 */
-	public int getIntValue() {
-		String val = getStringValue();
-		if (val == null) {
-			return 0;
-		}
-		try {
-			return Integer.parseInt(val);
-		} catch (NumberFormatException e) {
-			return 0;
-		}
-	}
-
-	/**
-	 * Returns 0 if string is invalid or null.
-	 * 
-	 * @see JMeterProperty#getLongValue()
-	 */
-	public long getLongValue() {
-		String val = getStringValue();
-		if (val == null) {
-			return 0;
-		}
-		try {
-			return Long.parseLong(val);
-		} catch (NumberFormatException e) {
-			return 0;
-		}
-	}
-
-	/**
-	 * Returns 0 if string is invalid or null.
-	 * 
-	 * @see JMeterProperty#getDoubleValue()
-	 */
-	public double getDoubleValue() {
-		String val = getStringValue();
-		if (val == null) {
-			return 0;
-		}
-		try {
-			return Double.parseDouble(val);
-		} catch (NumberFormatException e) {
-			log.error("Tried to parse a non-number string to an integer", e);
-			return 0;
-		}
-	}
-
-	/**
-	 * Returns 0 if string is invalid or null.
-	 * 
-	 * @see JMeterProperty#getFloatValue()
-	 */
-	public float getFloatValue() {
-		String val = getStringValue();
-		if (val == null) {
-			return 0;
-		}
-		try {
-			return Float.parseFloat(val);
-		} catch (NumberFormatException e) {
-			log.error("Tried to parse a non-number string to an integer", e);
-			return 0;
-		}
-	}
-
-	/**
-	 * Returns false if string is invalid or null.
-	 * 
-	 * @see JMeterProperty#getBooleanValue()
-	 */
-	public boolean getBooleanValue() {
-		String val = getStringValue();
-		if (val == null) {
-			return false;
-		}
-		return Boolean.valueOf(val).booleanValue();
-	}
-
-	/**
-	 * Determines if the two objects are equal by comparing names and values
-	 * 
-	 * @return true if names are equal and values are equal (or both null)
-	 */
-	public boolean equals(Object o) {
-		if (!(o instanceof JMeterProperty))
-			return false;
-		if (this == o)
-			return true;
-		JMeterProperty jpo = (JMeterProperty) o;
-		if (!name.equals(jpo.getName()))
-			return false;
-		String s1 = getStringValue();
-		String s2 = jpo.getStringValue();
-		return s1 == null ? s2 == null : s1.equals(s2);
-	}
-
-	public int hashCode() {
-		int result = 17;
-		result = result * 37 + name.hashCode();// name cannot be null
-		String s = getStringValue();
-		result = result * 37 + (s == null ? 0 : s.hashCode());
-		return result;
-	}
-
-	/**
-	 * Compares two JMeterProperty object values. N.B. Does not compare names
-	 * 
-	 * @param arg0
-	 *            JMeterProperty to compare against
-	 * @return 0 if equal values or both values null; -1 otherwise
-	 * @see Comparable#compareTo(Object)
-	 */
-	public int compareTo(Object arg0) {
-		if (arg0 instanceof JMeterProperty) {
-			// We don't expect the string values to ever be null. But (as in
-			// bug 19499) sometimes they are. So have null compare less than
-			// any other value. Log a warning so we can try to find the root
-			// cause of the null value.
-			String val = getStringValue();
-			String val2 = ((JMeterProperty) arg0).getStringValue();
-			if (val == null) {
-				log.warn("Warning: Unexpected null value for property: " + name);
-
-				if (val2 == null) {
-					// Two null values -- return equal
-					return 0;
-				} else {
-					return -1;
-				}
-			}
-			return val.compareTo(val2);
-		} else {
-			return -1;
-		}
-	}
-
-	/**
-	 * Get the property type for this property. Used to convert raw values into
-	 * JMeterProperties.
-	 */
-	protected Class getPropertyType() {
-		return getClass();
-	}
-
-	protected JMeterProperty getBlankProperty() {
-		try {
-			JMeterProperty prop = (JMeterProperty) getPropertyType().newInstance();
-			if (prop instanceof NullProperty) {
-				return new StringProperty();
-			}
-			return prop;
-		} catch (Exception e) {
-			return new StringProperty();
-		}
-	}
-
-	protected static JMeterProperty getBlankProperty(Object item) {
-		if (item == null) {
-			return new NullProperty();
-		}
-		if (item instanceof String) {
-			return new StringProperty("", item.toString());
-		} else if (item instanceof Boolean) {
-			return new BooleanProperty("", ((Boolean) item).booleanValue());
-		} else if (item instanceof Float) {
-			return new FloatProperty("", ((Float) item).floatValue());
-		} else if (item instanceof Double) {
-			return new DoubleProperty("", ((Double) item).doubleValue());
-		} else if (item instanceof Integer) {
-			return new IntegerProperty("", ((Integer) item).intValue());
-		} else if (item instanceof Long) {
-			return new LongProperty("", ((Long) item).longValue());
-		} else if (item instanceof Long) {
-			return new LongProperty("", ((Long) item).longValue());
-		} else {
-			return new StringProperty("", item.toString());
-		}
-	}
-
-	protected Collection normalizeList(Collection coll) {
-		Iterator iter = coll.iterator();
-		Collection newColl = null;
-		while (iter.hasNext()) {
-			Object item = iter.next();
-			if (newColl == null) {
-				try {
-					newColl = (Collection) coll.getClass().newInstance();
-				} catch (Exception e) {
-					log.error("Bad collection", e);
-				}
-			}
-			newColl.add(convertObject(item));
-		}
-		if (newColl != null) {
-			return newColl;
-		} else {
-			return coll;
-		}
-	}
-
-	/**
-	 * Given a Map, it converts the Map into a collection of JMeterProperty
-	 * objects, appropriate for a MapProperty object.
-	 */
-	protected Map normalizeMap(Map coll) {
-		Iterator iter = coll.entrySet().iterator();
-		Map newColl = null;
-		while (iter.hasNext()) {
-			Map.Entry entry = (Map.Entry) iter.next();
-            Object item = entry.getKey();
-			Object prop = entry.getValue();
-			if (newColl == null) {
-				try {
-					newColl = (Map) coll.getClass().newInstance();
-				} catch (Exception e) {
-					log.error("Bad collection", e);
-				}
-			}
-			newColl.put(item, convertObject(prop));
-		}
-		if (newColl != null) {
-			return newColl;
-		} else {
-			return coll;
-		}
-	}
-
-	public static JMeterProperty createProperty(Object item) {
-		JMeterProperty prop = makeProperty(item);
-		if (prop == null) {
-			prop = getBlankProperty(item);
-		}
-		return prop;
-	}
-
-	/**
-	 * @param item
-	 * @return
-	 */
-	protected static JMeterProperty makeProperty(Object item) {
-		if (item instanceof JMeterProperty) {
-			return (JMeterProperty) item;
-		}
-		if (item instanceof TestElement) {
-			return new TestElementProperty(((TestElement) item).getPropertyAsString(TestElement.NAME),
-					(TestElement) item);
-		}
-		if (item instanceof Collection) {
-			return new CollectionProperty("" + item.hashCode(), (Collection) item);
-		}
-		if (item instanceof Map) {
-			return new MapProperty("" + item.hashCode(), (Map) item);
-		}
-		return null;
-	}
-
-	protected JMeterProperty convertObject(Object item) {
-		JMeterProperty prop = makeProperty(item);
-		if (prop == null) {
-			prop = getBlankProperty();
-			prop.setName("" + item.hashCode());
-			prop.setObjectValue(item);
-		}
-		return prop;
-	}
-
-	/**
-	 * Provides the string representation of the property.
-	 * 
-	 * @return the string value
-	 */
-	public String toString() {
-		// N.B. Other classes rely on this returning just the string.
-		return getStringValue();
-	}
-
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see org.apache.jmeter.testelement.property.JMeterProperty#mergeIn(org.apache.jmeter.testelement.property.JMeterProperty)
-	 */
-	public void mergeIn(JMeterProperty prop) {
-	}
-}
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testelement/property/StringProperty.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testelement/property/StringProperty.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/testelement/property/StringProperty.java	(working copy)
@@ -23,76 +23,85 @@
  * @version $Revision$
  */
 public class StringProperty extends AbstractProperty {
-	private String value;
 
-	private transient String savedValue;
+    private String value;
 
-	public StringProperty(String name, String value) {
-		super(name);
-		this.value = value;
-	}
+    private transient String savedValue;
 
-	public StringProperty() {
-		super();
-	}
+    public StringProperty(String name, String value) {
+        super(name);
+        this.value = value;
+    }
 
-	/**
-	 * @see JMeterProperty#setRunningVersion(boolean)
-	 */
-	public void setRunningVersion(boolean runningVersion) {
-		super.setRunningVersion(runningVersion);
-		if (runningVersion) {
-			savedValue = value;
-		} else {
-			savedValue = null;
-		}
-	}
+    public StringProperty() {
+        super();
+    }
 
-	public void setObjectValue(Object v) {
-		value = v.toString();
-	}
+    /**
+     * @see JMeterProperty#setRunningVersion(boolean)
+     */
+    public void setRunningVersion(boolean runningVersion) {
+        super.setRunningVersion(runningVersion);
+        if (runningVersion) {
+            savedValue = value;
+        } else {
+            savedValue = null;
+        }
+    }
 
-	/**
-	 * @see JMeterProperty#getStringValue()
-	 */
-	public String getStringValue() {
-		return value;
-	}
+    public void setObjectValue(Object v) {
+        value = v.toString();
+    }
 
-	/**
-	 * @see JMeterProperty#getObjectValue()
-	 */
-	public Object getObjectValue() {
-		return value;
-	}
+    /**
+     * @see JMeterProperty#getStringValue()
+     */
+    public String getStringValue() {
+        return value;
+    }
 
-	/**
-	 * @see Object#clone()
-	 */
-	public Object clone() {
-		StringProperty prop = (StringProperty) super.clone();
-		prop.value = value;
-		return prop;
-	}
+    /**
+     * 
+     * @param value
+     */
+    public void setStringValue(String value) {
+        setValue(value);
+    }
 
-	/**
-	 * Sets the value.
-	 * 
-	 * @param value
-	 *            The value to set
-	 */
-	public void setValue(String value) {
-		this.value = value;
-	}
+    /**
+     * @see JMeterProperty#getObjectValue()
+     */
+    public Object getObjectValue() {
+        return value;
+    }
 
-	/*
-	 * (non-Javadoc)
-	 * 
-	 * @see JMeterProperty#recoverRunningVersion(TestElement)
-	 */
-	public void recoverRunningVersion(TestElement owner) {
-		if (savedValue != null) {
-			value = savedValue;
-		}
-	}
+    /**
+     * @see Object#clone()
+     */
+    public Object clone() {
+        StringProperty prop = (StringProperty) super.clone();
+        prop.value = value;
+        return prop;
+    }
+
+    /**
+     * Sets the value.
+     * 
+     * @param value
+     *            The value to set
+     */
+    public void setValue(String value) {
+        this.value = value;
+    }
+
+    /*
+     * (non-Javadoc)
+     * 
+     * @see JMeterProperty#recoverRunningVersion(TestElement)
+     */
+    public void recoverRunningVersion(TestElement owner) {
+        if (savedValue != null) {
+            value = savedValue;
+        }
+    }
 }
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/threads/JMeterThread.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/threads/JMeterThread.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/threads/JMeterThread.java	(working copy)
@@ -501,14 +501,18 @@
 	}
 
 	private class IterationListener implements LoopIterationListener {
-		/*
-		 * (non-Javadoc)
-		 * 
-		 * @see LoopIterationListener#iterationStart(LoopIterationEvent)
+		/**
+         * @see LoopIterationListener#iterationStart(LoopIterationEvent)
 		 */
 		public void iterationStart(LoopIterationEvent iterEvent) {
 			notifyTestListeners();
 		}
+
+        /**
+         * @see LoopIterationListener#iterationEnd(LoopIterationEvent)
+         */
+        public void iterationEnd(LoopIterationEvent iterEvent) {
+        }
 	}
 
 	/**
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/engine/event/LoopIterationListener.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/engine/event/LoopIterationListener.java	(revision 424985)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/engine/event/LoopIterationListener.java	(working copy)
@@ -20,4 +20,5 @@
 
 public interface LoopIterationListener {
 	public void iterationStart(LoopIterationEvent iterEvent);
+    public void iterationEnd(LoopIterationEvent iterEvent);
 }
Index: D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/util/JMeterVersion.java
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/util/JMeterVersion.java	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/src/core/org/apache/jmeter/util/JMeterVersion.java	(working copy)
@@ -41,7 +41,7 @@
 	 * JMeterUtils This ensures that JMeterUtils always gets the correct
 	 * version, even if it is not re-compiled during the build.
 	 */
-	private static final String VERSION = "2.1.2";
+	private static final String VERSION = "2.2-SNAPSHOT";
 
 	static final String COPYRIGHT = "Copyright (c) 1998-2006 The Apache Software Foundation";
 
Index: D:/Development/Eclipse/Workspace/jmeter/build.xml
===================================================================
--- D:/Development/Eclipse/Workspace/jmeter/build.xml	(revision 424313)
+++ D:/Development/Eclipse/Workspace/jmeter/build.xml	(working copy)
@@ -201,6 +201,7 @@
   <property name="src.monitor.model" value="src/monitor/model"/>
   <property name="src.jms" value="src/protocol/jms"/>
   <property name="src.report" value="src/reports"/>
+  <property name="src.ejb" value="src/protocol/ejb"/>
 
   <!-- Where the documentation sources live -->
   <property name="src.docs" value="xdocs"/>
@@ -252,6 +253,7 @@
   <property name="build.jms" location="build/protocol/jms"/>
   <property name="build.report" location="build/reports"/>
   <property name="build.test" location="build/test"/>
+  <property name="build.ejb" value="build/protocol/ejb"/>
   
   <!-- Path prefix to allow Anakia to find stylesheets if running under Eclipse -->
   <!--
@@ -329,6 +331,8 @@
   <property name="excalibur-instrument.jar" value="${lib.dir}/excalibur-instrument-1.0.jar"/>
   <property name="xstream.jar" value="${lib.dir}/xstream-1.1.3.jar"/>
   <property name="xpp3.jar" value="${lib.dir}/xpp3_min-1.1.3.4.I.jar"/>
+  <property name="geronimo-spec-j2ee.jar" value="${lib.dir}/geronimo-spec-j2ee-1.4-rc4.jar"/>
+  <property name="bsh.jar" value="${lib.dir}/bsh-1.3.0.jar"/>
 	  
   <!-- The following 3 jars are probably optional for JDK1.4 -->
   <property name="xalan.jar" value="${lib.dir}/xalan.jar"/>
@@ -378,6 +382,8 @@
     <include name="${batik-awt-util.jar}"/>
     <include name="${xstream.jar}"/>
     <include name="${xpp3.jar}"/>
+  	<include name="${geronimo-spec-j2ee.jar}"/>
+  	<include name="${bsh.jar}"/>
   </patternset>
 
   <!--
@@ -460,6 +466,9 @@
     <available classname="javax.jms.Message" property="jms.present">
       <classpath refid="classpath"/>
     </available>
+  	<available classname="javax.ejb.EJBHome" property="ejb.present">
+      <classpath refid="classpath"/>
+	</available>
   </target>
   
   <!--
@@ -484,9 +493,13 @@
   <target name="jms-message" depends="check-libs" unless="jms.present">
     <echo message="Classes for JMS support not found in classpath"/>
   </target>
+	
+  <target name="ejb-message" depends="check-libs" unless="ejb.present">
+    <echo message="Classes for EJB support not found in classpath"/>
+  </target>
 
   <target name="report-missing-libs" 
-      depends="ssl-message,mail-message,beanshell-message,htmlparser16-message,jms-message"
+      depends="ssl-message,mail-message,beanshell-message,htmlparser16-message,jms-message,ejb-message"
   />
 
   <!--
@@ -566,7 +579,7 @@
       </classpath>
     </javac>
   </target>
-
+  
   <target name="compile-htmlparser16" depends="compile-http,compile-htmlparser" description="Compile htmlparser 1.6 support" if="htmlparser16.present">
     <mkdir dir="${build.htmlparser16}"/>
     <javac srcdir="${src.htmlparser16}" destdir="${build.htmlparser16}" optimize="${optimize}" debug="on" source="${src.java.version}" target="${target.java.version}" deprecation="${deprecation}" encoding="${encoding}">
@@ -709,7 +722,7 @@
     </javac>
   </target>
 
-  <target name="compile-protocols" depends="compile-http,compile-htmlparser16,compile-ftp,compile-jdbc,compile-java,compile-ldap,compile-mail,compile-tcp" description="Compile all protocol-specific components."/>
+  <target name="compile-protocols" depends="compile-http,compile-htmlparser16,compile-ftp,compile-jdbc,compile-java,compile-ldap,compile-mail,compile-tcp,compile-ejb" description="Compile all protocol-specific components."/>
 
   <target name="compile-examples" depends="compile-jorphan,compile-core" description="Compile example components.">
     <mkdir dir="${build.examples}"/>
@@ -804,6 +817,20 @@
       </classpath>
     </javac>
   </target>
+	
+  <target name="compile-ejb" depends="compile-jorphan,compile-core" 
+	      	description="Compile components specific to EJB sampling."
+					if="ejb.present">
+	<mkdir dir="${build.ejb}"/>
+    <javac srcdir="${src.ejb}" destdir="${build.ejb}" source="${src.java.version}" optimize="${optimize}" debug="on" target="${target.java.version}" deprecation="${deprecation}" encoding="${encoding}">
+      <include name="**/*.java"/>
+      <classpath>
+        <path refid="classpath"/>
+        <pathelement location="${build.jorphan}"/>
+        <pathelement location="${build.core}"/>
+      </classpath>
+    </javac>
+  </target>
 
   <target name="compile" 
   depends="compile-core,compile-components,compile-functions,compile-protocols,compile-rmi,compile-htmlparser,compile-monitor,compile-junit,compile-jms,compile-report"
@@ -1080,6 +1107,14 @@
            <attribute name="X-Compile-Target-JDK" value="${target.java.version}"/>
     	</manifest>
     </jar>
+  	
+  	<!-- ejb -->
+    <!-- Ensure that build dir exists, even if JMS has not been built -->
+    <mkdir dir="${build.ejb}"/>
+    <jar jarfile="${dest.jar}/ApacheJMeter_ejb.jar">
+      <fileset dir="${build.ejb}" includes="**/*.class" />
+      <fileset dir="${src.ejb}" includes="**/*.properties" />
+    </jar>
     
     <jar jarfile="${lib.dir}/htmlparser.jar" manifest="MANIFEST">
         <fileset dir="${build.htmlparser}" includes="**/*.class" excludes="org/htmlparser/tests/**/*.class"/>
@@ -1142,6 +1177,7 @@
     <property name="javamail.complete" value="assume"/>
     <property name="beanshell.present" value="assume"/>
     <property name="jms.present" value="assume"/>
+  	<property name="ejb.present" value="assume"/>
     <property name="htmlparser16.present" value="assume"/>
   </target>
 
@@ -1648,7 +1684,7 @@
    <java classname="org.apache.jorphan.test.AllTests" fork="yes" dir="${basedir}/bin">
       <classpath>
     	<fileset dir="${dest.jar}" includes="*.jar"/>
-        <pathelement location="${build.test}"/>
+	    <pathelement location="${build.test}"/>
     	<fileset dir="${lib.dir}" includes="htmlparser.jar"/>
     	<fileset dir="${lib.dir}" includes="htmlparserparser.jar"/>
     	<path refid="classpath"/>
@@ -1712,7 +1748,7 @@
 -->
     <java classname="org.htmlparser.tests.AllTests" fork="yes" failonerror="yes">
       <classpath>
-	<pathelement location="${build.htmlparser}"/>
+	    <pathelement location="${build.htmlparser}"/>
         <pathelement location="${lib.dir}/htmlparser.jar"/>
         <pathelement location="${junit.jar}"/>
         <pathelement location="${log-kit.jar}"/>
@@ -1720,5 +1756,5 @@
       <arg value="-text"/>
     </java>
   </target>
-  
+
 </project>
Index: D:/Development/Eclipse/Workspace/jmeter/lib/geronimo-spec-j2ee-1.4-rc4.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: D:\Development\Eclipse\Workspace\jmeter\lib\geronimo-spec-j2ee-1.4-rc4.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: D:/Development/Eclipse/Workspace/jmeter/lib/geronimo-spec-javamail-1.3.1-rc5.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: D:\Development\Eclipse\Workspace\jmeter\lib\geronimo-spec-javamail-1.3.1-rc5.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Index: D:/Development/Eclipse/Workspace/jmeter/lib/activation-1.0.2.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: D:\Development\Eclipse\Workspace\jmeter\lib\activation-1.0.2.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

